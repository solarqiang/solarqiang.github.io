<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="b6sfFZ2JS42hoER_mUyRDfihbdCJv_T81PvPJY4zjM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"solarqiang.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":280,"display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Android 广播机制介绍 类似于发布-订阅设计模式，Android 应用可以与其他应用相互收发广播消息，还可以接收 Android 系统的广播消息。例如，Android 系统会在系统启动或设备开始充电时发送广播。再比如，应用可以发送自定义广播来通知其他应用它们可能感兴趣的事件。 应用可以注册接收特定的广播，这样系统会在广播发出后传送给这些应用。 按发送方式分类，广播可分为有序广播、常规广播、">
<meta property="og:type" content="article">
<meta property="og:title" content="Broadcast 源码分析">
<meta property="og:url" content="https://solarqiang.github.io/posts/3752956090/">
<meta property="og:site_name" content="小强的开发笔记">
<meta property="og:description" content="Android 广播机制介绍 类似于发布-订阅设计模式，Android 应用可以与其他应用相互收发广播消息，还可以接收 Android 系统的广播消息。例如，Android 系统会在系统启动或设备开始充电时发送广播。再比如，应用可以发送自定义广播来通知其他应用它们可能感兴趣的事件。 应用可以注册接收特定的广播，这样系统会在广播发出后传送给这些应用。 按发送方式分类，广播可分为有序广播、常规广播、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/registerBroadcast.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendBroadcast.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendRegisteredBroadcast.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendOrderedBroadcast.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity.svg">
<meta property="article:published_time" content="2020-02-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-09T17:38:32.817Z">
<meta property="article:author" content="solarqiang">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://solarqiang.github.io/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/registerBroadcast.svg">

<link rel="canonical" href="https://solarqiang.github.io/posts/3752956090/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Broadcast 源码分析 | 小强的开发笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小强的开发笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://solarqiang.github.io/posts/3752956090/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="solarqiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小强的开发笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Broadcast 源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-10T00:00:00+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-10 01:38:32" itemprop="dateModified" datetime="2024-01-10T01:38:32+08:00">2024-01-10</time>
              </span>

          
            <span id="/posts/3752956090/" class="post-meta-item leancloud_visitors" data-flag-title="Broadcast 源码分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="android-广播机制介绍"><a class="markdownIt-Anchor" href="#android-广播机制介绍"></a> Android 广播机制介绍</h1>
<p>类似于发布-订阅设计模式，Android 应用可以与其他应用相互收发广播消息，还可以接收 Android 系统的广播消息。例如，Android 系统会在系统启动或设备开始充电时发送广播。再比如，应用可以发送自定义广播来通知其他应用它们可能感兴趣的事件。</p>
<p>应用可以注册接收特定的广播，这样系统会在广播发出后传送给这些应用。</p>
<p>按发送方式分类，广播可分为有序广播、常规广播、本地广播；按定义方式分类，可分为系统广播、自定义广播。此外，广播接收器可分为清单声明的接收器与上下文注册的接收器。</p>
<span id="more"></span>
<h2 id="接收广播"><a class="markdownIt-Anchor" href="#接收广播"></a> 接收广播</h2>
<h3 id="清单声明的接收器"><a class="markdownIt-Anchor" href="#清单声明的接收器"></a> 清单声明的接收器</h3>
<p>如果在清单中声明广播接收器，系统会在广播发出后启动该应用。</p>
<p>使用方法：</p>
<ol>
<li>在应用清单中指定 <code>&lt;receiver&gt;</code> 元素，<code>&lt;intent-filter&gt;</code> 指定订阅的广播操作。</li>
<li>创建 <code>BroadcastReceiver </code>子类，实现 <code>onReceive(Context, Intent)</code> 方法。</li>
</ol>
<p>系统软件包管理器会在应用安装时注册接收器。</p>
<h3 id="上下文注册的接收器"><a class="markdownIt-Anchor" href="#上下文注册的接收器"></a> 上下文注册的接收器</h3>
<p>使用方法：</p>
<ol>
<li>创建 <code>BroadcastReceiver</code> 子类并实例化。</li>
<li>创建 <code>IntentFilter</code> 并调用 <code>registerReceiver(BroadcastReceiver, IntentFilter)</code> 注册接收器。只要注册上下文有效，接收器就会接收到广播。</li>
<li>如有需要，调用<code>unregisterReceiver(android.content.BroadcastReceiver)</code> 停止接收广播。</li>
</ol>
<h3 id="对进程状态的影响"><a class="markdownIt-Anchor" href="#对进程状态的影响"></a> 对进程状态的影响</h3>
<blockquote>
<p><code>BroadcastReceiver</code> 的状态（无论它是否在运行）会影响其所在进程的状态，而其所在进程的状态又会影响它被系统终结的可能性。例如，当进程执行接收器（即当前在运行其 <code>onReceive()</code> 方法中的代码）时，它被认为是前台进程。除非遇到极大的内存压力，否则系统会保持该进程运行。</p>
<p>但是，一旦从 <code>onReceive()</code> 返回代码，BroadcastReceiver 就不再活跃。接收器的宿主进程变得与在其中运行的其他应用组件一样重要。如果该进程仅托管清单声明的接收器（这对于用户从未与之互动或最近没有与之互动的应用很常见），则从 <code>onReceive()</code> 返回时，系统会将其进程视为低优先级进程，并可能会将其终止，以便将资源提供给其他更重要的进程使用。</p>
</blockquote>
<h2 id="发送广播"><a class="markdownIt-Anchor" href="#发送广播"></a> 发送广播</h2>
<p>Android 为应用提供三种方式来发送广播：</p>
<ul>
<li>
<p><code>sendOrderedBroadcast(Intent, String)</code> 方法发送<strong>有序广播</strong>。系统按接收器的优先级逐个顺序向接收器发送广播，上一个接收器处理完广播后才发送广播到下一个接收器。当接收器逐个顺序执行时，接收器可以向下传递结果，也可以完全中止广播，使其不再传递给其他接收器。接收器的运行顺序可以通过匹配的 intent-filter 的 android:priority 属性来控制；具有相同优先级的接收器将按随机顺序运行。</p>
</li>
<li>
<p><code>sendBroadcast(Intent)</code> 方法发送<strong>常规广播</strong>。系统会按随机的顺序向所有接收器发送广播。这种方法效率更高，但也意味着接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播。</p>
</li>
<li>
<p><code>LocalBroadcastManager.sendBroadcast</code> 方法发送<strong>本地广播</strong>。这种广播只会发送给与发送器位于同一应用中的接收器，适用于无需跨应用发送广播的场景。这种实现方法的效率更高（无需进行进程间通信），而且无需担心其他应用在收发您的广播时带来的任何安全问题。</p>
</li>
</ul>
<p>当 BroadcastReceiver 接收到有序广播后，在 <code>onReceive</code> 方法内：</p>
<ul>
<li>使用 <code>getResultCode</code>，<code>getResultData</code>,<code>getResultExtras</code> 方法取得上个广播接收器返回的结果；</li>
<li>使用 <code>setResult(int, String, Bundle)</code> 以及对应的 set 方法设置结果传递给下个广播接收器；</li>
<li>使用 <code>abortBroadcast()</code> 方法来中止广播，使其不再传递给下个接收器。</li>
</ul>
<h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1>
<p>广播机制的“注册中心”，是由 ActivityManagerService 来担当的，这个系统组件负责处理广播接收器的注册请求，收取所有发送的广播，根据广播类型找到相应的接收器，最后将广播发送给接收器们处理。</p>
<h2 id="注册接收器"><a class="markdownIt-Anchor" href="#注册接收器"></a> 注册接收器</h2>
<h3 id="清单声明的接收器静态注册"><a class="markdownIt-Anchor" href="#清单声明的接收器静态注册"></a> 清单声明的接收器（静态注册）</h3>
<p>TODO</p>
<h3 id="上下文注册的接收器动态注册"><a class="markdownIt-Anchor" href="#上下文注册的接收器动态注册"></a> 上下文注册的接收器（动态注册）</h3>
<p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/registerBroadcast.svg" alt="注册广播接收器时序图" /></p>
<p>应用调用 Activity/Service 的 <code>registerReceiver</code> 方法注册接收器，而 Activity/Service 都继承于 Context 抽象类，最终调用的实现在 <code>ContextImpl.registerReceiverInternal</code> 方法中。</p>
<h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Intent <span class="title function_">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        IntentFilter filter, String broadcastPermission,</span></span><br><span class="line"><span class="params">        Handler scheduler, Context context, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">IIntentReceiver</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span> &amp;&amp; context != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="literal">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="literal">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> <span class="title class_">LoadedApk</span>.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="literal">null</span>, <span class="literal">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> ActivityManager.getService().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                broadcastPermission, userId, flags);</span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mPackageInfo</code> 是 LoadedApk 类型对象，在应用启动时创建。</p>
<p>如果 <code>scheduler</code> 参数没有指定 Handler， 会获取主线程的 Handler。</p>
<p>将广播接收器 <code>receiver</code> 封装成 LoadedApk.ReceiverDispatcher 对象，包含了传入的 BroadcastReceiver，调用者的 Context，用于处理的 Handler，主线程的 Instrumentation（用于测试）。这个 ReceiverDispatcher 对象包含一个实现了 <code>IIntentReceiver</code> AIDL 接口的 InnerReceivcer 对象 <code>mIIntentReceiver</code>。</p>
<p>如果 <code>mPackageInfo</code> 对象和 <code>context</code> 参数都不为空，使用 <code>LoadedApk.getReceiverDispatcher</code> 方法获取该对象，同时在 LoadedApk 的 <code>mReceivers</code> 成员注册该 ReceiverDispatcher；否则，创建 ReceiverDispatcher 对象并使用 <code>getIIntentReceiver()</code> 方法返回其 InnerReceivcer 对象。</p>
<p>通过 Binder 调用 ActivityManagerService 的 <code>registerReceiver</code> 方法，传入封装的 InnerReceivcer 对象、 IntentFilter 和其他调用者相关的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Intent <span class="title function_">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span><br><span class="line"><span class="params">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">            callerApp = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (callerApp == <span class="literal">null</span>) &#123;...&#125; <span class="comment">// throw SecurityException</span></span><br><span class="line">            <span class="keyword">if</span> (callerApp.info.uid != SYSTEM_UID &amp;&amp;</span><br><span class="line">                    !callerApp.pkgList.containsKey(callerPackage) &amp;&amp;</span><br><span class="line">                    !<span class="string">&quot;android&quot;</span>.equals(callerPackage)) &#123;...&#125; <span class="comment">// throw SecurityException</span></span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callerPackage = <span class="literal">null</span>;</span><br><span class="line">            callingUid = Binder.getCallingUid();</span><br><span class="line">            callingPid = Binder.getCallingPid();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">        <span class="keyword">if</span> (actions == <span class="literal">null</span>) &#123;...&#125; <span class="comment">// 新建空白迭代器</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>首先使用 <code>getRecordForAppLocked</code> 获取调用者（<code>caller</code>）的 <code>ProcessRecord</code>，如果找不到这个应用，或者应用不在运行，则抛出 SecurityException。如果 <code>caller</code> 为 <code>null</code>，则使用 Binder 获取其 UID 和 PID。</p>
<p>获取 IntentFilter 的 actions 迭代器（如果为空，就新建空白迭代器）。</p>
<h3 id="匹配粘性广播"><a class="markdownIt-Anchor" href="#匹配粘性广播"></a> 匹配粘性广播</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Collect stickies of users</span></span><br><span class="line">    <span class="type">int</span>[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">    <span class="keyword">while</span> (actions.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> actions.next();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : userIds) &#123;</span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">            <span class="keyword">if</span> (stickies != <span class="literal">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                <span class="keyword">if</span> (intents != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stickyIntents == <span class="literal">null</span>) &#123;</span><br><span class="line">                        stickyIntents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Intent&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    stickyIntents.addAll(intents);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//离开临界区</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Intent&gt; allSticky = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (stickyIntents != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> mContext.getContentResolver();</span><br><span class="line">    <span class="comment">// Look for any matching sticky broadcasts...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> stickyIntents.get(i);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (filter.match(resolver, intent, <span class="literal">true</span>, TAG) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allSticky == <span class="literal">null</span>) &#123;</span><br><span class="line">                allSticky = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Intent&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            allSticky.add(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The first sticky in the list is returned directly back to the client.</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">sticky</span> <span class="operator">=</span> allSticky != <span class="literal">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="literal">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (receiver == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 actions 迭代器，寻找全局和调用者所属用户的粘性广播列表中 Intent action 匹配的广播，将结果添加到 <code>stickyIntents</code> 列表。</p>
<p>离开临界区，如果获取到了匹配的粘性广播，遍历结果列表，使用 <code>IntentFilter.match</code> 方法进一步匹配 IntentFilter 的其他属性，将最终结果添加到 <code>allSticky</code> 列表。</p>
<p>如果有获取到粘性广播，将列表中的第一个粘性广播赋值给 <code>sticky</code>，准备之后返回给调用者。</p>
<p>如果广播接收器为 <code>null</code>，在这里直接将结果 <code>sticky</code> 返回。</p>
<h3 id="注册广播接收器"><a class="markdownIt-Anchor" href="#注册广播接收器"></a> 注册广播接收器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callerApp != <span class="literal">null</span> &amp;&amp; (callerApp.thread == <span class="literal">null</span></span><br><span class="line">            || callerApp.thread.asBinder() != caller.asBinder())) &#123;</span><br><span class="line">        <span class="comment">// Original caller already died</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ReceiverList</span> <span class="variable">rl</span> <span class="operator">=</span> mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">    <span class="keyword">if</span> (rl == <span class="literal">null</span>) &#123;</span><br><span class="line">        rl = <span class="keyword">new</span> <span class="title class_">ReceiverList</span>(<span class="built_in">this</span>, callerApp, callingPid, callingUid,</span><br><span class="line">                userId, receiver);</span><br><span class="line">        <span class="keyword">if</span> (rl.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalReceiversForApp</span> <span class="operator">=</span> rl.app.receivers.size();</span><br><span class="line">            <span class="keyword">if</span> (totalReceiversForApp &gt;= MAX_RECEIVERS_ALLOWED_PER_APP) &#123;...&#125; <span class="comment">// throw IllegalStateException</span></span><br><span class="line">            rl.app.receivers.add(rl);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                receiver.asBinder().linkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> sticky;</span><br><span class="line">            &#125;</span><br><span class="line">            rl.linkedToDeath = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.uid != callingUid) &#123;...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.pid != callingPid) &#123;...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.userId != userId) &#123;...&#125; <span class="comment">// throw IllegalArgumentException</span></span><br><span class="line">    <span class="type">BroadcastFilter</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastFilter</span>(filter, rl, callerPackage,</span><br><span class="line">            permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">    <span class="keyword">if</span> (rl.containsFilter(filter)) &#123; ... <span class="comment">// 警告接收器已经注册</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rl.add(bf);</span><br><span class="line">        ... <span class="comment">//debugCheck</span></span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue broadcasts for all existing stickies that match</span></span><br><span class="line">    <span class="comment">// this filter.</span></span><br><span class="line">    <span class="keyword">if</span> (allSticky != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">receivers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        receivers.add(bf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">stickyCount</span> <span class="operator">=</span> allSticky.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stickyCount; i++) &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> allSticky.get(i);</span><br><span class="line">            <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">            <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, <span class="literal">null</span>,</span><br><span class="line">                    <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, OP_NONE, <span class="literal">null</span>, receivers,</span><br><span class="line">                    <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, -<span class="number">1</span>, <span class="literal">false</span>,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/* only PRE_BOOT_COMPLETED should be exempt, no stickies */</span>);</span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sticky;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先检查调用者进程是否还存活，如果已死，则返回 null。</p>
<p>从 <code>mRegisteredReceiveres</code> 获取当前接收器对应的接收器列表（<code>ReceiverList rl</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>mRegisteredReceiveres</code> 保存了所有注册的广播接收器，其 hash key为 当前接收器 IBinder 对象 IIntentReceiver，值为对应的接收器列表。ReceiverList 是 ArrayList&lt;BroadcastFilter&gt; 的子类，保存了调用者的 ProcessRecord、UID、PID、UserID 以及接收器 IIntentFilter 信息。</p>
<p>如果还没有对应的列表，就新建一个，加入到 <code>mRegisteredReceiveres</code> 中。如果有调用者应用信息，这时还要检查调用者应用注册的接收器总数是否达到上限，超限则抛出 IllegalStateException，没有超限则加入到调用者应用的接收器列表中。如果之前没有得到调用者应用信息，在这里就向接收器列表注册当前接收器的死亡回调，检查接收器所在进程是否存活，若死亡就返回 <code>sticky</code>。</p>
<p>判断获取的接收器列表中，UID/PID/UserID 是否与调用者的对应值相同，不同则抛出 IllegalArgumentException。</p>
<p>将广播接收器的接收器列表、IntentFilter、调用者、权限等信息封装到 BroadcastFilter 对象中。检查具有相同 IntentFilter 的接收器是否已存在于接收器列表中。如果没有，就将 BroadcastFilter 加入到接收器列表和 <code>mReceiverResolver</code> 中，也就完成了广播接收器的注册。</p>
<p>上面注册结束以后，如果筛选出了与当前注册的 IntentFilter 匹配的粘性广播列表，就将所有这些粘性广播逐条发送给当前的接收器 <code>receivers</code>，可以看到 <code>receivers</code> 里面就只有之前创建的一个 BroadcastFilter。最后返回 <code>sticky</code>。</p>
<p>总结一下，通过上下文注册的广播接收器会在这些地方留下记录：</p>
<ul>
<li>AMS 的 <code>mRegisteredReceivers</code> 成员中注册 BroadcastFilter</li>
<li>ProcessRecord 的 <code>receivers</code> 成员中注册 BroadcastFilter</li>
<li>LoadedApk 的 <code>mReceivers</code> 成员中注册 ReceiverDispatcher</li>
<li>AMS 的 <code>mReceiverResolver</code> 成员中注册 BroadcastFilter</li>
</ul>
<h2 id="注销接收器"><a class="markdownIt-Anchor" href="#注销接收器"></a> 注销接收器</h2>
<p>通过 <code>registerReceiver</code> 注册的接收器可以通过 <code>unRegisterReceiver</code> 方法来注销。</p>
<p>类似于其配对方法，实现位于 <code>ContextImpl.unRegisterReceiver</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">IIntentReceiver</span> <span class="variable">rd</span> <span class="operator">=</span> mPackageInfo.forgetReceiverDispatcher(</span><br><span class="line">                getOuterContext(), receiver);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().unregisterReceiver(rd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>forgetReceiverDispatcher</code> 移除 LoadedApk 中注册的 ReceiverDispatcher，再交由 AMS 的同名方法继续处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">doTrim</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">ReceiverList</span> <span class="variable">rl</span> <span class="operator">=</span> mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (rl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> rl.curBroadcast;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; r == r.queue.getMatchingOrderedReceiver(r)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">doNext</span> <span class="operator">=</span> r.queue.finishReceiverLocked(</span><br><span class="line">                            r, r.resultCode, r.resultData, r.resultExtras,</span><br><span class="line">                            r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">                        doTrim = <span class="literal">true</span>;</span><br><span class="line">                        r.queue.processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rl.app != <span class="literal">null</span>) &#123;</span><br><span class="line">                    rl.app.receivers.remove(rl);</span><br><span class="line">                &#125;</span><br><span class="line">                removeReceiverLocked(rl);</span><br><span class="line">                <span class="keyword">if</span> (rl.linkedToDeath) &#123;</span><br><span class="line">                    rl.linkedToDeath = <span class="literal">false</span>;</span><br><span class="line">                    rl.receiver.asBinder().unlinkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doTrim) &#123;</span><br><span class="line">            trimApplications(OomAdjuster.OOM_ADJ_REASON_FINISH_RECEIVER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注销接收器也就是在之前注册的地方移除对应的记录，此外还要从广播队列中移除该接收器。具体来说：</p>
<ul>
<li>在 <code>mRegisteredReceivers</code> 中，取得对应的接收器列表，再取得该列表中正在处理的广播，再取得该广播的广播队列，调用 <code>BroadcastQueue.finishReceiverLocked</code> 方法</li>
<li>从 ProcessRecord 的 <code>receivers</code>  成员中注销接收器；</li>
<li>调用 <code>removeReceiverLocked</code> 方法，从 <code>mRegisteredReceivers</code> 中注销接收器，从 <code>mReceiverResolver</code> 中移除 BroadcastFilter。</li>
</ul>
<h2 id="发送广播-2"><a class="markdownIt-Anchor" href="#发送广播-2"></a> 发送广播</h2>
<p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendBroadcast.svg" alt="加入广播到 BroadcastQueue" /></p>
<p>应用调用 Context 类的 <code>sendBroadcast</code> 系列方法，其实现位于 ContextImpl 中，最终调用 AMS 的 <code>broadcastIntent</code> 方法。</p>
<h3 id="初始验证"><a class="markdownIt-Anchor" href="#初始验证"></a> 初始验证</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span><br><span class="line"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> resultCode, String resultData, Bundle resultExtras,</span></span><br><span class="line"><span class="params">        String[] requiredPermissions, <span class="type">int</span> appOp, Bundle bOptions,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> serialized, <span class="type">boolean</span> sticky, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;broadcastIntent&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line">        ...... <span class="comment">// 准备调用 broadcastIntentLocked 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>verifyBroadcastLocked</code> 会判断广播的 Intent 是否合法：</p>
<ul>
<li>广播 Intent 不能包含文件描述符；</li>
<li>如果没有设置 <code>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</code> 或 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标志，不能在系统启动完成前广播；</li>
<li>不能设置 <code>FLAG_RECEIVER_BOOT_UPGRADE</code> 标志；</li>
<li>如果设置了 <code>FLAG_RECEIVER_FROM_SHELL</code> 标志，发送者必须以 root 或 shell 用户运行，否则该标志会被移除。</li>
</ul>
<p>最后调用 <code>broadcastIntentLocked</code> 方法。这个方法很长，分段来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span><br><span class="line"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">        IIntentReceiver resultTo, <span class="type">int</span> resultCode, String resultData,</span></span><br><span class="line"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="type">int</span> appOp, Bundle bOptions,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, <span class="type">int</span> realCallingUid,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> realCallingPid, <span class="type">int</span> userId, <span class="type">boolean</span> allowBackgroundActivityStarts)</span> &#123;</span><br><span class="line">    intent = <span class="keyword">new</span> <span class="title class_">Intent</span>(intent);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// By default broadcasts do not go to stopped apps.</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line">        <span class="comment">// If we have not finished booting, don&#x27;t allow this to launch new processes.</span></span><br><span class="line">        <span class="keyword">if</span> (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) &#123;</span><br><span class="line">            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line">        userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="literal">true</span>,</span><br><span class="line">                ALLOW_NON_FULL, <span class="string">&quot;broadcast&quot;</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that the user who is receiving this broadcast or its parent is running.</span></span><br><span class="line">        <span class="comment">// If not, we will just skip it. Make an exception for shutdown broadcasts, upgrade steps.</span></span><br><span class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserOrItsParentRunning(userId)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((callingUid != SYSTEM_UID</span><br><span class="line">                    || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>)</span><br><span class="line">                    &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Skipping broadcast of &quot;</span> + intent</span><br><span class="line">                        + <span class="string">&quot;: user &quot;</span> + userId + <span class="string">&quot; and its parent (if any) are stopped&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复制一份 Intent， 设置属性，使广播不能发送到停止的应用，不能在还没有启动完成时启动新进程。</p>
<p>判断广播可以送达的用户。广播不能向没有在运行的用户应用发送。</p>
<h3 id="后台执行限制相关"><a class="markdownIt-Anchor" href="#后台执行限制相关"></a> 后台执行限制相关</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line"><span class="type">BroadcastOptions</span> <span class="variable">brOptions</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (bOptions != <span class="literal">null</span>) &#123;</span><br><span class="line">    brOptions = <span class="keyword">new</span> <span class="title class_">BroadcastOptions</span>(bOptions);</span><br><span class="line">    <span class="keyword">if</span> (brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (brOptions.isDontSendToRestrictedApps()</span><br><span class="line">            &amp;&amp; !isUidActiveLocked(callingUid)</span><br><span class="line">            &amp;&amp; isBackgroundRestrictedNoCheck(callingUid, callerPackage)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Not sending broadcast &quot;</span> + action + <span class="string">&quot; - app &quot;</span> + callerPackage</span><br><span class="line">                + <span class="string">&quot; has background restrictions&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.START_CANCELED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (brOptions.allowsBackgroundActivityStarts()) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入了 <code>bOptions</code> 参数，进行与后台执行限制相关的权限检查：</p>
<ul>
<li>不具有 <code>CHANGE_DEVICE_IDLE_TEMP_WHITELIST</code> 的进程不允许发送广播，并抛出 SecurityException；</li>
<li>应用有后台限制，则广播不会被发送；</li>
<li>广播选项允许后台 Activity 启动，并且发送者不具有 <code>START_ACTIVITIES_FROM_BACKGROUND</code> 权限，不允许发送广播，抛出 SecurityException。</li>
</ul>
<p>Q: 带 <code>options</code> 参数的 <code>sendBroadcast</code> 方法带有 <code>@SystemApi</code> 装饰器，不应由开发者主动调用，那系统是如何调用该方法，添加所需的 <code>options</code> 参数呢？</p>
<h3 id="判断与处理受保护广播"><a class="markdownIt-Anchor" href="#判断与处理受保护广播"></a> 判断与处理受保护广播</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isProtectedBroadcast;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isCallerSystem;</span><br><span class="line"><span class="comment">// 判断发送者是否是系统进程</span></span><br><span class="line"><span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First line security check before anything else: stop non-system apps from</span></span><br><span class="line"><span class="comment">// sending protected broadcasts.</span></span><br><span class="line"><span class="keyword">if</span> (!isCallerSystem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isProtectedBroadcast) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(msg);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">            || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查广播是否为受保护广播：只有系统能发送受保护广播，系统只能发送受保护广播。除了一个例外：为了兼容性原因，允许应用发送配置和更新应用微件（App Widget）的广播到自身的应用微件。</p>
<p>对一些系统广播（添加删除应用、时间更改、网络变更等）进行处理（杀进程、通知电池服务等），此处源码略过不表。</p>
<h3 id="处理粘性广播"><a class="markdownIt-Anchor" href="#处理粘性广播"></a> 处理粘性广播</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">    <span class="keyword">if</span> (checkPermission(android.Manifest.permission.BROADCAST_STICKY,...)...) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (requiredPermissions != <span class="literal">null</span> &amp;&amp; requiredPermissions.length &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() != <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="comment">// We use userId directly here, since the &quot;all&quot; target is maintained</span></span><br><span class="line">    <span class="comment">// as a separate set of sticky broadcasts.</span></span><br><span class="line">    <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">        <span class="comment">// But first, if this is not a broadcast to all users, then</span></span><br><span class="line">        <span class="comment">// make sure it doesn&#x27;t conflict with an existing broadcast to</span></span><br><span class="line">        <span class="comment">// all users.</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (stickies == <span class="literal">null</span>) &#123;</span><br><span class="line">        stickies = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">        mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stickies.put(intent.getAction(), list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">stickiesCount</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">            <span class="comment">// This sticky already exists, replace it.</span></span><br><span class="line">            list.set(i, <span class="keyword">new</span> <span class="title class_">Intent</span>(intent));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= stickiesCount) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Intent</span>(intent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段处理粘性广播(Sticky Broadcast)。</p>
<p>所有粘性广播列表保存在 AMS 的 <code>mStickyBroadcasts</code> 成员中。最外层的 SparseArray 以 user ID 为 key，中层的 ArrayMap 以 Intent 的 action 为 key，相同 user ID 、相同 action 的 Intent 保存在 ArrayList 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts = ...;</span><br></pre></td></tr></table></figure>
<p>首先检查权限：</p>
<ul>
<li>发送者没有 <code>BROADCAST_STICKY</code> 权限，则抛出 SecurityException；</li>
<li>如果 <code>requiredPermissions</code> 非空，则广播发送中止，因为粘性广播不能规定接收器权限。</li>
<li>如果广播的 Intent 指定了特定的组件作为接收器，则抛出 SecurityException，因为粘性广播不支持指定接收器。</li>
</ul>
<p>如果广播不是针对所有用户，遍历针对所有用户的粘性广播（全局粘性广播）列表，检查是否与已有的全局广播冲突。如果有冲突，抛出 IllegalArgumentException。</p>
<p>最后，获取广播面向的用户对应的粘性广播列表，如果已有广播的 Intent filter 与当前广播相同，则用当前广播替换，否则，将当前广播加入该列表。</p>
<h3 id="寻找广播接收器"><a class="markdownIt-Anchor" href="#寻找广播接收器"></a> 寻找广播接收器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] users;</span><br><span class="line"><span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">    <span class="comment">// Caller wants broadcast to go to all started users.</span></span><br><span class="line">    users = mUserController.getStartedUserArray();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Caller wants broadcast to go to one specific user.</span></span><br><span class="line">    users = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;userId&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化广播将要发送给的用户列表：</p>
<ul>
<li>如果指定发送给所有用户，就将所有<strong>已在运行的</strong>用户加入列表；</li>
<li>如果指定给特定用户，就只加入该用户到列表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line"><span class="type">List</span> <span class="variable">receivers</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (intent.getComponent() == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == SHELL_UID) &#123;</span><br><span class="line">        <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mUserController.hasUserRestriction(</span><br><span class="line">                    UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                    mReceiverResolver.queryIntent(intent,</span><br><span class="line">                            resolvedType, <span class="literal">false</span> <span class="comment">/*defaultOnly*/</span>, users[i]);</span><br><span class="line">            <span class="keyword">if</span> (registeredReceivers == <span class="literal">null</span>) &#123;</span><br><span class="line">                registeredReceivers = registeredReceiversForUser;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, <span class="literal">false</span> <span class="comment">/*defaultOnly*/</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果广播没有指定仅发送给上下文注册的接收器（通过设置 <code>FLAG_RECEIVER_REGISTERED_ONLY</code>），就调用 <code>collectReceiverComponents</code> 方法获取清单注册的接收器。</p>
<p>如果广播没有指定接收器的组件名，就获取接收器列表：如果指定发送给所有用户，遍历之前创建的正在运行用户列表，将每个用户的接收器加入到 <code>registeredReceivers</code> 列表；否则，将指定用户的接收器加入该列表。</p>
<h3 id="发送常规广播"><a class="markdownIt-Anchor" href="#发送常规广播"></a> 发送常规广播</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">replacePending</span> <span class="operator">=</span></span><br><span class="line">        (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">&quot;Enqueueing broadcast: &quot;</span> + intent.getAction()</span><br><span class="line">        + <span class="string">&quot; replacePending=&quot;</span> + replacePending);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">NR</span> <span class="operator">=</span> registeredReceivers != <span class="literal">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// If we are not serializing this broadcast, then send the</span></span><br><span class="line">    <span class="comment">// registered receivers separately so they don&#x27;t wait for the</span></span><br><span class="line">    <span class="comment">// components to be launched.</span></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                isProtectedBroadcast, registeredReceivers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">    <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">            resultCode, resultData, resultExtras, ordered, sticky, <span class="literal">false</span>, userId,</span><br><span class="line">            allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">&quot;Enqueueing parallel broadcast &quot;</span> + r);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">replaced</span> <span class="operator">=</span> replacePending</span><br><span class="line">            &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// Note: We assume resultTo is null for non-ordered broadcasts.</span></span><br><span class="line">    <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">        queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    registeredReceivers = <span class="literal">null</span>;</span><br><span class="line">    NR = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前广播为常规广播，上下文注册的接收器列表非空，进行以下操作：</p>
<ol>
<li>通过 <code>broadcastQueueForIntent</code> 方法，获取对应的广播队列。将广播封装到 BroadcastRecord 对象中。</li>
<li>如果广播（通过设置 <code>FLAG_RECEIVER_REPLACE_PENDING</code>） 要求顶替尚未发送的同类广播，就调用 <code>replaceParallelBroadcastLocked</code> 方法，尝试寻找广播队列中的同类广播并将其替换。否则，使用 <code>enqueueParallelBroadcastLocked</code> 将广播加入到广播队列，再使用 <code>scheduleBroadcastsLocked</code> 安排发送广播。</li>
<li>最后将上下文注册的接收器列表 <code>registeredReceivers</code> 设为 null，以避免下一步重复操作。</li>
</ol>
<h3 id="发送其余广播"><a class="markdownIt-Anchor" href="#发送其余广播"></a> 发送其余广播</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge into one list.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ir</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (receivers != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 不允许应用接收自身的 PACKAGE_ADDED 广播，以免其利用该广播自启动。</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">NT</span> <span class="operator">=</span> receivers != <span class="literal">null</span> ? receivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ResolveInfo</span> <span class="variable">curt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BroadcastFilter</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curt == <span class="literal">null</span>) &#123;</span><br><span class="line">            curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">            curr = registeredReceivers.get(ir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">            <span class="comment">// Insert this broadcast record into the final list.</span></span><br><span class="line">            receivers.add(it, curr);</span><br><span class="line">            ir++;</span><br><span class="line">            curr = <span class="literal">null</span>;</span><br><span class="line">            it++;</span><br><span class="line">            NT++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip to the next ResolveInfo in the final list.</span></span><br><span class="line">            it++;</span><br><span class="line">            curt = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ir &lt; NR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (receivers == <span class="literal">null</span>) &#123;</span><br><span class="line">        receivers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    receivers.add(registeredReceivers.get(ir));</span><br><span class="line">    ir++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面将动态接收器的常规广播记录加入广播队列，剩下待处理的还有静态接收器的常规广播，以及有序广播（动态和静态接收器的）。</p>
<p>如果广播类型为 <code>PACKAGE_ADDED</code> / <code>PACKAGE_RESTARTED</code> / <code>PACKAGE_DATA_CLEARED</code> / <code>EXTERNAL_APPLICATIONS_AVAILABLE</code>，则从接收器列表中移除广播中提到的应用，以免其利用该广播进行自启。</p>
<p>将动态接收器列表 <code>registeredReceivers</code> 按优先级顺序合并到静态接收器列表 <code>receivers</code> 中。现在这个列表中包含了来自动态接收器的 BroadcastFilter 对象，和来自静态接收器的 ResolveInfo 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((receivers != <span class="literal">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">        || resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">    <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, <span class="literal">false</span>, userId,</span><br><span class="line">            allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">&quot;Enqueueing ordered broadcast &quot;</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BroadcastRecord</span> <span class="variable">oldRecord</span> <span class="operator">=</span></span><br><span class="line">            replacePending ? queue.replaceOrderedBroadcastLocked(r) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Replaced, fire the result-to receiver.</span></span><br><span class="line">        <span class="keyword">if</span> (oldRecord.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">BroadcastQueue</span> <span class="variable">oldQueue</span> <span class="operator">=</span> broadcastQueueForIntent(oldRecord.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo,</span><br><span class="line">                        oldRecord.intent,</span><br><span class="line">                        Activity.RESULT_CANCELED, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                        <span class="literal">false</span>, <span class="literal">false</span>, oldRecord.userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There was nobody interested in the broadcast, but we still want to record</span></span><br><span class="line">    <span class="comment">// that it happened.</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="literal">null</span> &amp;&amp; intent.getPackage() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This was an implicit broadcast... let&#x27;s record it for posterity.</span></span><br><span class="line">        addBroadcastStatLocked(intent.getAction(), callerPackage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br></pre></td></tr></table></figure>
<p>类似之前的操作，获取广播队列，封装广播对象，尝试替换未发送的重复广播，或者加入广播到队列并安排发送。替换广播后要调用 <code>performReceiveLocked</code> 方法。</p>
<p>如果隐式广播没有找到接收器，调用 <code>addBroadcastStatLocked</code> 记录这次广播。</p>
<p>最后，返回广播成功的标志。</p>
<h2 id="相关对象与方法"><a class="markdownIt-Anchor" href="#相关对象与方法"></a> 相关对象与方法</h2>
<h3 id="broadcastqueue"><a class="markdownIt-Anchor" href="#broadcastqueue"></a> BroadcastQueue</h3>
<h4 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h4>
<p>BroadcastQueue 对象分别存储了两种广播记录的队列，并支持对广播队列的增删改查操作。</p>
<p>动态注册的常规广播记录存储在 <code>ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts</code>  中。<code>enqueueParallelBroadcastLocked</code> 和  <code>replaceParallelBroadcastLocked</code> 方法实际上就是对该列表的操作。</p>
<p>其余广播存储在 <code>BroadcastDispatcher mDispatcher</code> 对象中，并由该对象负责管理。队列的实际存储位置是 <code>BroadcastDispatcher.mOrderedBroadcasts</code>，同样是 ArrayList&lt;BroadcastRecord&gt; 类型。<code>enqueueOrderedBroadcastLocked</code> 和 <code>replaceOrderedBroadcastLocked</code> 方法就是对该列表的操作。注意这里的变量和方法名令人困惑：这个广播队列不仅储存了有序广播，也储存了静态注册的常规广播。</p>
<h4 id="通过-handler-触发广播发送"><a class="markdownIt-Anchor" href="#通过-handler-触发广播发送"></a> 通过 Handler 触发广播发送</h4>
<p>BroadcastHandler 子类重载了 Handler 的 <code>HandleMessage</code> 方法，当接到 <code>BROADCAST_INTENT_MSG</code> 时执行 <code>processNextBroadcast</code> 方法，接到 <code>BROADCAST_TIMEOUT_MSG</code> 时执行 <code>broadcastTimeoutLocked</code> 方法。这个子类的实例作为成员变量 <code>mHandler</code> 出现，对应的 Looper 由 AMS 的 <code>mHandlerThread</code> 持有。</p>
<p><code>scheduleBroadcastsLocked</code> 方法安排广播发送，实际上就是向 <code>mHandler</code> 发送 <code>BROADCAST_INTENT_MSG</code>，并设置 <code>mBroadcastScheduled = true</code> 以避免重复发送该消息。</p>
<h4 id="处理广播队列"><a class="markdownIt-Anchor" href="#处理广播队列"></a> 处理广播队列</h4>
<p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendRegisteredBroadcast.svg" alt="发送常规广播时序图" /></p>
<p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendOrderedBroadcast.svg" alt="发送有序广播时序图" /></p>
<p><code>processNextBroadcast</code> 方法获取 AMS 的锁，再执行 <code>processNextBroadcastLocked</code> 方法。</p>
<p>这个方法是广播队列处理的核心，很长，分段来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processNextBroadcastLocked</span><span class="params">(<span class="type">boolean</span> fromMsg, <span class="type">boolean</span> skipOomAdj)</span> &#123;</span><br><span class="line">    BroadcastRecord r;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">    mBroadcastsScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></span><br><span class="line">    <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> r.receivers.size();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> r.receivers.get(i);</span><br><span class="line">            ...</span><br><span class="line">            deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="literal">false</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        addBroadcastToHistoryLocked(r);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先发送动态接收器的常规广播记录。一个个取出 <code>mParallelBroadcasts</code> 存储的常规广播记录，遍历其接收器，调用 <code>deliverToRegisteredReceiverLocked</code> 方法向接收器发送广播。最后调用 <code>addBroadcastToHistoryLocked</code> 方法记录广播历史。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPendingBroadcast != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> isDead;</span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcast.curApp.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">            <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mService.mPidsSelfLocked.get(</span><br><span class="line">                    mPendingBroadcast.curApp.pid);</span><br><span class="line">            isDead = proc == <span class="literal">null</span> || proc.isCrashing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mService.mProcessList.mProcessNames.get(</span><br><span class="line">                mPendingBroadcast.curApp.processName, mPendingBroadcast.curApp.uid);</span><br><span class="line">        isDead = proc == <span class="literal">null</span> || !proc.pendingStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDead) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s still alive, so keep waiting</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">        mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">        mPendingBroadcast = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来处理其余广播。<code>mPendingBroadcast</code> 记录当前正在处理的广播。如果该广播不为空，判断正在处理该广播的进程是否已退出。如果没有退出，就直接返回，以继续等待该进程。如果已退出，表明该应用已完成处理这个广播，更改该广播的状态为空闲，更新其下个接收器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">looped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// while (r == null);</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    r = mDispatcher.getNextBroadcastLocked(now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        .....<span class="comment">// No more broadcasts are deliverable right now, so all done!</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">forceReceive</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that even if something goes awry with the timeout</span></span><br><span class="line">    <span class="comment">// detection, we catch &quot;hung&quot; broadcasts here, discard them,</span></span><br><span class="line">    <span class="comment">// and continue to make progress.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is only done if the system is ready so that early-stage receivers</span></span><br><span class="line">    <span class="comment">// don&#x27;t get executed with timeouts; and of course other timeout-</span></span><br><span class="line">    <span class="comment">// exempt broadcasts are ignored.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numReceivers</span> <span class="operator">=</span> (r.receivers != <span class="literal">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; !r.timeoutExempt &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                (now &gt; r.dispatchTime + (<span class="number">2</span> * mConstants.TIMEOUT * numReceivers))) &#123;</span><br><span class="line">            ...</span><br><span class="line">            broadcastTimeoutLocked(<span class="literal">false</span>); <span class="comment">// forcibly finish this broadcast</span></span><br><span class="line">            forceReceive = <span class="literal">true</span>;</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>进入循环，这个循环用来搜索下一个需要发送的广播并将其取到变量 <code>r</code>，只有当 <code>r != null</code> 时才会退出循环。</p>
<p>调用 <code>mDispatcher.getNextBroadcastLocked</code> 方法获取下一个要处理的广播。如果没有，就直接返回。</p>
<p>检查广播处理是否超时。AMS 转发广播时会将当前时间记录在 BroadcastRecord 中，如果这个广播任务不能在 <code>2 * mConstants.TIMEOUT * numReceivers</code> 时间内完成（默认 TIMEOUT 值为 10 秒），就调用 <code>broadcastTimeoutLocked</code> 方法强制完成广播，将其状态设为 <code>IDLE</code>。如果这个广播的状态不是 <code>IDLE</code>，在这里直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In do &#123;...&#125; while (r == null)</span></span><br><span class="line"><span class="comment">// Is the current broadcast is done for any reason?</span></span><br><span class="line"><span class="keyword">if</span> (r.receivers == <span class="literal">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">        || r.resultAbort || forceReceive) &#123;</span><br><span class="line">    <span class="comment">// Send the final result if requested</span></span><br><span class="line">    <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if this was part of a split/deferral complex, update the refcount and only</span></span><br><span class="line">        <span class="comment">// send the completion when we clear all of them</span></span><br><span class="line">        <span class="keyword">if</span> (r.splitToken != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newCount</span> <span class="operator">=</span> mSplitRefcounts.get(r.splitToken) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newCount == <span class="number">0</span>) &#123;</span><br><span class="line">                ...<span class="comment">// done!  clear out this record&#x27;s bookkeeping and deliver</span></span><br><span class="line">                mSplitRefcounts.delete(r.splitToken);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// still have some split broadcast records in flight; update refcount</span></span><br><span class="line">                <span class="comment">// and hold off on the callback</span></span><br><span class="line">                ...</span><br><span class="line">                sendResult = <span class="literal">false</span>;</span><br><span class="line">                mSplitRefcounts.put(r.splitToken, newCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendResult) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">                performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.resultCode,</span><br><span class="line">                        r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                <span class="comment">// Set this to null so that the reference</span></span><br><span class="line">                <span class="comment">// (local and remote) isn&#x27;t kept in the mBroadcastHistory.</span></span><br><span class="line">                r.resultTo = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// ... and on to the next...</span></span><br><span class="line">    addBroadcastToHistoryLocked(r);</span><br><span class="line">    <span class="keyword">if</span> (r.intent.getComponent() == <span class="literal">null</span> &amp;&amp; r.intent.getPackage() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This was an implicit broadcast... let&#x27;s record it for posterity.</span></span><br><span class="line">        mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatcher.retireBroadcastLocked(r);</span><br><span class="line">    r = <span class="literal">null</span>;</span><br><span class="line">    looped = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前广播已经完成，进行如下处理：</p>
<ol>
<li>如果要求发送广播结果，执行 <code>performReceiveLocked</code> 方法</li>
<li>将当前广播加入历史记录</li>
<li>调用 AMS 的 <code>addBroadcastStatLocked</code> 方法记录当前广播</li>
<li>调用 <code>mDispatcher.retireBroadcastLocked</code> 方法</li>
<li>结束本轮循环，判断下一个广播是否需要发送</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do &#123; ...</span></span><br><span class="line">    <span class="keyword">if</span> (!r.deferred) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">receiverUid</span> <span class="operator">=</span> r.getReceiverUid(r.receivers.get(r.nextReceiver));</span><br><span class="line">        <span class="keyword">if</span> (mDispatcher.isDeferringLocked(receiverUid)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If this is the only (remaining) receiver in the broadcast, &quot;splitting&quot;</span></span><br><span class="line">            <span class="comment">// doesn&#x27;t make sense -- just defer it as-is and retire it as the</span></span><br><span class="line">            <span class="comment">// currently active outgoing broadcast.</span></span><br><span class="line">            BroadcastRecord defer;</span><br><span class="line">            <span class="keyword">if</span> (r.nextReceiver + <span class="number">1</span> == numReceivers) &#123;</span><br><span class="line">                ...</span><br><span class="line">                defer = r;</span><br><span class="line">                mDispatcher.retireBroadcastLocked(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Nontrivial case; split out &#x27;uid&#x27;s receivers to a new broadcast record</span></span><br><span class="line">                <span class="comment">// and defer that, then loop and pick up continuing delivery of the current</span></span><br><span class="line">                <span class="comment">// record (now absent those receivers).</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// The split operation is guaranteed to match at least at &#x27;nextReceiver&#x27;</span></span><br><span class="line">                defer = r.splitRecipientsLocked(receiverUid, r.nextReceiver);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// Track completion refcount as well if relevant</span></span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> r.splitToken;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// first split of this record; refcount for &#x27;r&#x27; and &#x27;deferred&#x27;</span></span><br><span class="line">                        r.splitToken = defer.splitToken = nextSplitTokenLocked();</span><br><span class="line">                        mSplitRefcounts.put(r.splitToken, <span class="number">2</span>);</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// new split from an already-refcounted situation; increment count</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">curCount</span> <span class="operator">=</span> mSplitRefcounts.get(token);</span><br><span class="line">                        ...</span><br><span class="line">                        mSplitRefcounts.put(token, curCount + <span class="number">1</span>);</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mDispatcher.addDeferredBroadcast(receiverUid, defer);</span><br><span class="line">            r = <span class="literal">null</span>;</span><br><span class="line">            looped = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (r == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>TODO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the next receiver...</span></span><br><span class="line"><span class="type">int</span> <span class="variable">recIdx</span> <span class="operator">=</span> r.nextReceiver++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep track of when this receiver started, and make sure there</span></span><br><span class="line"><span class="comment">// is a timeout message pending to kill it if need be.</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> <span class="type">BroadcastOptions</span> <span class="variable">brOptions</span> <span class="operator">=</span> r.options;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">nextReceiver</span> <span class="operator">=</span> r.receivers.get(recIdx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">    <span class="comment">// Simple case: this is a registered receiver who gets</span></span><br><span class="line">    <span class="comment">// a direct call.</span></span><br><span class="line">    <span class="type">BroadcastFilter</span> <span class="variable">filter</span> <span class="operator">=</span> (BroadcastFilter)nextReceiver;</span><br><span class="line">    ...</span><br><span class="line">    deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">    <span class="keyword">if</span> (r.receiver == <span class="literal">null</span> || !r.ordered) &#123;</span><br><span class="line">        <span class="comment">// The receiver has already finished, so schedule to</span></span><br><span class="line">        <span class="comment">// process the next one.</span></span><br><span class="line">        ...</span><br><span class="line">        r.state = BroadcastRecord.IDLE;</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束循环，表明已经取到需要发送的广播。取这个广播的下一个需要发送的接收器。</p>
<p>如果这个接收器是 BroadcastFilter 的实例，表明这个接收器是动态注册的：</p>
<ol>
<li>
<p>不需要启动相应的应用，直接使用 <code>deliverToRegisteredReceiverLocked</code> 方法发送广播到接收器。</p>
</li>
<li>
<p>如果广播接收器已完成处理（在上一步执行方法时使 <code>r.receiver = null</code>），或者不是有序广播，就安排处理下一个广播：将广播状态设为 <code>IDLE</code>，调用 <code>scheduleBroadcastsLocked</code> 发送处理广播队列的消息。</p>
</li>
<li>
<p>最后总是返回。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hard case: need to instantiate the receiver, possibly</span></span><br><span class="line"><span class="comment">// starting its application process to host it.</span></span><br><span class="line"><span class="type">ResolveInfo</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line">    (ResolveInfo)nextReceiver;</span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(</span><br><span class="line">        info.activityInfo.applicationInfo.packageName,</span><br><span class="line">        info.activityInfo.name);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">skip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">receiverUid</span> <span class="operator">=</span> info.activityInfo.applicationInfo.uid;</span><br><span class="line">...</span><br><span class="line"><span class="type">String</span> <span class="variable">targetProcess</span> <span class="operator">=</span> info.activityInfo.processName;</span><br><span class="line"><span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo.uid, <span class="literal">false</span>);</span><br><span class="line">...... <span class="comment">// 处理一些禁止后台启动的情况，将 skip 设为 true</span></span><br><span class="line"><span class="keyword">if</span> (skip) &#123;</span><br><span class="line">    ......</span><br><span class="line">    r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">    r.receiver = <span class="literal">null</span>;</span><br><span class="line">    r.curFilter = <span class="literal">null</span>;</span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    r.manifestSkipCount++;</span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">r.manifestCount++;</span><br><span class="line"></span><br><span class="line">r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">r.curComponent = component;</span><br><span class="line">r.curReceiver = info.activityInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broadcast is being executed, its package can&#x27;t be stopped.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">            r.curComponent.getPackageName(), <span class="literal">false</span>, r.userId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is this receiver&#x27;s application already running?</span></span><br><span class="line"><span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span> &amp;&amp; !app.killed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                info.activityInfo.applicationInfo.longVersionCode, mService.mProcessStats);</span><br><span class="line">        maybeAddAllowBackgroundActivityStartsToken(app, r);</span><br><span class="line">        processCurBroadcastLocked(r, app, skipOomAdj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123; ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If some unexpected exception happened, just skip</span></span><br><span class="line">        <span class="comment">// this broadcast. </span></span><br><span class="line">        ...... <span class="comment">// finishReceiverLocked; ScheduleBroadcastLocked; state = IDLE;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">    <span class="comment">// restart the application.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not running -- get it started, to be executed when the app comes up.</span></span><br><span class="line"><span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(...)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 应用启动失败，跳过广播</span></span><br><span class="line">    ...... <span class="comment">// finishReceiverLocked; ScheduleBroadcastLocked; state = IDLE;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行到这里，表明这个接收器是静态声明的，需要判断是否需要启动接收器所在应用来处理广播。</p>
<p>判断一些不适合启动接收器应用的情形，跳过当前广播记录。如果判定需要跳过广播（<code>skip = true</code>），安排下个广播发送并返回。</p>
<p>接下来，调用 <code>PackageManagerService.setPackageStoppedState</code> 方法，设置 Stopped State 为 false。表明这个软件包不能被停止。</p>
<p>如果接收者进程已运行，则调用 <code>processCurBroadcastLocked</code> 方法直接发送广播给该进程，然后返回。如果该过程中抛出 RuntimeException 异常，则跳过当前广播记录并返回。</p>
<p>如果接收者进程尚未启动，则调用 AMS 的 <code>startProcessLocked</code> 方法拉起该进程。如果启动失败，则跳过当前广播记录并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    maybeAddAllowBackgroundActivityStartsToken(r.curApp, r);</span><br><span class="line">    mPendingBroadcast = r;</span><br><span class="line">    mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startProcessLocked</code> 方法是异步的，这里并不会等待进程启动完成后返回，再处理广播。因此设定 <code>mPendingBroadcast </code> 值为当前正在处理的广播记录，<code>mPendingBroadcastRecvIndex</code> 为当前处理的接收者。到这里整个方法就结束了，而这个待处理广播的发送也不在这个方法内完成，而是在进程启动完成时通过 AMS 调用相应方法处理的。前面判断 <code>mPendingBroadcast</code> 不为 <code>null</code> 时直接返回，进程完成后才继续处理，保证了有序广播总是在前一个接收器处理完之后才向下个接收器发送。</p>
<p>进程启动完成时，ActivityThread 会调用 AMS 的 attachApplication 方法，进一步调用 BroadcastQueue.sendPendingBroadcastsLocked 方法，最终将广播发送到启动的进程。</p>
<p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity.svg" alt="进程启动接收广播时序图" /></p>
<h4 id="发送广播到接收者"><a class="markdownIt-Anchor" href="#发送广播到接收者"></a> 发送广播到接收者</h4>
<h5 id="processcurbroadcastlocked"><a class="markdownIt-Anchor" href="#processcurbroadcastlocked"></a> <code>processCurBroadcastLocked</code></h5>
<p>调用 ActivityThread.ApplicationThread 的 <code>scheduleReceiver</code> 方法，向接收者进程发送广播 Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processCurBroadcastLocked</span><span class="params">(BroadcastRecord r,</span></span><br><span class="line"><span class="params">        ProcessRecord app, <span class="type">boolean</span> skipOomAdj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...... <span class="comment">// 一些异常判断</span></span><br><span class="line"></span><br><span class="line">    r.receiver = app.thread.asBinder();</span><br><span class="line">    r.curApp = app;</span><br><span class="line">    app.curReceivers.add(r);</span><br><span class="line">    ...... <span class="comment">// 通知 AMS 进程状态和优先级变更</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the application to launch this receiver.</span></span><br><span class="line">    r.intent.setComponent(r.curComponent);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.curReceiver,</span><br><span class="line">                mService.compatibilityInfoForPackage(r.curReceiver.applicationInfo),</span><br><span class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">                app.getReportedProcState());</span><br><span class="line">        ...</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!started) &#123;...&#125; <span class="comment">// 接收者进程启动失败，从 ProcessRecord 中移除广播记录。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="delivertoregisteredreceiverlocked"><a class="markdownIt-Anchor" href="#delivertoregisteredreceiverlocked"></a> <code>deliverToRegisteredReceiverLocked</code></h5>
<p>检查广播发送者是否有权限发送这个广播，广播接收器是否有权限接收这个广播。如果没有相应权限，则设置该广播结束。否则，将 BroadcastRecord 的成员变量传入 <code>performReceiveLocked</code> 发送该广播。</p>
<h5 id="performreceivelocked"><a class="markdownIt-Anchor" href="#performreceivelocked"></a> <code>performReceiveLocked</code></h5>
<p>使用单向 Binder 调用异步地向接收器发送广播 Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span><br><span class="line"><span class="params">        Intent intent, <span class="type">int</span> resultCode, String data, Bundle extras,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have an app thread, do the call through that so it is</span></span><br><span class="line">            <span class="comment">// correctly ordered with other one-way calls.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.getReportedProcState());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;...&#125; <span class="comment">//throw ex</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">//throw RemoteException</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于具有 ApplicationThread 的一般应用，通过 Binder 调用 scheduleRegisteredReceiver<code>方法，进一步调用</code>InnerReceiver.performReceive` 方法。</li>
<li>对于没有 ProcessRecord 的系统进程，直接调用 <code>InnerReceiver.performReceive</code> 方法。</li>
</ul>
<h5 id="loadedapkreceiverdispatcherinnerreceiverperformreceive"><a class="markdownIt-Anchor" href="#loadedapkreceiverdispatcherinnerreceiverperformreceive"></a> <code>LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive</code></h5>
<p>该方法是对其父类的 <code>performReceive</code> 方法的包装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performReceive</span><span class="params">(Intent intent, <span class="type">int</span> resultCode, String data,</span></span><br><span class="line"><span class="params">        Bundle extras, <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Args</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Args</span>(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="literal">null</span> || !mActivityThread.post(args.getRunnable())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">            ...</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法初始化一个 LoadedApk.ReceiverDispatcher.Args 对象，这个类型是 BroadcastReceiver.PendingResult 的子类。通过 <code>getRunnable</code> 方法返回一个 Runnable，接下来在 if 语句中向 ActivityThread 的 Handler 发送该 Runnable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Runnable <span class="title function_">getRunnable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> mReceiver;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ordered</span> <span class="operator">=</span> mOrdered;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> mCurIntent;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="literal">null</span> || intent == <span class="literal">null</span> || mForgotten) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sendFinished(mgr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            receiver.setPendingResult(<span class="built_in">this</span>);</span><br><span class="line">            receiver.onReceive(mContext, intent);;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sendFinished(mgr);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先调用 <code>setPendingResult</code> 设置接收器收到的返回结果，接着执行接收器的 <code>onReceive</code> 方法。如果执行 <code>onReceive</code> 或者发送 Runnable 过程出现异常，就会调用 <code>sendFinished</code> 方法。这个方法传入广播的返回结果到 AMS 的 <code>finishReceiver</code> 方法，以通知 AMS 该有序广播处理完毕，继续处理下一个目标。</p>
<h5 id="finishreceiverlocked"><a class="markdownIt-Anchor" href="#finishreceiverlocked"></a> <code>finishReceiverLocked</code></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">finishReceiverLocked</span><span class="params">(BroadcastRecord r, <span class="type">int</span> resultCode,</span></span><br><span class="line"><span class="params">        String resultData, Bundle resultExtras, <span class="type">boolean</span> resultAbort, <span class="type">boolean</span> waitForServices)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> r.state;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityInfo</span> <span class="variable">receiver</span> <span class="operator">=</span> r.curReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">finishTime</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">elapsed</span> <span class="operator">=</span> finishTime - r.receiverTime;</span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    ...... <span class="comment">// 调整活动优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re abandoning this broadcast before any receivers were actually spun up,</span></span><br><span class="line">    <span class="comment">// nextReceiver is zero; in which case time-to-process bookkeeping doesn&#x27;t apply.</span></span><br><span class="line">    <span class="keyword">if</span> (r.nextReceiver &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.duration[r.nextReceiver - <span class="number">1</span>] = elapsed;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 记录处理广播耗时过长的应用</span></span><br><span class="line">    r.receiver = <span class="literal">null</span>;</span><br><span class="line">    r.intent.setComponent(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.curApp != <span class="literal">null</span> &amp;&amp; r.curApp.curReceivers.contains(r)) &#123;</span><br><span class="line">        r.curApp.curReceivers.remove(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.curFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = <span class="literal">null</span>;</span><br><span class="line">    r.curReceiver = <span class="literal">null</span>;</span><br><span class="line">    r.curApp = <span class="literal">null</span>;</span><br><span class="line">    mPendingBroadcast = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    r.resultCode = resultCode;</span><br><span class="line">    r.resultData = resultData;</span><br><span class="line">    r.resultExtras = resultExtras;</span><br><span class="line">    <span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">        r.resultAbort = resultAbort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.resultAbort = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 处理 waitForServices</span></span><br><span class="line">    r.curComponent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We will process the next receiver right now if this is finishing</span></span><br><span class="line">    <span class="comment">// an app receiver (which is always asynchronous) or after we have</span></span><br><span class="line">    <span class="comment">// come back from calling a receiver.</span></span><br><span class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法将 <code>AMS.finishReceiver</code> 方法传入的广播结果记录到对应的 BroadcastRecord 中，这样下个广播接收者就能收到更新的结果。</p>
<h5 id="broadcasttimeoutlocked"><a class="markdownIt-Anchor" href="#broadcasttimeoutlocked"></a> <code>broadcastTimeoutLocked</code></h5>
<p>这个方法排除一些特定场景的例外后，强制完成广播，触发 ANR。</p>
<p>排除的场景包括：</p>
<ol>
<li>系统尚未启动完成；</li>
<li>这个广播豁免了超时；</li>
<li>广播启动了服务，而服务被延迟启动；</li>
<li>应用处于调试状态。</li>
</ol>
<p>不同的广播队列超时时间不同，详见 <a href="#broadcastqueueforintent">broadcastQueueForIntent</a>。</p>
<h3 id="activitythread"><a class="markdownIt-Anchor" href="#activitythread"></a> ActivityThread</h3>
<h5 id="applicationthreadschedulereceiver"><a class="markdownIt-Anchor" href="#applicationthreadschedulereceiver"></a> <code>ApplicationThread.scheduleReceiver</code></h5>
<p>将收到的广播结果封装到 ActivityThread.ReceiverData 对象中，该类型是 BroadcastReceiver.PendingResult 的子类。向 ActivityThread 的 Handler 发送 <code>RECEIVER</code> 消息和 ReceiverData 对象，Handler 收到消息后调用 <code>handleReceiver</code> 方法；</p>
<h4 id="applicationthreadscheduleregisteredreceiver"><a class="markdownIt-Anchor" href="#applicationthreadscheduleregisteredreceiver"></a> <code>ApplicationThread.scheduleRegisteredReceiver</code></h4>
<p>通过 <code>updateProcessState</code> 更新进程状态，再调用 <code>InnerReceiver.performReceive</code> 方法。</p>
<h4 id="handlereceiver"><a class="markdownIt-Anchor" href="#handlereceiver"></a> <code>handleReceiver</code></h4>
<p>这个方法在 <code>ActivityThread</code> 中定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleReceiver</span><span class="params">(ReceiverData data)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line"></span><br><span class="line">    Application app;</span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    ContextImpl context;</span><br><span class="line">    ...... <span class="comment">// 获取 app, receiver, context</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sCurrentBroadcastIntent.set(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="literal">null</span>) &#123;</span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能和代码都类似于 <code>Args.getRunnable</code> 返回的 Runnable 方法，设置 PendingResult，调用 <code>onReceive</code> 方法，并在方法完成后通知 AMS 完成广播。</p>
<h3 id="broadcastreceiver"><a class="markdownIt-Anchor" href="#broadcastreceiver"></a> BroadcastReceiver</h3>
<p>BroadcastReceiver 接收到广播后，可以使用 <code>getResult</code> 获取上个接收器返回的结果，使用 <code>setResult</code> 系列方法来设置结果传给下个广播接收器，或者使用 <code>abortBroadcast</code> 方法中止广播向下一个接收器传递。这一系列方法操作的是 BroadcastReceiver.PendingResult 对象。</p>
<h4 id="setpendingresult"><a class="markdownIt-Anchor" href="#setpendingresult"></a> <code>setPendingResult</code></h4>
<p>设置 mPendingResult 变量的值。<code>ActivityThead.handleReceiver</code> 和 <code>Args.getRunnable</code> 方法发送广播时，调用该方法设置接收器结果。</p>
<h4 id="完成广播"><a class="markdownIt-Anchor" href="#完成广播"></a> 完成广播</h4>
<p><code>Args.getRunnable</code> 和 <code>handleReceiver</code> 在广播处理完返回时，都会调用 <code>PendingResult.finish</code> 方法，该方法会调用 <code>PendingResult.sendFinished</code> 方法。如果处理广播中出现异常，则会直接调用 <code>sendFinished</code> 方法。</p>
<p><code>sendFinished</code> 方法禁止广播结果传递文件描述符，接着传入广播结果（可能被接收器更改）到 AMS 的 <code>finishReceiver</code> 方法。</p>
<p><code>AMS.finishReceiver</code> 方法找到广播所在广播队列及对应的广播记录，传入广播结果到 <code>BroadcastQueue.finishReceiverLocked</code> 方法。接着，根据其返回值判定是否调用 <code>BroadcastQueue.processNextBroadcastLocked</code> 方法推动下次广播发送。</p>
<h3 id="broadcastqueueforintent"><a class="markdownIt-Anchor" href="#broadcastqueueforintent"></a> <code>broadcastQueueForIntent</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue <span class="title function_">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOnOffloadQueue(intent.getFlags())) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> mOffloadBroadcastQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isFg</span> <span class="operator">=</span> (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOnOffloadQueue</span><span class="params">(<span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mEnableOffloadQueue &amp;&amp; ((flags &amp; Intent.FLAG_RECEIVER_OFFLOAD) != <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法返回 Intent 对应的广播队列。AMS 中定义了三个广播队列：<code>mFgBroadcastQueue, mBgBroadcastQueue, mOffloadBroadcastQueue</code>，分别用于前台的接收器、后台的接收器，和“长”广播（例如 <code>BOOT_COMPLETED</code>，通过 <code>FLAG_RECEIVER_OFFLOAD</code> 标志来判定）。</p>
<p>这三个队列有不同的广播超时时间：前台广播是 10 秒，后台广播和长广播是 60 秒。</p>
<h3 id="collectreceivercomponents"><a class="markdownIt-Anchor" href="#collectreceivercomponents"></a> <code>collectReceiverComponents</code></h3>
<p>这个方法调用 <code>PackageManagerService.queryIntentReceivers</code> 方法，</p>
<h3 id="mreceiverresolverqueryintent"><a class="markdownIt-Anchor" href="#mreceiverresolverqueryintent"></a> <code>mReceiverResolver.queryIntent</code></h3>
<p>查询指定用户的接收器使用的是 <code>mReceiverResolver.queryIntent</code> 方法，TODO</p>
<h1 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h1>
<p>Q: <strong>从未打开过的 APP(包括系统 APP)可以接收 <code>ACTION_BOOT_COMPLETED</code> 广播么？</strong></p>
<p>A: Android 8.0 开始对后台执行进行限制，应用无法在清单注册一些隐式广播的接收器。但是，<code>ACTION_BOOT_COMPLETED</code> 广播被豁免这一限制。</p>
<p>从未打开的非系统应用在软件包管理器(PackageManager)中处于停止状态(stopped state)。只有具有 <code>FLAG_INCLUDE_STOPPED_PACKAGES</code> 广播才可以被停止状态的应用接收。</p>
<p>而系统广播 <code>ACTION_BOOT_COMPLETE</code> 不具有该标志，而是有 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> 标志，这意味着该广播不能被从未打开过的应用接收，但是系统应用不受该限制，因此该广播可以被从未打开过的系统应用接收。</p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li>广播概览, <a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/broadcasts?hl=zh_cn">https://developer.android.com/guide/components/broadcasts?hl=zh_cn</a></li>
<li>Android系统源码分析-Broadcast注册和注销, <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/882cf3911772">https://www.jianshu.com/p/882cf3911772</a></li>
<li>Android系统源码分析-Broadcast发送, <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5323a22f3f3">https://www.jianshu.com/p/c5323a22f3f3</a></li>
<li>安装APP后不启动，实现开机启动APP的Activity或者Service, <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015851405">https://segmentfault.com/a/1190000015851405</a></li>
</ol>
<h1 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/content/Context.java</span><br><span class="line">frameworks/base/core/java/android/content/BroadcastReceiver.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/IntentResolver.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ReceiverList.java</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/249898534/" rel="prev" title="Handler 源码分析">
      <i class="fa fa-chevron-left"></i> Handler 源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/3663140717/" rel="next" title="ContentProvider 源码分析">
      ContentProvider 源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#android-%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="nav-text"> Android 广播机制介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E5%B9%BF%E6%92%AD"><span class="nav-text"> 接收广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E5%8D%95%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text"> 清单声明的接收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B3%A8%E5%86%8C%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text"> 上下文注册的接收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text"> 对进程状态的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD"><span class="nav-text"> 发送广播</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text"> 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text"> 注册接收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E5%8D%95%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C"><span class="nav-text"> 清单声明的接收器（静态注册）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B3%A8%E5%86%8C%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C"><span class="nav-text"> 上下文注册的接收器（动态注册）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text"> 准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%B2%98%E6%80%A7%E5%B9%BF%E6%92%AD"><span class="nav-text"> 匹配粘性广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text"> 注册广播接收器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%94%80%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text"> 注销接收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD-2"><span class="nav-text"> 发送广播</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E9%AA%8C%E8%AF%81"><span class="nav-text"> 初始验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E9%99%90%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="nav-text"> 后台执行限制相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%8E%E5%A4%84%E7%90%86%E5%8F%97%E4%BF%9D%E6%8A%A4%E5%B9%BF%E6%92%AD"><span class="nav-text"> 判断与处理受保护广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%B2%98%E6%80%A7%E5%B9%BF%E6%92%AD"><span class="nav-text"> 处理粘性广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text"> 寻找广播接收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%B8%B8%E8%A7%84%E5%B9%BF%E6%92%AD"><span class="nav-text"> 发送常规广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%85%B6%E4%BD%99%E5%B9%BF%E6%92%AD"><span class="nav-text"> 发送其余广播</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-text"> 相关对象与方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#broadcastqueue"><span class="nav-text"> BroadcastQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-text"> 数据存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-handler-%E8%A7%A6%E5%8F%91%E5%B9%BF%E6%92%AD%E5%8F%91%E9%80%81"><span class="nav-text"> 通过 Handler 触发广播发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%B9%BF%E6%92%AD%E9%98%9F%E5%88%97"><span class="nav-text"> 处理广播队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD%E5%88%B0%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-text"> 发送广播到接收者</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#processcurbroadcastlocked"><span class="nav-text"> processCurBroadcastLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delivertoregisteredreceiverlocked"><span class="nav-text"> deliverToRegisteredReceiverLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#performreceivelocked"><span class="nav-text"> performReceiveLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#loadedapkreceiverdispatcherinnerreceiverperformreceive"><span class="nav-text"> LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finishreceiverlocked"><span class="nav-text"> finishReceiverLocked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#broadcasttimeoutlocked"><span class="nav-text"> broadcastTimeoutLocked</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#activitythread"><span class="nav-text"> ActivityThread</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#applicationthreadschedulereceiver"><span class="nav-text"> ApplicationThread.scheduleReceiver</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#applicationthreadscheduleregisteredreceiver"><span class="nav-text"> ApplicationThread.scheduleRegisteredReceiver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handlereceiver"><span class="nav-text"> handleReceiver</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broadcastreceiver"><span class="nav-text"> BroadcastReceiver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setpendingresult"><span class="nav-text"> setPendingResult</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%88%90%E5%B9%BF%E6%92%AD"><span class="nav-text"> 完成广播</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broadcastqueueforintent"><span class="nav-text"> broadcastQueueForIntent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#collectreceivercomponents"><span class="nav-text"> collectReceiverComponents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mreceiverresolverqueryintent"><span class="nav-text"> mReceiverResolver.queryIntent</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#qa"><span class="nav-text"> Q&amp;A</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text"> 参考文献</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-text"> 源代码</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">solarqiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/solarqiang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;solarqiang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhiqiang.sol@foxmail.com" title="E-Mail → mailto:zhiqiang.sol@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">solarqiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"bbnDMngYAJzVwwnYmQY3Rpm4-MdYXbMMI","app_key":"19WWCYLnVoXolUN0qqs73zX1","security":true,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'f7b603007e72448a85b0',
      clientSecret: 'a8354c5d4cc087aef62a729d4c69750b38cd2ad4',
      repo        : 'solarqiang.github.io',
      owner       : 'solarqiang',
      admin       : ['solarqiang'],
      id          : '726ebe1d0598041d239db163f6b3981f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
