<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="b6sfFZ2JS42hoER_mUyRDfihbdCJv_T81PvPJY4zjM0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"solarqiang.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":280,"display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="背景知识  进程与线程 类似其他操作系统的相应概念，Android 的进程拥有独立的虚拟内存空间，而线程与同一进程内的其他线程共享内存，只拥有各自的栈空间、程序计数器和寄存器等少量独占资源。 当 Android 启动一个之前未运行的应用的组件时，会为其启动一个包含单个主线程&quot;main&quot;的新的 Linux 进程。默认情况下，同一应用的所有组件会在此进程内启动，并且使用同一执行线">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler 源码分析">
<meta property="og:url" content="https://solarqiang.github.io/posts/249898534/">
<meta property="og:site_name" content="小强的开发笔记">
<meta property="og:description" content="背景知识  进程与线程 类似其他操作系统的相应概念，Android 的进程拥有独立的虚拟内存空间，而线程与同一进程内的其他线程共享内存，只拥有各自的栈空间、程序计数器和寄存器等少量独占资源。 当 Android 启动一个之前未运行的应用的组件时，会为其启动一个包含单个主线程&quot;main&quot;的新的 Linux 进程。默认情况下，同一应用的所有组件会在此进程内启动，并且使用同一执行线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/classes.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MessageLoop.png">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/next_activity.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MessageQueue.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/loop.svg">
<meta property="og:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendMessage.svg">
<meta property="article:published_time" content="2020-01-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-09T17:38:46.090Z">
<meta property="article:author" content="solarqiang">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://solarqiang.github.io/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/classes.svg">

<link rel="canonical" href="https://solarqiang.github.io/posts/249898534/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Handler 源码分析 | 小强的开发笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小强的开发笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://solarqiang.github.io/posts/249898534/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="solarqiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小强的开发笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Handler 源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-19T00:00:00+08:00">2020-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-10 01:38:46" itemprop="dateModified" datetime="2024-01-10T01:38:46+08:00">2024-01-10</time>
              </span>

          
            <span id="/posts/249898534/" class="post-meta-item leancloud_visitors" data-flag-title="Handler 源码分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="背景知识"><a class="markdownIt-Anchor" href="#背景知识"></a> 背景知识</h1>
<h2 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h2>
<p>类似其他操作系统的相应概念，Android 的进程拥有独立的虚拟内存空间，而线程与同一进程内的其他线程共享内存，只拥有各自的栈空间、程序计数器和寄存器等少量独占资源。<br />
当 Android 启动一个之前未运行的应用的组件时，会为其启动一个包含单个主线程&quot;main&quot;的新的 Linux 进程。默认情况下，同一应用的所有组件会在此进程内启动，并且使用同一执行线程。<br />
开发者可以人为安排组件在单独的进程中运行，并且为进程创建额外的线程。</p>
<h2 id="android-线程"><a class="markdownIt-Anchor" href="#android-线程"></a> Android 线程</h2>
<p>每个 Android 应用都有一个主线程，也称界面线程，负责绘制 UI，处理用户交互以及接收生命周期事件。Android UI 操作不是线程安全的，这些操作必须在主线程执行。<br />
为了不拖慢主线程，任何长时间运行的计算和操作都应在后台线程完成，避免 ANR。使用多线程还可以充分利用多核处理器的优势，通过并行提高运行速度。</p>
<span id="more"></span>
<ol>
<li>创建线程的方法
<ol>
<li>Java 的线程方法
<ol>
<li>重载 Thread.run() 方法</li>
<li>实现 Runnable 类</li>
</ol>
</li>
<li>Android 的线程方法
<ol>
<li>AsyncTask</li>
<li>IntentService</li>
<li>HandlerThread</li>
<li>Executors 中创建线程池 (<code>newFixedThreadPool</code>, <code>newScheduledThreadPool</code>, <code>newWorkStealingPool</code>)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>从其他线程访问主线程的方法</p>
<ol>
<li><code>Activity.runOnUiThread(Runnable)</code></li>
<li><code>View.post(Runnable)</code></li>
<li><code>View.postDelayed(Runnable, long)</code></li>
<li>使用 Handler</li>
</ol>
<h2 id="handler-介绍"><a class="markdownIt-Anchor" href="#handler-介绍"></a> Handler 介绍</h2>
<p><code>Handler</code> 是 Android 系统线程管理框架的一部分，使用消息队列实现线程之间的通信。<br />
<code>Handler</code> 允许你发送和处理关联到线程的 <code>MessageQueue</code> 的 <code>Message</code> 和 <code>Runnable</code> 对象。新的 <code>Handler</code> 会绑定到创建者线程的消息队列上。</p>
<p>消息驱动机制的四要素：</p>
<ol>
<li>接收消息的“消息队列”：<code>MessageQueue</code></li>
<li>阻塞式地从消息队列中接收消息并进行处理的“线程”:<code>Thread</code> &amp; <code>Looper</code></li>
<li>可发送的“消息的格式”: <code>Message</code></li>
<li>“消息发送函数”: <code>Handler.post(Runnable)</code> &amp; <code>Handler.sendMessage(Message)</code></li>
</ol>
<p>Handler 的两大主要作用：</p>
<ol>
<li>安排 <code>Message</code> 和 <code>Runnable</code> 在未来某个时刻运行。</li>
<li>安排在其他线程中执行的动作。</li>
</ol>
<p>使用 Handler：</p>
<ul>
<li>
<p>接收者线程：</p>
<ol>
<li>如果是子线程，判断其是否已有 <code>Looper</code>，如果没有，运行 <code>Looper.prepare()</code></li>
<li>实例化 Handler 对象 <code>mHandler</code>，实现 <code>handleMessage</code> 方法（重载方法或实现 <code>Callback</code> 接口）。</li>
<li>如果接收者是子线程，调用 <code>Looper.loop()</code> 方法，使得 Looper 调用 <code>handleMessage</code> 方法对消息进行处理；如果是主线程，启动时已经调用了 <code>Looper.prepare()</code> <code>Looper.loop()</code> 方法。</li>
<li>如果子线程不需要再处理消息，调用 <code>Looper.myLooper().quit()</code> 退出消息轮询</li>
</ol>
</li>
<li>
<p>发送者线程：</p>
<ol>
<li>创建 Message 对象，设置 Message 的参数</li>
<li>使用 <code>mHandler.sendMessage(Message)</code> 方法将 Message 传入 Handler 的消息队列</li>
</ol>
</li>
</ul>
<p>Handler 常用方法：<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, <code>sendMessageDelayed(Message, long)</code></p>
<h2 id="looper-介绍"><a class="markdownIt-Anchor" href="#looper-介绍"></a> Looper 介绍</h2>
<p>Looper 负责处理 MessageQueue 中的 Message。</p>
<p>一个线程内最多只有一个 Looper 对象，否则会抛出异常。</p>
<p>使用 Looper：<br />
1. 判定是否已有 <code>Looper</code> 并 <code>Looper.prepare()</code><br />
2. 做一些准备工作<br />
3. 调用<code>Looper.loop()</code>，线程进入阻塞态</p>
<h1 id="handler-源码分析"><a class="markdownIt-Anchor" href="#handler-源码分析"></a> Handler 源码分析</h1>
<p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/classes.svg" alt="Handler 相关类型" /></p>
<h2 id="handler"><a class="markdownIt-Anchor" href="#handler"></a> Handler</h2>
<p><code>frameworks/base/core/java/android/os/Handler.java</code></p>
<p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MessageLoop.png" alt="Handler 工作原理" /></p>
<p>重要成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> mAsynchronous;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">IMessenger mMessenger;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  mLooper = Looper.myLooper();</span><br><span class="line">  <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">  mQueue = mLooper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">  mLooper = looper;</span><br><span class="line">  mQueue = looper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种构造方法首先获取当前线程的 Looper。如果当前线程没有初始化 Looper，则会抛出异常。第二种构造方法直接传入要使用的 Looper 作为参数。之后初始化 <code>mCallback</code> 和 <code>mAsynchronous</code> 成员。</p>
<h3 id="其他方法"><a class="markdownIt-Anchor" href="#其他方法"></a> 其他方法</h3>
<p><code>post</code> 系列方法会调用 <code>getPostMessage</code> 方法将 Runnable 包装为 Message，然后使用 <code>sendMessage</code> 系列方法发送。</p>
<p><code>sendMessage</code> 系列方法最终会调用 <code>enqueueMessage</code> 私有方法，最后调用 <code>MessageQueue.enqueueMessage</code> 方法加入消息队列。</p>
<p><code>removeMessages</code> 和 <code>removeCallbacks</code> 系列方法会调用 <code>MessageQueue.removeMessages</code> 方法从消息队列中移除指定消息。</p>
<p><code>obtainMessage</code> 系列方法会调用 <code>Message.obtian</code> 系列方法，从消息池中获取一个 <code>Message</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">  <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">  m.callback = r;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getPostMessage</code> 方法将 Runnable 对象赋值给 Message 对象的 <code>callback</code> 成员变量，从而将其包装为 Message。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatchMessage</code> 方法处理消息的方式有三种：</p>
<ol>
<li>先检查 Message 对象的 <code>callback</code> 是否非空，若是，表明这个 Message 是使用 <code>post</code> 方法发送的，运行该 Runnable。</li>
<li>否则，检查是否初始化了 <code>mCallback</code> 成员变量，若是，运行其中的 <code>handleMessage</code> 方法。mCallback 成员变量可以在调用 Handler 构造方法时传入 Callback 接口的实现来初始化。</li>
<li>如果没有实现 Callback 接口，或上一步方法返回值为 <code>true</code>，则运行 Handler 本身的 <code>handleMessage</code> 方法。</li>
</ol>
<p><code>getMain</code> 方法会返回静态成员变量 <code>MAIN_THREAD_HANDLER</code> 的值。如果该变量没有初始化，就创建一个使用主线程 Looper 对象初始化的 Handler 对象，对该变量赋值并返回。</p>
<p><code>createAsync</code> 系列方法调用 Handler 对应构造方法，其中<code>async=true</code></p>
<p><code>runWithScissors</code> TODO</p>
<p><code>getIMessenger</code> TODO</p>
<h2 id="looper"><a class="markdownIt-Anchor" href="#looper"></a> Looper</h2>
<p><code>frameworks/base/core/java/android/os/Looper.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Looper</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Observer sObserver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法-2"><a class="markdownIt-Anchor" href="#构造方法-2"></a> 构造方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法是私有方法，只能通过 <code>Looper.prepare()</code> 来初始化 <code>Looper</code>。</p>
<p>接下来就看看<code>Looper.prepare()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">       prepare(<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先尝试获取静态线程局部变量 <code>sThreadLocal</code>，如果不为空，就说明已经创建过 <code>Looper</code> 对象，抛出<code>RuntimeException</code>；否则，就将 <code>sThreadLocal</code> 的值设置为新创建的 <code>Looper</code> 对象。</p>
<p>同一线程内的所有对象共享同一个静态变量 <code>sThreadLocal</code>，因此能保证一个线程至多只有一个 <code>Looper</code> 对象。</p>
<p>启动主线程相关代码：</p>
<p><code>frameworks/base/core/java/android/app/ActiviytThead.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line">  ......</span><br><span class="line">	<span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">	thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line">	......</span><br><span class="line">  Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程启动时调用 <code>PrepareMainLooper()</code> 方法。这个方法会调用 <code>prepare(quitAllowed)</code> 方法，其中 <code>quitAllow=False</code>，之后将 <code>sMainLooper</code> 赋值为自身的 Looper。其他线程可以使用 <code>Looper.getMainLooper()</code> 方法来访问主线程的 Looper。<br />
实例化 Looper 之后，创建 ActivityThread 实例，将线程注册到系统服务，最后调用 <code>Looper.loop()</code> 进入消息处理循环。</p>
<p>至此，应用程序的启动过程就完成了。正常情况下主线程会一直处于消息循环中，这样应用程序组件就可以利用消息处理机制来实现业务逻辑。</p>
<h3 id="消息循环"><a class="markdownIt-Anchor" href="#消息循环"></a> 消息循环</h3>
<p>看看<code>Looper.loop()</code>怎样进行消息处理循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        	......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        	......</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loop()</code> 方法会进入一个死循环，不断从 MessageQueue 取出消息，交给 Handler 处理。</p>
<p>如果消息队列为空，<code>queue.next()</code> 方法会阻塞，直到有消息进来，再取出消息返回。除非调用<code>quit()</code> 或 <code>quitSafely()</code> 方法结束轮询，<code>queue.next()</code> 才会返回<code>null</code>，结束循环。</p>
<h2 id="messagequeue"><a class="markdownIt-Anchor" href="#messagequeue"></a> MessageQueue</h2>
<p><code>frameworks/base/core/java/android/os/MessageQueue.java</code></p>
<p><code>frameworks/base/core/jni/android_os_MessageQueue.cpp</code></p>
<h3 id="构造方法-3"><a class="markdownIt-Anchor" href="#构造方法-3"></a> 构造方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">  mQuitAllowed = quitAllowed;</span><br><span class="line">  mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出主要工作在 <code>nativeInit()</code>函数进行，这是一个 JNI 方法，在讨论线程阻塞与唤醒时再回到这里。</p>
<h3 id="插入与移除消息"><a class="markdownIt-Anchor" href="#插入与移除消息"></a> 插入与移除消息</h3>
<p>消息队列以链表的方式储存，MessageQueue 的 <code>mMessages</code> 成员变量保存链表的第一个消息。</p>
<p><code>enqueueMessage</code> 方法插入消息到队列，<code>removeMessages</code> 方法移除消息。插入和移除消息时会保证消息队列总是按 <code>when</code> 属性递增的顺序排列，也就是链表的头总是最紧急要处理的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mBlocked = true</code> 时，以下几种情况下，插入消息会设置 <code>needWake = true</code>，唤醒接收者线程：</p>
<ol>
<li>消息队列为空(<code>p == null</code>)</li>
<li>消息设置为立即处理(<code>when == 0</code>)</li>
<li>消息预定的时刻早于队列头部的消息(<code>when &lt; p.when</code>)</li>
<li>消息队列被同步屏障暂停，而插入的消息是最早一条要处理的异步消息</li>
</ol>
<p>如果需要唤醒，会调用 <code>nativeWake(mPtr)</code> 方法唤醒线程。我们待会讨论这个方法。</p>
<h3 id="插入与移除同步屏障"><a class="markdownIt-Anchor" href="#插入与移除同步屏障"></a> 插入与移除同步屏障</h3>
<p><code>postSyncBarrier</code> 方法会插入一条同步屏障(Sync Barrier)消息到消息队列。<code>next</code> 方法读取到同步屏障消息后，会停止处理同步消息，只处理异步消息。如果不设置生效时间或设置为 0，屏障将立即生效。该方法返回一个 token，用于调用 <code>removeSyncBarrier</code> 方法移除该同步屏障。</p>
<p><code>removeSyncBarrier</code> 方法会移除插入的同步屏障消息，使消息队列继续处理同步消息。</p>
<h3 id="取下一条消息"><a class="markdownIt-Anchor" href="#取下一条消息"></a> 取下一条消息</h3>
<p><code>MessageQueue.next()</code> 方法将下一条待处理的消息返回给 Looper。其内部实现了阻塞线程、同步屏障、定时处理消息、处理空闲情况等机制。没有消息时，该方法会阻塞线程，直到新的消息到达，或者定时器到期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>首先获取 NativeMessageQueue 对象的指针。如果该指针为空，说明 Native 对象没有正确初始化，返回 null 结束消息循环。</p>
<p>接下来进入取待处理消息的循环。</p>
<p>若下次查询的超时时间不为0，Binder.flushPendingCommands()；（？）</p>
<p>调用 JNI 方法 <code>nativePollOnce</code>，这个方法就是没有消息时阻塞的源头，先放在一边。</p>
<p>接着看下面的过程，仍在 for 循环内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prevMsg = msg;</span><br><span class="line">            msg = msg.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">            <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">            nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Got a message.</span></span><br><span class="line">            mBlocked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                prevMsg.next = msg.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = msg.next;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No more messages.</span></span><br><span class="line">        nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">    <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">    <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">        pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">        mBlocked = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">        mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mMessages</code> 成员变量作为链表头，是这一轮循环搜索消息的起始点，临时变量<code>msg</code> 保存要取出的消息。</p>
<ol>
<li>
<p>第 6 到 12 行，如果 <code>msg.target</code> 为空，说明这是一个由 <code>postSyncBarrier</code> 方法设置的同步屏障(Sync Barrier)消息，那么快进 <code>msg</code> 到下一个异步消息。</p>
</li>
<li>
<p>接下来，如果<code>msg</code>不为空，首先判断消息的唤醒时间是否已到，没有到就设置下次唤醒时间为该唤醒时间。否则，从消息队列链表中取出<code>msg</code>：</p>
</li>
</ol>
<ul>
<li>如果之前有快进过(<code>prevMsg != null</code>)，<code>prevMsg</code> 指向下一个消息。</li>
<li>否则，<code>mMessages</code> 向前移动。</li>
</ul>
<p>最后返回当前消息 <code>msg</code>。<br />
如果上一步判断当前消息为空，设置 <code>nextPollTimeoutMillis = -1</code>, 执行<code>nativePollOnce</code> 方法时将一直阻塞，直到有新的消息到达。</p>
<ol start="3">
<li>
<p>36 到 39 行，如果 <code>mQuitting</code> 变量设置为 <code>true</code>， 现在就是处理退出请求的时候：扔掉剩余请求，并返回 null。</p>
</li>
<li>
<p>44 行开始，就是处理 IdleHandler 的代码。如果第一次遇到空闲（没有消息要处理）的情况，初始化 <code>pendingIdleHandlerCount</code> 计数。</p>
</li>
<li>
<p>接下来，如果没有 IdleHandler 需要运行，设置<code>mBlocked = true</code>，这会通知 <code>enqueueMessage</code> 方法在加入消息时唤醒当前线程。<br />
这一节的最后，如果之前没有初始化 <code>mPendingIdleHandlers</code>，执行初始化。<br />
离开临界区，继续处理 IdleHandlerr：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">    mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line"><span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">nextPollTimeoutMillis = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>遍历要处理的 IdleHandler，执行其 <code>queueIdle()</code> 方法。如果该方法返回 <code>false</code>，表明整个消息循环中该方法只需执行一次，就从 <code>mIdleHandlers</code> 中移除对应的 IdleHandler。</p>
<p>最后重设 <code>pendingIdleHandlerCount</code> 计数为 0，这样下个循环就不会再次处理 IdleHandler 相关逻辑。</p>
<p>总结一下整个方法的行为：</p>
<p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/next_activity.svg" alt="MessageQueue.next" /></p>
<h2 id="线程阻塞与唤醒"><a class="markdownIt-Anchor" href="#线程阻塞与唤醒"></a> 线程阻塞与唤醒</h2>
<h3 id="初始化-nativemessagequeue"><a class="markdownIt-Anchor" href="#初始化-nativemessagequeue"></a> 初始化 NativeMessageQueue</h3>
<p>前面 MessageQueue 初始化时，调用 <code>nativeInit()</code> 初始化其 C++ 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> <span class="built_in">NativeMessageQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">incStrong</span>(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了 NativeMessageQueue 对象并增加其强引用计数，返回对象指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::<span class="built_in">NativeMessageQueue</span>() :</span><br><span class="line">        <span class="built_in">mPollEnv</span>(<span class="literal">NULL</span>), <span class="built_in">mPollObj</span>(<span class="literal">NULL</span>), <span class="built_in">mExceptionObj</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::<span class="built_in">getForThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">false</span>);</span><br><span class="line">        Looper::<span class="built_in">setForThread</span>(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法尝试获取当前线程的 C++ 层 Looper 对象，如果没有获取到，则新建一个并绑定到当前线程。</p>
<p>来看看这个 C++ 层的 Looper：<br />
<code>system/core/libutils/include/utils/Looper.h</code>、<br />
<code>system/core/libutils/Looper.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks)</span><br><span class="line">    : <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks),</span><br><span class="line">      <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mPolling</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mResponseIndex</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd.<span class="built_in">reset</span>(<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd.<span class="built_in">get</span>() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法使用 <code>eventFd</code> 系统调用获取了 <code>mWakeEventFd</code>，作为后续 <code>epoll</code> 用于唤醒的文件描述符。</p>
<p>有了 Fd，再进入 <code>rebuildEpollLocked()</code> 调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Close old epoll instance if we have one.</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the new epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd.<span class="built_in">reset</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="built_in">get</span>(), &amp;eventItem);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第 6 行，通过系统调用 <code>epoll_create1</code> 初始化一个 epoll 实例，之后创建 epoll_event 结构 <code>eventItem</code> 并设置 <code>events</code> 属性，将 <code>fd</code> 设置为之前创建的 <code>mWakeEventFd</code>。</p>
<p>在第 13 行，通过系统调用 <code>epoll_ctl</code> 将 <code>eventItem</code> 注册到 epoll。</p>
<p>epoll  允许我们对多个文件描述符进行监听。注册监听的 <code>fd</code> 之后，调用 <code>epoll_wait</code> 函数，当 <code>fd</code> 指向的对象数据可用时，<code>epoll_wait</code> 函数就会返回，同时从传入的<code>events</code>指针返回发生改变的 <code>fd</code> 对应的 <code>eventItem</code>。</p>
<h3 id="阻塞"><a class="markdownIt-Anchor" href="#阻塞"></a> 阻塞</h3>
<p>前面说过如果消息队列没有消息，线程就会被阻塞。阻塞的调用路径是 <code>Looper.loop() -&gt; MessageQueue.next() -&gt; MessageQueue.nativePollOnce(long , int)</code>。我们从 <code>nativePollOnce</code> 开始继续追踪。</p>
<p>JNI 方法 <code>nativePollOnce</code> 调用 <code>NativeMessageQueue::pollOnce</code> 方法，进一步调用 <code>Looper::pollOnce</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	......</span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来到 <code>pollInner</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第4行就是关键所在。通过执行系统调用 <code>epoll_wait</code> ，线程将会阻塞，直到注册的 fd 有新数据或者到达超时时间才会返回。前面 MessageQueue 初始化时注册了 <code>mWakeEventFd</code> ，当它有新数据时 <code>epoll_wait</code> 就会返回，解除阻塞。由此推测，唤醒线程的方法 <code>nativeWake</code> 正是通过向 <code>mWakeEventFd</code> 写数据的操作，来解除阻塞，实现其功能的。这里写入的数据并不重要，只是利用 <code>epoll</code> 机制提供的阻塞和唤醒功能。</p>
<p>解除阻塞后，接下来进入事件处理的过程。遍历返回的 <code>eventItems</code>，检查是否有 fd 与 <code>mWakeEventFd</code> 相同。如果有，执行 <code>awoken</code> 方法。该方法不断读取 <code>mWakeEventFd</code> 以清空其内容，便于下次使用。</p>
<p>这里省略了大量与处理 Native 层消息相关的代码，因为这与本次主题无关。</p>
<h3 id="唤醒"><a class="markdownIt-Anchor" href="#唤醒"></a> 唤醒</h3>
<p><code>nativeWake</code> 用于唤醒功能，调用 <code>NativeMessageQueue::wake()</code>，进一步调用 <code>Looper::wake()</code>。正如之前预测的，该方法向 <code>mWakeEventFd</code> 写入数据，实现其唤醒的功能。</p>
<h2 id="调用链"><a class="markdownIt-Anchor" href="#调用链"></a> 调用链</h2>
<p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MessageQueue.svg" alt="MessageQueue" /></p>
<p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/loop.svg" alt="loop" /></p>
<p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendMessage.svg" alt="sendMessage" /></p>
<h1 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h1>
<p><strong>Q: Looper 如何保证线程唯一的？</strong></p>
<p>A: Looper 的构造方法是私有的，只能通过 <code>Looper.prepare()</code> 创建，通过 <code>Looper.myLooper()</code> 获取。</p>
<p><code>Looper.prepare()</code> 会检查静态线程局部变量 <code>sThreadLocal</code> 的值是否已设定，只有未设定时才会将其设为新建的Looper 对象，否则抛出异常。同一线程内的所有对象共享同一个静态变量<code>sThreadLocal</code> ，因此能保证一个线程至多只有一个 Looper 对象。</p>
<p><strong>Q: ThreadLocal如何实现数据隔离的？与加锁实现的区别是什么？</strong></p>
<p>A: 每个 Thread 对象中保存一个 ThreadLocalMap 对象，由 ThreadLocal 中的方法操纵。这个 Map 的 key 是 ThreadLocal 的弱引用，value 就是储存的对象。</p>
<p>当调用 <code>ThreadLocal.get()</code> 方法时，先判断该 ThreadLocalMap 是否非空，再使用 ThreadLocal 对象作为 key 查询并返回储存的对象。查询用的 hash code 是在ThreadLocal 对象初始化时调用  <code>threadLocalHashCode</code>  生成的。若 ThreadLocalMap 为null，或没有与 key 对应的对象，则调用 <code>setInitialValue()</code> 设初值并返回该值。</p>
<p>ThreadLocal 和 synchonized 都用于解决多线程并发访问，但是 ThreadLocal 与 synchronized 有本质的区别。</p>
<ol>
<li>机制不同
<ul>
<li>synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。</li>
<li>ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象。</li>
</ul>
</li>
<li>数据共享状态不同
<ul>
<li>synchronized 仅提供一份数据，使得多个线程间通信时能够获得数据共享。</li>
<li>ThreadLocal 为每个线程提供一份数据，隔离了多个线程对数据的数据共享。</li>
</ul>
</li>
</ol>
<p><strong>Q: 想在消息队列阻塞前处理一个事件应该如何实现？</strong></p>
<p>A: 调用 <code>next</code> 方法取下一条消息时，消息队列会在当前消息为空时阻塞，以等待新的消息。通过 <code>addIdleHandler</code> 方法，添加处理空闲状态的代码，可以在下次循环到 <code>nativePollOnce</code> 阻塞之前执行期望的操作。</p>
<p><strong>Q: 主线程与其他线程的不同之处有哪些？</strong></p>
<p>A:  主线程在应用启动时由 Android 系统启动，子线程由应用开发者主动开启。主线程会在启动时调用 <code>Looper.prepareMainLooper()</code> 和 <code>Looper.loop()</code> 方法，进入消息循环。主线程进入 <code>Looper.loop()</code> 方法后不会退出消息循环，子线程可以通过 <code>Looper.quit()</code> 退出消息循环。主线程负责处理 UI 事件和 Broadcast 消息，若超时未响应会触发 ANR。</p>
<p><strong>Q: <code>Message</code> 和 <code>Runnable</code> 在 Handler 中什么区别？</strong></p>
<p>A:  逻辑是一样的，<code>post</code> 方法中的<code> Runnable</code> 会被封装成 <code>Message</code>，再用 <code>SendMessage</code> 方法发送。</p>
<p><strong>Q: Handler 如何实现消息定时处理？</strong></p>
<p>A: 这一功能是在 <code>MessageQueue.next()</code> 方法实现的。MessageQueue 取出消息返回前，会对比该消息的 <code>when</code> 属性与当前时间。如果还没有到设定的时刻，就会设置<code>nextPollTimeoutMillis</code>变量，使得线程在给定的时刻唤醒。否则，就会返回该消息到 Looper，Looper 再调用 <code>dispatchMessage</code> 交给 Handler 处理。</p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li>Android SDK, android.os.Handler</li>
<li>Android Developers Documentation, <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/os/Handler">https://developer.android.com/reference/android/os/Handler</a></li>
<li>Android 源码分析 --Handler 机制的实现与工作原理,<a target="_blank" rel="noopener" href="https://juejin.im/post/5910522f1b69e6006858b830">https://juejin.im/post/5910522f1b69e6006858b830</a></li>
<li>Android 消息机制（一）消息队列的创建与循环的开始 Looper与MessageQueue, <a target="_blank" rel="noopener" href="https://www.viseator.com/2017/10/22/android_event_1/">https://www.viseator.com/2017/10/22/android_event_1/</a></li>
<li>Android Handler的使用方式和注意事项, <a target="_blank" rel="noopener" href="https://juejin.im/post/5910533dac502e006cfe01cd">https://juejin.im/post/5910533dac502e006cfe01cd</a></li>
<li>理解 Java 中的 ThreadLocal, <a target="_blank" rel="noopener" href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/posts/3752956090/" rel="next" title="Broadcast 源码分析">
      Broadcast 源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-text"> 背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#android-%E7%BA%BF%E7%A8%8B"><span class="nav-text"> Android 线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler-%E4%BB%8B%E7%BB%8D"><span class="nav-text"> Handler 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#looper-%E4%BB%8B%E7%BB%8D"><span class="nav-text"> Looper 介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text"> Handler 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#handler"><span class="nav-text"> Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text"> 构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-text"> 其他方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#looper"><span class="nav-text"> Looper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="nav-text"> 构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF"><span class="nav-text"> 消息循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#messagequeue"><span class="nav-text"> MessageQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="nav-text"> 构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E7%A7%BB%E9%99%A4%E6%B6%88%E6%81%AF"><span class="nav-text"> 插入与移除消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E7%A7%BB%E9%99%A4%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C"><span class="nav-text"> 插入与移除同步屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E4%B8%8B%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF"><span class="nav-text"> 取下一条消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="nav-text"> 线程阻塞与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-nativemessagequeue"><span class="nav-text"> 初始化 NativeMessageQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-text"> 阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%A4%E9%86%92"><span class="nav-text"> 唤醒</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-text"> 调用链</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#qa"><span class="nav-text"> Q&amp;A</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text"> 参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">solarqiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/solarqiang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;solarqiang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhiqiang.sol@foxmail.com" title="E-Mail → mailto:zhiqiang.sol@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">solarqiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"bbnDMngYAJzVwwnYmQY3Rpm4-MdYXbMMI","app_key":"19WWCYLnVoXolUN0qqs73zX1","security":true,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'f7b603007e72448a85b0',
      clientSecret: 'a8354c5d4cc087aef62a729d4c69750b38cd2ad4',
      repo        : 'solarqiang.github.io',
      owner       : 'solarqiang',
      admin       : ['solarqiang'],
      id          : '9376f7fb734f35b8e34d36769dd64f82',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
