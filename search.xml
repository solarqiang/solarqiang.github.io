<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你需要多快，才能追上今天的落日？</title>
      <link href="/posts/1706992220/"/>
      <url>/posts/1706992220/</url>
      
        <content type="html"><![CDATA[<p>今天天气很好，天很晴朗，能见度也很高。坐在窗前，看着太阳一点点沉下去，色彩变得温暖橙黄。于是想到下去骑车拍落日，顺便完成今天的运动量。<br />向着日落的方向骑行，没过多久便日落西山，只留下一片余晖。</p><p>感叹落日的美景与白日的结束之余，一个问题浮现在脑海：<strong>我需要至少以多快的速度追赶落日，才能追上它？</strong></p><div style="display: flex;            align-items: stretch;            gap: 20px;            justify-content: space-between;"            >    <img style="flex: 1;                height: 50%;                object-fit: cover;                margin-bottom:0px;                max-width: 50%;"    src="/attachments/2024-02-29-你需要多快-才能追上今天的落日/IMG_4028.jpeg"     title="作者拍摄于香港西环"    alt="香港西环的落日">    <div style="flex: 1;              display: flex;              flex-direction: column;            justify-content: space-between;">        <img style="                  width: 100%;                margin-bottom:0px;                  object-fit: cover;"             src="/attachments/2024-02-29-你需要多快-才能追上今天的落日/IMG_4268.jpeg"             title="作者拍摄于深圳莲花山"            alt="深圳莲花山的落日">        <img style="                    width: 100%;                margin-bottom:0px;                    object-fit: cover;"             src="/attachments/2024-02-29-你需要多快-才能追上今天的落日/IMG_4872.jpeg"             title="作者拍摄于北京望京"            alt="北京望京的落日">    </div></div><!-- ![作者拍摄于香港西环](/attachments/2024-02-29-你需要多快-才能追上今天的落日/IMG_4028.jpeg)![作者拍摄于深圳莲花山](/attachments/2024-02-29-你需要多快-才能追上今天的落日/IMG_4268.jpeg)![作者拍摄于北京望京](/attachments/2024-02-29-你需要多快-才能追上今天的落日/IMG_4872.jpeg) --><span id="more"></span><h1 id="简短的答案"><a class="markdownIt-Anchor" href="#简短的答案"></a> 简短的答案</h1><p>在地球上以 1670 km/h，或464 m/s的速度追赶落日，可以保证追上它。</p><p>这个速度上限是由地球赤道周长除以一天的时间得来的（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40076</mn><mtext> </mtext><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">m</mi></mrow><mi mathvariant="normal">/</mi><mn>24</mn><mtext> </mtext><mi mathvariant="normal">h</mi><mo>=</mo><mn>1670</mn><mtext> </mtext><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">h</mi></mrow></mrow><annotation encoding="application/x-tex">40076\ \mathrm{km} / 24\ \mathrm{h} = 1670\ \mathrm{km/h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">m</span></span><span class="mord">/</span><span class="mord">2</span><span class="mord">4</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">h</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">7</span><span class="mord">0</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">m</span><span class="mord mathrm">/</span><span class="mord mathrm">h</span></span></span></span></span>）。<br />这个速度是 1.36 倍音速，超过了一般的民航客机巡航速度 （~900 公里每小时）。</p><p>但在较高纬度以及夏季和冬季时，这个上限会变低。<br />另外，在水星、金星和火星上追逐日落，比在地球上更容易。</p><h1 id="冗长的答案"><a class="markdownIt-Anchor" href="#冗长的答案"></a> 冗长的答案</h1><h2 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h2><p>这个问题跟哪些因素有关呢？为了简化问题，先做以下假定，这些假定在下面的讨论中始终成立：</p><p><strong>简化假定</strong>：</p><ol><li>行星整体上呈球形，其直径和形状保持不变；</li><li>行星的自转速度保持不变；</li><li>行星沿圆形轨道，以恒星为中心匀速公转，其公转的角速度保持不变；</li><li>行星的轨道半径远远大于行星与恒星自身的半径；</li></ol><p>对于太阳系的大行星来说，这些假定都没什么大问题；即使假定与事实有较小的偏离，对这个问题的讨论也不会造成太大影响。</p><h3 id="上限估算"><a class="markdownIt-Anchor" href="#上限估算"></a> 上限估算</h3><p>那么，对于半径为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，一<a href="https://www.wikiwand.com/zh-hans/%E5%A4%AA%E9%98%B3%E6%97%A5">太阳日</a>长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的行星来说，需要多快的速度可以追赶上落日呢？<br />我们现在可以给出一个速度的上限，也就是当晨昏线垂直于赤道，追逐者也在赤道上追逐太阳时所需的速度。它等于行星的赤道周长除以太阳日的长度。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>v</mi><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi></mrow></msub><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>R</mi></mrow><msub><mi>T</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">v_\mathrm{max} = \frac{2 \pi R}{T_{sol}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">m</span><span class="mord mathrm mtight">a</span><span class="mord mathrm mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>带入地球的赤道周长与一天的长度，就得到之前提到的上限速度 1670 km/h.</p><p>如果是小王子所在的（虚构） B612 号小行星，假设上面的一天也是24小时，小行星的半径为5米，那么小王子只需以 0.00036 米/秒的速度散步，就可以追上落日了。难怪他一天可以看44场日落！</p><p>下面是各大行星上追赶落日的速度上限。</p><table><thead><tr><th>行星</th><th>直径 (km)</th><th>太阳日(h)</th><th>赤道追及速度(km/h)</th></tr></thead><tbody><tr><td>水星</td><td>4879</td><td>4222.5</td><td>3.6</td></tr><tr><td>金星</td><td>12104</td><td>5841.6</td><td>6.5</td></tr><tr><td>地球</td><td>12756</td><td>24.0</td><td>1669.8</td></tr><tr><td>火星</td><td>6792</td><td>24.6</td><td>867.4</td></tr><tr><td>木星</td><td>142984</td><td>9.9</td><td>45373.5</td></tr><tr><td>土星</td><td>120536</td><td>10.6</td><td>35724.1</td></tr><tr><td>天王星</td><td>51118</td><td>17.2</td><td>9336.7</td></tr><tr><td>海王星</td><td>49528</td><td>16.0</td><td>9724.8</td></tr></tbody></table><p>在水星上，你可以用步行的速度追上晨昏线，虽然没有大气的日落听起来一点也不酷，但建立一座永远追逐落日、靠温差和太阳能发电的绿色可移动都市，这主意就很酷；<br />金星严酷的地面环境不太适合步行或观赏日落，但在硫酸云层之上的晴空，也可以乘气球尽情欣赏落日，而气球里充的甚至可以是空气（空气比二氧化碳轻，可以漂浮在金星的大气）；<br />在火星上，如果有朝一日能够拥有可呼吸的大气，追逐落日的航班或许就会成为航空爱好者的心头好；<br />在四大气态巨行星的云顶观赏日落应该非常壮观，尤其是木星色彩瑰丽的云层与土星气势磅礴的土星环，一定是太阳系十大必看景色之一。但由于其快速的自转，靠大气层内飞行器追上日落或许不太现实。</p><p>回到地球上来，可以想象，当追逐者纬度变高时，由于地面经过晨昏线的线速度减小，他不需要这么快就能追上太阳。<br />另外，如果行星的自转轴不是垂直于其公转轨道平面（存在<a href="https://www.wikiwand.com/zh-hans/%E8%BD%89%E8%BB%B8%E5%82%BE%E8%A7%92">转轴倾角</a>），随着季节变化，导致晨昏线与纬线之间存在夹角，也会让追赶太阳变得容易一些。</p><h2 id="计算"><a class="markdownIt-Anchor" href="#计算"></a> 计算</h2><h3 id="计算太阳相对运动的速度矢量"><a class="markdownIt-Anchor" href="#计算太阳相对运动的速度矢量"></a> 计算太阳相对运动的速度矢量</h3><p>接下来，就开始计算吧。<br />给出以下条件：</p><ul><li>行星自转角速度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">\omega_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，公转的角速度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（规定自转角速度总为正，公转与自转同向时，公转角速度为正，公转与自转反向时，公转角速度为负）</li><li>行星的<a href="https://www.wikiwand.com/zh-hans/%E8%BD%89%E8%BB%B8%E5%82%BE%E8%A7%92">转轴倾角</a>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，当前太阳在<a href="https://www.wikiwand.com/zh-hans/%E9%BB%83%E9%81%93%E5%9D%90%E6%A8%99%E7%B3%BB">黄道坐标系</a>上的黄经为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\lambda_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（黄纬 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\beta_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 始终为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>）（春分点是太阳直射点位于行星赤道时太阳的位置，黄经定义为从春分点沿太阳运行方向转过的角度）</li><li>追逐者所处的纬度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span></li></ul><p>从追逐者的视角观测太阳，追逐者观测到的太阳的移动速度，可分解两部分：</p><ol><li>行星自转导致天球相对地平坐标系的转动，大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>r</mi></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\omega_r \cdot \cos \delta_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59445em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，方向指向赤道坐标系的西方，也就是赤经减小，或时角增大的方向。</li><li>行星公转导致太阳在黄道坐标系的移动，大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，方向指向黄道坐标系黄经增大的方向。</li></ol><h4 id="自转速度的计算"><a class="markdownIt-Anchor" href="#自转速度的计算"></a> 自转速度的计算</h4><p>为得到第一部分分量，需要首先求出太阳的赤道坐标。黄道与赤道坐标系转换公式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>sin</mi><mo>⁡</mo><mi>δ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>sin</mi><mo>⁡</mo><mi>ϵ</mi><mi>sin</mi><mo>⁡</mo><mi>λ</mi><mi>cos</mi><mo>⁡</mo><mi>β</mi><mo>+</mo><mi>cos</mi><mo>⁡</mo><mi>ϵ</mi><mi>sin</mi><mo>⁡</mo><mi>β</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>cos</mi><mo>⁡</mo><mi>α</mi><mi>cos</mi><mo>⁡</mo><mi>δ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>cos</mi><mo>⁡</mo><mi>λ</mi><mi>cos</mi><mo>⁡</mo><mi>β</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi><mi>cos</mi><mo>⁡</mo><mi>δ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>cos</mi><mo>⁡</mo><mi>ϵ</mi><mi>sin</mi><mo>⁡</mo><mi>λ</mi><mi>cos</mi><mo>⁡</mo><mi>β</mi><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>ϵ</mi><mi>sin</mi><mo>⁡</mo><mi>β</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\sin \delta &amp;= \sin \epsilon  \sin \lambda \cos \beta + \cos \epsilon \sin \beta \\\cos \alpha \cos \delta &amp;= \cos \lambda \cos \beta\\\sin \alpha \cos \delta &amp;= \cos \epsilon \sin \lambda \cos \beta - \sin \epsilon \sin \beta\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>带入太阳的黄道坐标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>λ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mo separator="true">,</mo><mtext> </mtext><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda_{sol},\ 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，得到其赤道坐标：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>α</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>arctan</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mi>ϵ</mi><mi>tan</mi><mo>⁡</mo><msub><mi>λ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>arcsin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>sin</mi><mo>⁡</mo><mi>ϵ</mi><mi>sin</mi><mo>⁡</mo><msub><mi>λ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\alpha_{sol} &amp;= \arctan(\cos \epsilon \tan \lambda_{sol})\\\delta_{sol} &amp;= \arcsin(\sin \epsilon \sin \lambda_{sol})\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">arctan</span><span class="mopen">(</span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">tan</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">arcsin</span><span class="mopen">(</span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>得到了太阳的赤纬，就可以计算得到第一部分分量的大小.</p><p>观察结果，可以得到以下特征：</p><ul><li>黄经为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">0^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>18</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">180^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span> 时，太阳的赤纬为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">0^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span>。这对应春分点或秋分点，太阳直射赤道；</li><li>黄经为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">90^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>27</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">270^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span> 时，太阳的赤纬达到极值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\pm \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord mathnormal">ϵ</span></span></span></span>。这对应夏至或冬至，太阳直射北回归线或南回归线。</li></ul><h4 id="简化问题"><a class="markdownIt-Anchor" href="#简化问题"></a> 简化问题</h4><p>第二部分分量大小，可以由行星公转周期直接得出，于是问题只剩下两者的夹角。</p><p>在继续计算之前，先退一步看看，是否真的有必要计算第二部分的分量大小？</p><p>对于地球来说，其公转周期（1 <a href="https://www.wikiwand.com/zh-hans/%E6%81%92%E6%98%9F%E5%B9%B4">恒星年</a>，365.2422 <a href="https://www.wikiwand.com/zh-hans/%E5%A4%AA%E9%98%B3%E6%97%A5">平太阳日</a>）远大于其自转周期（1 <a href="https://www.wikiwand.com/zh-hans/%E6%81%92%E6%98%9F%E6%97%A5">恒星日</a>，23h56m4s）。因此，第一部分分量大小一般是第二部分分量的上百倍。</p><p>于是，再做一个<strong>简化假定</strong>：</p><ul><li>假设行星绕太阳公转角速度远小于其自转角速度</li></ul><p>在太阳系内，这个假设对于除了水星、金星以外的行星是成立的。如果考虑卫星，对应的就是其主星绕太阳公转角速度，与卫星自转角速度。这样看的话，这个假设对于月球以外的卫星也是成立的。</p><p>有了这个假设，就意味着“行星公转导致太阳在黄道坐标系的移动”在问题讨论范围内可以忽略不计，而太阳的运动几乎完全由行星自转造成，其运动可以认为是在赤纬圈上绕地轴旋转。</p><p>这里也对感兴趣的读者附上公转与自转方向夹角的计算过程。</p><details><summary>点击展开/收起：公转与自转方向夹角的计算</summary><p>通过太阳的赤经圈、黄道圈与赤道圈三者组成一球面三角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 点为春分点；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 点为赤经圈与赤道圈交点；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 点为太阳所在位置，即赤经圈与黄道圈的交点。</li></ul><p>根据已有条件：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>A</mi><mi>B</mi><mo>=</mo><msub><mi>α</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c = AB = \alpha_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>B</mi><mi>C</mi><mo>=</mo><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a = BC = \delta_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi><mi>A</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\angle A = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi><mi>B</mi><mo>=</mo><mn>9</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">\angle B = 90^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p>结合球面三角公式得出：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>cos</mi><mo>⁡</mo><mi>C</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><mi>cos</mi><mo>⁡</mo><mi>A</mi><mi>cos</mi><mo>⁡</mo><mi>B</mi><mo>+</mo><mi>sin</mi><mo>⁡</mo><mi>A</mi><mi>sin</mi><mo>⁡</mo><mi>B</mi><mi>cos</mi><mo>⁡</mo><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>sin</mi><mo>⁡</mo><mi>ϵ</mi><mi>cos</mi><mo>⁡</mo><msub><mi>α</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\cos C &amp;= - \cos A \cos B + \sin A \sin B \cos c \\&amp;=  \sin \epsilon \cos \alpha_{sol}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>两个速度矢量组成矢量三角形 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DFG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">G</span></span></span></span>,其中：</p><ul><li>分矢量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>D</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">g = DF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 为自转的速度矢量；</li><li>分矢量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mi>F</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">d = FG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">G</span></span></span></span> 为公转的速度矢量；</li><li>希望求解合矢量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>D</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">f = DG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">G</span></span></span></span> 的大小与方向</li></ul><p>则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi><mi>F</mi><mo>=</mo><mn>9</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup><mo>−</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\angle F = 90^{\circ} - C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.757445em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，分矢量的大小和方向已在上面阐述。</p><p>由于速度是位移的一阶导数，可用平面近似，下面使用平面三角公式求解。<br />由余弦公式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>ω</mi><mn>2</mn></msup><mo>=</mo><msup><mi>f</mi><mn>2</mn></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>g</mi><mn>2</mn></msup><mo>+</mo><msup><mi>d</mi><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>g</mi><mi>d</mi><mi>cos</mi><mo>⁡</mo><mi>F</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mi>ω</mi><mi>o</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>ω</mi><mi>r</mi><mn>2</mn></msubsup><msup><mo><mi>cos</mi><mo>⁡</mo></mo><mn>2</mn></msup><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mo>−</mo><mn>2</mn><msub><mi>ω</mi><mi>o</mi></msub><msub><mi>ω</mi><mi>r</mi></msub><mtext> </mtext><mi>sin</mi><mo>⁡</mo><mi>C</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\omega^2 = f^2 &amp;= g^2 + d^2 - 2 g d \cos F\\ &amp;= \omega_o^2 + \omega_r ^2 \cos^2 \delta_{sol} - 2 \omega_o \omega_r \ \sin C \\\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.048216em;vertical-align:-1.274108em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.774108em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.385892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.274108em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.774108em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span><span style="top:-2.385892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">cos</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.274108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>由正弦公式，速度方向与赤道坐标系上正西方向的夹角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">\angle D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mfrac><mi>d</mi><mrow><mi>sin</mi><mo>⁡</mo><mi>D</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>f</mi><mrow><mi>sin</mi><mo>⁡</mo><mi>F</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>sin</mi><mo>⁡</mo><mi>D</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi>d</mi><mi>sin</mi><mo>⁡</mo><mi>F</mi></mrow><mi>f</mi></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\frac{d}{\sin D} &amp;= \frac{f}{\sin F} \\\sin D &amp;= \frac{d \sin F}{f}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.909320000000001em;vertical-align:-2.204660000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.70466em;"><span style="top:-4.70466em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.347219999999999em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.204660000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.70466em;"><span style="top:-4.70466em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.347219999999999em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.204660000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p></details><h3 id="计算追及太阳的最小速度"><a class="markdownIt-Anchor" href="#计算追及太阳的最小速度"></a> 计算追及太阳的最小速度</h3><p>得到了太阳在天空运动的角速度，乘以行星半径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，就得到了在地面上抵消其运动所需的速度了。</p><p>那么，问题完美解决了，不是吗？</p><p>其实还可以进一步优化，因为“追上落日”并不完全等同于“抵消太阳在天空中的运动”。<br />只要保持太阳在地平线以上，我们就可以一直欣赏到落日的美景了。<br />也就是说，我们要找的，是太阳运动垂直于地平线的分量。用我们自身的运动抵消这一分量，就能使太阳一直在地平线上了。</p><!-- 我们再做一次坐标变换，这次将赤道坐标系转换为地平坐标系。 --><!-- 这里的一个难点在于，赤道坐标系是相对于地平坐标系旋转的，也就是说换算的结果是跟当前时间相关的。 --><!-- 在实际的天文观测或天文导航中，一般是由标准观测站（如0度经线上的格林威治天文台）在特定时间观测主要导航天体（如太阳，月球，亮星）的本地时角，将其与天体的赤经对比，得到用作参考的恒星时。观测者根据当前时间与参考时间的差值，既可以结合当地赤经，计算得到待观测天体的本地时角；也可以通过测量天体的本地时角，反推出所在地的赤经。 --><p>让我们整理一下已知条件：</p><ul><li>已知：太阳的高度角为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">0^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span></li><li>已知：观测者所处纬度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span></li><li>已求得：太阳的赤经赤纬 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha_{sol},\ \delta_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul><p>于是由赤道圈、经过太阳的赤经圈、地平圈作出球面三角形 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mi>K</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">JKL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">L</span></span></span></span>，其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> 是赤道圈与地平圈的交点；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 是地平圈与赤经圈的交点；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是赤道圈与赤经圈的交点；</li></ul><p>根据已有条件：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi><mi>J</mi><mo>=</mo><mn>9</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup><mo>−</mo><mi mathvariant="normal">∣</mi><mi>δ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\angle J = 90^{\circ} - |\delta|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.757445em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord">∣</span></span></span></span>，即观测者所处纬度绝对值的余角；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi><mi>L</mi><mo>=</mo><mn>9</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">\angle L = 90^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>K</mi><mi>L</mi><mo>=</mo><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">j = KL = \delta_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即太阳的赤纬。</li></ul><p>求得</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>sin</mi><mo>⁡</mo><mi>K</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi>cos</mi><mo>⁡</mo><mi>J</mi></mrow><mrow><mi>cos</mi><mo>⁡</mo><mi>j</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi>sin</mi><mo>⁡</mo><mi mathvariant="normal">∣</mi><mi>δ</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi>cos</mi><mo>⁡</mo><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\sin K &amp;= \frac{\cos J}{\cos j}  \\&amp;= \frac{\sin |\delta|}{\cos \delta_{sol}}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.103770000000001em;vertical-align:-2.3018850000000004em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8018850000000004em;"><span style="top:-4.868555000000001em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span><span style="top:-2.2611149999999998em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3018850000000004em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8018850000000004em;"><span style="top:-4.868555000000001em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.2611149999999998em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3018850000000004em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>太阳落下的速度方向垂直于赤经圈向下，其大小为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>ω</mi><mo lspace="0em" rspace="0em">⊥</mo></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>ω</mi><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mi>K</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>ω</mi><mi>r</mi></msub><mo>⋅</mo><msqrt><mrow><msup><mo><mi>cos</mi><mo>⁡</mo></mo><mn>2</mn></msup><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mo>−</mo><msup><mo><mi>sin</mi><mo>⁡</mo></mo><mn>2</mn></msup><mi mathvariant="normal">∣</mi><mi>δ</mi><mi mathvariant="normal">∣</mi></mrow></msqrt></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\omega_{\perp} &amp;= \omega \cdot \cos K \\&amp;= \omega_r \cdot \sqrt{\cos^2 \delta_{sol} - \sin^2 |\delta|}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6400000000000006em;vertical-align:-1.5700000000000003em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0700000000000003em;"><span style="top:-4.574809em;"><span class="pstrut" style="height:3.344809em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.57em;"><span class="pstrut" style="height:3.344809em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5700000000000003em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0700000000000003em;"><span style="top:-4.574809em;"><span class="pstrut" style="height:3.344809em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span><span style="top:-2.57em;"><span class="pstrut" style="height:3.344809em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3448090000000001em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mop"><span class="mop">cos</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop">sin</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.871868em;"><span style="top:-3.12076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord">∣</span></span></span><span style="top:-3.3048089999999997em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49519099999999994em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5700000000000003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>观察上面的结果，可以得到：</p><ol><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>δ</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mn>9</mn><msup><mn>0</mn><mo lspace="0em" rspace="0em">∘</mo></msup><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\delta| &gt; 90^{\circ} - |\delta_{sol}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.757445em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>  时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 没有实数解。这对应了极昼或极夜的场景，太阳不升起或不落下；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\delta_{sol}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 不变时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\cos K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 随 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span> 增大单调减小，即观测者纬度绝对值越大，太阳越是“斜着”落下去，其垂直地平的分量越小；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span> 不变时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\cos K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 随 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>δ</mi><mrow><mi>s</mi><mi>o</mi><mi>l</mi></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\delta_{sol}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> 增大单调减小。即太阳的赤纬绝对值越大，其垂直地平的分量越小。</li></ol><p>让我们计算一下，2024 年 2 月 29 日，在北纬 40 度的北京，需要多快才能追上日落？<br />询问 WolframAlpha 可得，当天太阳的赤纬为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>8.</mn><msup><mn>3</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">-8.3^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.757445em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">8</span><span class="mord">.</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span>，于是我们需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.752</mn><mo>×</mo><mn>1670</mn><mtext> </mtext><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">h</mi></mrow><mo>=</mo><mn>1256</mn><mtext> </mtext><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">h</mi></mrow></mrow><annotation encoding="application/x-tex">0.752 \times 1670\ \mathrm{km/h} =  1256 \ \mathrm{km/h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">5</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">7</span><span class="mord">0</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">m</span><span class="mord mathrm">/</span><span class="mord mathrm">h</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">m</span><span class="mord mathrm">/</span><span class="mord mathrm">h</span></span></span></span></span> 的速度，才能追上当天的日落。<br />看来当天的日落只能乘坐超音速战斗机才能追上了。</p><p>在冬至日或夏至日，太阳的赤纬达到最大（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo><mn>23.</mn><msup><mn>4</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">\pm 23.4^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.757445em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord">2</span><span class="mord">3</span><span class="mord">.</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span>）。<br />此时纬度至少要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>47.</mn><msup><mn>9</mn><mo lspace="0em" rspace="0em">∘</mo></msup></mrow><annotation encoding="application/x-tex">47.9^{\circ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">7</span><span class="mord">.</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span></span></span></span>，才能使得逐日所需的速度小于 900 公里每小时。<br />作为参考，伦敦（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>51.</mn><msup><mn>5</mn><mo lspace="0em" rspace="0em">∘</mo></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">51.5^{\circ}N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>），巴黎（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>48.</mn><msup><mn>9</mn><mo lspace="0em" rspace="0em">∘</mo></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">48.9^{\circ}N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mord">.</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>）、莫斯科（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>55.</mn><msup><mn>8</mn><mo lspace="0em" rspace="0em">∘</mo></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">55.8^{\circ}N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mord">.</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∘</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>）的纬度都高于这个值。<br />在这些城市，或许真能坐上追逐落日的航班！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 天文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么你应该学习使用函数式编程</title>
      <link href="/posts/3669135081/"/>
      <url>/posts/3669135081/</url>
      
        <content type="html"><![CDATA[<p>如果你使用 Java 开发，你应该听说过 Java 8 引进的 Lambda 表达式，以及用于处理容器类的 Streams API；<br />如果你用过 JavaScript，你应该也知道高阶函数(如 <code>map</code>/<code>reduce</code>, <code>filter</code>, <code>sort</code>)，以及闭包、箭头函数、generator 之类的概念；<br />如果你上手过 Kotlin，你可能会被里面漫天飞舞的 <code>let</code>, <code>apply</code>, <code>also</code>, <code>with</code> 函数，以及一层层的花括号包裹的 Lambda 表达式感到印象深刻。</p><p>这些新鲜玩意初看起来似乎没有那么直观，甚至很别扭：这些代码块什么时候执行、如何被执行，很难一眼看出来！<br />尝试用一下后，你或许会想“搞这么花里胡哨的，这不就是省得给接口取名字的语法糖嘛”，然后继续写你的匿名内部类；<br />又或者，你会对这种简洁又新奇的写法感到欲罢不能，恨不得将整个项目都改写为花括号嵌套花括号，最后连自己都看不明白写了个啥。</p><p>但这些“新鲜玩意”其实并不新鲜，其历史甚至可以追溯到图灵第一次提出通用图灵机的概念之前！</p><p>这篇文章将试图以程序员的视角介绍<strong>函数式编程</strong>的概念，以及你为什么应该学习使用它的几个理由。</p><span id="more"></span><p>本文将大量使用 Kotlin 作为示例语言，了解 Kotlin 的<a href="https://book.kotlincn.net/text/basic-syntax.html">基本语法</a>，以及<a href="https://book.kotlincn.net/text/lambdas.html">高阶函数与 Lambda 表达式</a>有助于理解示例。<br />考虑到篇幅及受众，本文不会试图介绍一些过于学术或抽象的概念。尽管他们常常与函数式编程一起出现，但你不需要为了理解函数式编程而学习大量的数学。<br />不理解以下这些概念并不影响阅读本文内容：λ演算(λ-calculus)，单子(Monad)， 函子(Functor)。<br />感兴趣的读者可自行搜索了解。</p><h1 id="什么是函数式编程"><a class="markdownIt-Anchor" href="#什么是函数式编程"></a> 什么是函数式编程</h1><p>**函数式编程（Functional Programming, FP）**是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。在函数式编程中，函数指的不是程序中的普通函数，而是数学中的函数，即映射关系。以下是一些关键概念：</p><ol><li><strong>程序的本质</strong>：根据输入通过某种运算获得相应的输出。</li><li><strong>描述输入和输出之间的映射</strong>：函数式编程用来描述输入和输出之间的映射关系，即对运算过程的抽象。</li><li><strong>纯函数</strong>：相同的输入始终要得到相同的输出。纯函数不依赖于外部状态，也不会改变外部状态。</li></ol><p>在函数式编程中，我们追求整个程序都由函数调用以及函数组合构成。</p><p>打个比方，假设你的任务是将一个球通过布满各种可操作的机关和障碍物的场地到达终点。</p><ul><li>过程式编程就像是你跟着球一起出发，通过场上的装置实时操控球的运动，你无时无刻不在关注：操作了A装置后，球向左偏移了X米，为了到达目的地，下一步需要操作B装置使其向南偏移Y米……最终到达终点；</li><li>函数式编程则像是你在了解了场上所有装置的作用后，通过事先的计算设置好场上装置的参数，确定了球的运动轨迹。当球出发后，你无需观看和干预，就知道球一定能按照计划到达终点。</li></ul><p>在上面的例子中我们可以看到命令式编程和函数式编程在思维方式上的差异。</p><ul><li>过程式编程关注程序运行中的可变状态（在上面的例子里是球在每一时刻的具体位置），并通过程序指令（操作场上的装置）控制可变状态的变化，达到想要的结果（球的位置到达终点）；</li><li>函数式编程着重于程序运行时输出和输出的映射关系（在上面的例子里，输入是球的初始位置，输出则是球的整体轨迹），通过函数调用与函数组合（对场上装置的参数调整，使得球的轨迹发生变化），使得给定的输入产生预期的输出（球的轨迹通过终点）。</li></ul><p>函数式编程中，代码直接操作的往往不是可变的数据，而是函数之间相互调用的关系，代码中更多不是命令式的操作语句，而是声明式的表达式的嵌套。</p><p>为了达成函数式编程的魔法，我们需要对程序员的自由做一个重大限制：<strong>函数式编程中的函数应该是纯函数，即不应该依赖于可变的状态，也不应该修改外部状态。</strong></p><p>你或许会说：“这个条件看上去很苛刻！我们已经太习惯于在函数中读取和操作外部状态，不这样做，我都不知道怎么写代码！”</p><p>但请理解，一时的限制是为了更好的抽象，从而写出更加可读、更具表现力的代码。</p><p>用上面球与场地的例子来说，给定相同的初始位置（输入），通过相同的函数（相同的场上装置的状态），不管重复多少次，都应该给出相同的结果（球通过终点）。</p><p>想象一下如果不是这样会发生什么事情：某个装置使得场地变湿滑，导致结果与场地干燥时不同（结果依赖于可变的外部状态）；某个装置只能使用一次，第二次就不能再使用（修改了外部状态：装置被使用过）。<br />这样的游戏会变得很难玩！</p><p>实际上，你已经经历过这样的限制，但并没有影响你写出好的代码，反而使得代码更具可读性与可维护性。</p><p>下面这个表格有助于帮你回想这些限制：</p><table><thead><tr><th>编程范式</th><th>附加限制</th><th>特征技术</th><th>代表语言</th></tr></thead><tbody><tr><td>结构化编程<br>(Structured Programming)</td><td>限制控制流的转移<br>(GOTO语句)</td><td>条件语句，选择语句，循环语句，子程序</td><td>Fortran, Pascal, C</td></tr><tr><td>面向对象编程<br>(Object Oriented Programming)</td><td>限制对数据结构的修改<br>(非成员函数访问私有变量)</td><td>封装，继承，多态</td><td>Smalltalk, C++, Java, Objective-C</td></tr><tr><td>函数式编程<br>(Functional Programming)</td><td>限制可变状态的访问与修改<br>(纯函数)</td><td>纯函数，头等函数，闭包，柯里化，懒求值</td><td>LISP, OCaml, Haskell</td></tr></tbody></table><p>好了，空谈无益，show me the code! 接下来我将通过几个示例，介绍过程式编程与函数式编程的差异，及函数式编程带来的好处。</p><h1 id="消除可变状态更易并行化的代码"><a class="markdownIt-Anchor" href="#消除可变状态更易并行化的代码"></a> 消除可变状态：更易并行化的代码</h1><h2 id="消除单个状态"><a class="markdownIt-Anchor" href="#消除单个状态"></a> 消除单个状态</h2><p>假如我们想在 Android 平台实现一个函数，可以从指定的数字开始，每秒倒计时减 1，展示倒计时数字，直到数字减到 0。</p><p>为了方便，我们定义下面的工具函数 <code>delayForOneSecond</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.MainLooper())</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">delayForOneSecond</span><span class="params">(r: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">    handler.postDelayed(r, <span class="number">1000L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按传统的过程式写法，我们需要一个可变状态量，记录当前倒计时到哪个数字，然后间隔一秒将这个变量减 1，展示倒计时，直到数字变为 0。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countDownFrom</span><span class="params">(number: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化可变状态</span></span><br><span class="line">    counter = number </span><br><span class="line">    countDown()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">countDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    println(<span class="string">&quot;count down: <span class="variable">$counter</span>!&quot;</span>)</span><br><span class="line">    <span class="comment">// 变更可变状态</span></span><br><span class="line">    counter--</span><br><span class="line">    <span class="keyword">if</span> (counter &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        delayForOneSecond &#123;</span><br><span class="line">            countDown()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数式编程中，我们不希望程序执行中存在可变状态。我们可以使用一个称为“状态传递”的技巧，将可变状态转变为函数的入参，在状态变更时，改变函数入参，并调用函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将倒计时状态作为函数参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countDownFrom</span><span class="params">(number: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    println(<span class="string">&quot;count down: <span class="variable">$number</span>!&quot;</span>)</span><br><span class="line">    <span class="comment">// 状态变更转化为下次调用的函数参数的变更，本次调用的函数参数在执行过程中保持不变</span></span><br><span class="line">    <span class="keyword">val</span> nextNumber = number - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (nextNumber &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        delayForOneSecond &#123;</span><br><span class="line">            countDownFrom(nextNumber)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来这两段代码做的事情大同小异，甚至传统带状态的写法更容易理解。但考虑以下扩展需求：</p><ol><li>希望可以展示多于一个正在进行中的倒计时；</li><li>希望可以在多个线程中同时运行倒计时.</li></ol><p>上面代码只涉及一个可变状态，但在实际业务场景中，随着需求迭代需要维护的状态数变多，保证所有状态在所有线程与共享实例都中正确变更的成本也会快速上升。</p><p>而使用函数式编程的写法，由于函数执行时参数保持不变，不存在意外篡改或竞态条件的风险，使用函数式编程的代码只需要很少改造甚至无需改造。</p><p>在需要并行处理的程序代码中，函数式编程便能发挥其真正的威力。</p><h2 id="消除循环变量"><a class="markdownIt-Anchor" href="#消除循环变量"></a> 消除循环变量</h2><p>在纯函数式编程中，即使像循环变量这样的概念也可以被消除。我们来看看是怎么做的。</p><p>下面是使用 for 循环遍历列表的代码，其中使用了循环变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(number: <span class="type">Int</span>)</span></span> = println(number)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 循环变量：i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.size; i++) &#123;</span><br><span class="line">        process(list[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processList2</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 循环变量：element</span></span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> list) &#123;</span><br><span class="line">        process(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数式编程中，可以使用递归代替循环的技巧，从而消除循环：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    processList(list, <span class="number">0</span>) <span class="comment">// 初始语句: index = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= list.size) <span class="keyword">return</span> <span class="comment">// 终止条件: i &gt;= list.size()</span></span><br><span class="line">    process(list[i]) <span class="comment">// 循环体</span></span><br><span class="line">    processList(list, i + <span class="number">1</span>) <span class="comment">// 增量语句: i++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种更加简洁的写法，是将需要传递的状态由索引 <code>i</code> 改为列表本身：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty()) <span class="keyword">return</span> <span class="comment">// 终止条件: 空列表</span></span><br><span class="line">    process(list.first()) <span class="comment">// 循环体</span></span><br><span class="line">    processList(list.subList(<span class="number">1</span>, list.size)) <span class="comment">// 增量语句: list = list.subList(1, list.size)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中，我们往往不追求完全消除可变状态，而是在保持函数式编程优势的情况下，使代码更易读、执行效率更高。因此以上做法仅仅提供一种思路参考，而非推荐实践。</p><h1 id="使用头等函数组合的力量"><a class="markdownIt-Anchor" href="#使用头等函数组合的力量"></a> 使用头等函数：组合的力量</h1><p>一种编程语言具有头等函数（First-class Functions），是指在这门语言中，函数可以像普通变量赋值给一个左值、作为函数参数传入，或作为函数返回值返回。</p><p>使用头等函数，我们可以对许多代码进一步抽象，将业务逻辑作为函数参数传入，从而编写通用的的工具函数。</p><p>例如，想编写一个通用的、遍历列表并做处理的函数，可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">forEachInList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty()) <span class="keyword">return</span> <span class="comment">// 终止条件: 空列表</span></span><br><span class="line">    action(list.first()) <span class="comment">// 循环体</span></span><br><span class="line">    forEachInList(list.subList(<span class="number">1</span>, list.size), action) <span class="comment">// 增量语句: list = list.subList(1, list.size)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forEachInList(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), ::println) </span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实际上，Kotlin 已经帮我们实现了这样的函数(<code>Collections.forEach</code>)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再尝试一下，对数组求和呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组求和</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">list.forEach &#123;</span><br><span class="line">    sum += it</span><br><span class="line">&#125;</span><br><span class="line">println(sum) <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure><p>这样写不够“函数式”，因为我们用到了可变状态 <code>sum</code>。通过递归消除循环变量，我们可以改成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Int&gt;</span>.<span class="title">sumUp</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 终止条件: 空列表</span></span><br><span class="line">    <span class="keyword">return</span> first() + subList(<span class="number">1</span>, size).sumUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步抽象，如果希望遍历数组，并对其中的数据做归并。这里的归并操作可以不仅是累加，还可以是过滤、收集等：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">accumulate</span><span class="params">(empty: <span class="type">R</span>, accumulator: (<span class="type">T</span>, <span class="type">R</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> empty <span class="comment">// 终止条件: 空列表</span></span><br><span class="line">    <span class="keyword">return</span> accumulator(last(), subList(<span class="number">0</span>, size - <span class="number">1</span>).accumulate(empty, accumulator))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！这里反转了列表遍历的顺序，这样 <code>accumulator</code> 方法执行时，才会从列表的第一个项目开始归并。</p><p>因为这里用到的递归的写法，导致计算顺序与循环不同。</p><p>在递归压栈时，先传入的参数压在栈底，后传入的参数在栈顶，直到遇到终止条件。</p><p>递归计算并退栈时，是从栈顶到栈底一层层计算的，因此后传入的参数会先被计算，计算的顺序与参数传入的顺序相反。<br />为了使 <code>accumulator</code> 函数的编写者能更符合直觉地编写累加函数（按列表顺序先后取列表元素），压栈的顺序需要取列表顺序的逆序。</p><p>假定传入列表为 <code>listOf(1, 2, 3, 4)</code>，<code>accumulator = &#123; a, b -&gt; a + b &#125;</code>，压栈和计算结果为：</p><table><thead><tr><th>栈深度</th><th><code>accumulator</code>参数列表</th><th>计算结果</th></tr></thead><tbody><tr><td>1</td><td><code>4, listOf(1, 2, 3).accumulate(...)</code></td><td>4 + <strong>6</strong> = 10</td></tr><tr><td>2</td><td><code>3, listOf(1, 2).accumulate(...)</code></td><td>3 + <strong>3</strong> = 6</td></tr><tr><td>3</td><td><code>2, listOf(1).accumulate(...)</code></td><td>2 + <strong>1</strong> = 3</td></tr><tr><td>4</td><td><code>1, emptyList().accumulate(...)</code></td><td>1 + <strong>0</strong> = 1</td></tr></tbody></table><p>注意压栈是从上往下进行，而计算并退栈是从下往上进行。退栈时返回的结果用粗体标明。</p><p>回到 <code>accumulate</code> 上来，我们可以用它重写之前的定义的 <code>sumUp</code> 函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Int&gt;</span>.<span class="title">sumUp</span><span class="params">()</span></span> = accumulate&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="number">0</span>) &#123; element, sum -&gt; element + sum &#125;</span><br><span class="line">list.sumUp() <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure><p>从 <code>accumulate</code> 基础上，还可以组合出 <code>filter</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt; = accumulate(emptyList()) &#123; element, result -&gt;</span><br><span class="line">    <span class="keyword">if</span> (predicate(element)) result + element <span class="keyword">else</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体到业务逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;Int&gt;</span>.<span class="title">getElementsGreaterThanTen</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = filter&lt;<span class="built_in">Int</span>&gt; &#123; it &gt; <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><p>我们完全没有用到面向对象编程的继承、抽象接口等特性，仅仅使用高阶函数的组合，就完成了抽象逻辑与具体业务的分离！</p><h2 id="闭包函数运行的上下文"><a class="markdownIt-Anchor" href="#闭包函数运行的上下文"></a> 闭包：函数运行的上下文</h2><p>在上面的一些例子中，我们不自觉地在 Lambda 表达式的函数体中，访问了其函数参数之外的变量，而程序代码也像我们想象中一样的运行了。</p><p>当你仔细思考这个问题时，你会发现这个实现并不是显而易见的。回顾一下在“消除可变状态”中提到的代码块：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nextNumber = number - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (nextNumber &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    delayForOneSecond &#123;</span><br><span class="line">        countDownFrom(nextNumber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在作为 <code>delayForOneSecond</code> 参数的 Lambda 表达式中（其类型为 <code>Runnable</code>），访问了 <code>nextNumber</code> 常量。</p><p><code>nextNumber</code> 常量并不是在这个 <code>Runnable</code> 运行时的环境中定义的，而是在其外层的 <code>countDownFrom</code> 方法中声明并计算出相应值的。</p><p>当 <code>Runnable.run()</code> 真正运行时，定义 <code>nextNumber</code> 的环境，也就是上一秒的 <code>countDownFrom</code> 方法，应该早已执行结束并返回，其函数调用栈内的所有临时变量应该都会退栈清除才对！</p><p><em>我们之所以能在函数中自由地访问其<strong>定义时上下文</strong>的变量，而不会出现任何异常，是语言和编译器帮我们做了许多工作才能达成的。</em></p><p>简单地说，当函数被创建并作为参数被传递时，真正被传递的不仅包含了这个函数指针本身，还有<strong>运行这个函数所需的上下文环境</strong>。在这个例子中，上下文环境就包含了在函数内部访问的外部变量 <code>nextNumber</code> 的值。</p><p>函数的定义与运行函数的上下文的结合，就被称为&quot;<strong>闭包(Closure)</strong>&quot;。</p><p>有了闭包，就能使函数即使脱离了定义函数时的上下文环境，也能独立运行。</p><p>而“将函数访问的外部变量作为上下文环境的一部分保存到闭包，使其能在原本的上下文销毁（如函数退栈，对象被回收）后仍然能继续存在”的动作，就称为“<strong>变量捕获（variable capture）</strong>”</p><p>“闭包”这样一个抽象概念，如何实现呢？以 JVM 中匿名内部类或 Lambda 表达式的实现为例，上面的 <code>Runnable</code> 实现就类似于下面（实际情况要比这个复杂，此处仅做简化演示）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器合成的类定义，</span></span><br><span class="line"> synthetic <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">delayForOneSecond$$Lambda0</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> nextNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在构造函数中将上下文作为参数捕获，作为成员变量保存</span></span><br><span class="line">    delayForOneSecond$$Lambda0(<span class="type">int</span> nextNumber) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextNumber = nextNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        countDownFrom(nextNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用处</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">nextNumber</span> <span class="operator">=</span> number - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// nextNumber 参数作为对象的构造函数参数被捕获，从而可以脱离定义时的上下文存在</span></span><br><span class="line">delayForOneSecond(<span class="keyword">new</span> <span class="title class_">delayForOneSecond$$Lambda0</span>(nextNumber));</span><br></pre></td></tr></table></figure><h2 id="柯里化组合函数的万能胶水"><a class="markdownIt-Anchor" href="#柯里化组合函数的万能胶水"></a> 柯里化：组合函数的万能胶水</h2><p>面向对象编程中，常常会遇到上层抽象与下层实现之间接口不一致，需要编写适配器（Adapter）将其组合到一起工作。</p><p>函数式编程中，也会遇到上层提供的函数与下层的具体业务之间，由于抽象程度不同，要求的函数参数不一致。这时就要用到被称为**柯里化（Currying）**的技巧，将其组合到一起工作。</p><p>什么是“柯里化”？柯里化是一种将多参数函数转换为一系列单参数函数的过程，它将外部函数的参数<em>捕获到</em>内部函数的<strong>闭包</strong>，并<strong>返回内部函数</strong>，从而减少了函数的参数个数。</p><p>我们举一个实际的例子看看。比如，底层框架提供了一个日志方法，允许我们以不同的级别和标签记录日志：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> LEVEL_VERBOSE = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> LEVEL_DEBUG = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> LEVEL_INFO = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> LEVEL_WARNING = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> LEVEL_ERROR = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(level: <span class="type">Int</span>, tag: <span class="type">String</span>, message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;[<span class="variable">$level</span>][<span class="variable">$tag</span>] <span class="variable">$message</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个具体业务，可能希望使用固定的标签来记录日志。平凡的做法，会在这个业务内部定义一个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">logMyBusiness</span><span class="params">(level: <span class="type">Int</span>, message: <span class="type">String</span>)</span></span> = log(level, <span class="string">&quot;MyBusiness&quot;</span>, message)</span><br></pre></td></tr></table></figure><p>但每个业务都定义一遍这样的函数，也稍显繁琐。另外，当可定义的参数增长时，可以预见重复的样板代码也会随之增长。</p><p>又例如，某个三方库(假定叫他 GoodLib)提供了一个接口，用于写入这个三方库内部产生的日志。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志接口定义</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Logger &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(channel: <span class="type">String</span>, message: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置日志接口实现</span></span><br><span class="line"><span class="keyword">object</span> GoodLibSettings &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> defaultLogger = Logger() &#123; channel, message -&gt; println(<span class="string">&quot;[<span class="variable">$channel</span>] <span class="variable">$message</span>&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> logger: Logger = defaultLogger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不同场景下，可能需要将日志以不同等级写入。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配之前提供的日志方法</span></span><br><span class="line">GoodLibSettings.logger = Logger() &#123; channel, message -&gt;</span><br><span class="line">    <span class="keyword">if</span> (channel == <span class="string">&quot;error&quot;</span>) &#123;</span><br><span class="line">        log(LEVEL_ERROR, <span class="string">&quot;GoodLib-<span class="variable">$channel</span>&quot;</span>, message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log(LEVEL_INFO, <span class="string">&quot;GoodLib-<span class="variable">$channel</span>&quot;</span>, message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结上面问题的共同点：底层框架提供的函数接收三个参数：<code>level, tag, message</code>，而业务层代码使用时，只希望使用一个参数 <code>message</code> 就足够了。</p><p>如果我们转换思路，不直接定义业务特定的函数，而是提供一个“函数工厂”，业务可以根据自己需要生成对应的函数，就可以减少重复的样板代码。函数柯里化就是这样的“函数工厂”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loggerOf</span><span class="params">(level: <span class="type">Int</span>, tag: <span class="type">String</span>)</span></span>: (String) -&gt; <span class="built_in">Unit</span> = &#123; message -&gt;</span><br><span class="line">    log(level, tag, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数<em>捕获</em>了 <code>level, tag</code> 这两个参数，将其作为<strong>闭包</strong>传递给了底层函数 <code>log</code>，并返回了仅接收一个参数 <code>message</code> 的匿名函数(类型签名为<code>(String) -&gt; Unit</code>)，供业务层使用。这个过程就是柯里化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式编程中，函数实例可以赋值给常量或者变量。</span></span><br><span class="line"><span class="keyword">val</span> bizLogDebug = loggerOf(LEVEL_DEBUG, <span class="string">&quot;MyBusiness&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> bizLogInfo = loggerOf(LEVEL_INFO, <span class="string">&quot;MyBusiness&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> otherBizLogInfo = loggerOf(LEVEL_INFO, <span class="string">&quot;OtherBusiness&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数实例，就像调用其他常规方式定义的函数一样</span></span><br><span class="line">bizLogDebug(<span class="string">&quot;debug message&quot;</span>)</span><br><span class="line">bizLogInfo(<span class="string">&quot;info message&quot;</span>)</span><br><span class="line">otherBizLogInfo(<span class="string">&quot;info message&quot;</span>)</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">[1][MyBusiness] debug message</span></span><br><span class="line"><span class="comment">[2][MyBusiness] info message</span></span><br><span class="line"><span class="comment">[2][OtherBusiness] info message</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GoodLibSettings.logger = Logger() &#123; channel, message -&gt;</span><br><span class="line">    <span class="keyword">val</span> level = <span class="keyword">if</span> (channel == <span class="string">&quot;error&quot;</span>) LEVEL_ERROR <span class="keyword">else</span> LEVEL_INFO</span><br><span class="line">    <span class="keyword">val</span> tag = <span class="string">&quot;GoodLib-<span class="variable">$channel</span>&quot;</span></span><br><span class="line">    loggerOf(level, tag)(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果底层框架要求的函数参数比业务使用的要少，也可以通过柯里化的技巧实现转换。下面举个例子。</p><p>假定有以下数据类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FavoriteItem</span>(<span class="keyword">val</span> userId: <span class="built_in">Long</span>, <span class="keyword">val</span> favorite: String) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;FavoriteItem(userId:<span class="variable">$userId</span>, favorite:<span class="variable">$favorite</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望为其实现按 <code>userId</code> 过滤列表的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> List<span class="type">&lt;FavoriteItem&gt;</span>.<span class="title">filterByUserId</span><span class="params">(userId: <span class="type">Long</span>)</span></span> = filter &#123; it.userId == userId &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> favoriteItemList = listOf(FavoriteItem(<span class="number">666L</span>, <span class="string">&quot;apple&quot;</span>), FavoriteItem(<span class="number">114514L</span>, <span class="string">&quot;banana&quot;</span>))</span><br><span class="line">favoriteItemList.filterByUserId(<span class="number">666L</span>)</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">[FavoriteItem(userId:666, favorite:apple)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>filterByUserId</code> 函数体接收了 <code>userId</code> 参数，将其通过闭包捕获，返回了一个仅接收 <code>FavoriteItem</code> 类型参数的匿名函数（类型签名为<code>(FavoriteItem) -&gt; Boolean</code>），再立即作为 <code>filter</code> 函数的参数使用。<br />仅一行简洁优雅的代码，就通过柯里化实现了底层方法的复用与业务自定义逻辑的封装。</p><h1 id="消除可变容器减少错误提升效率"><a class="markdownIt-Anchor" href="#消除可变容器减少错误提升效率"></a> 消除可变容器：减少错误，提升效率</h1><p>让我们在前面处理列表的基础上继续扩展功能，看看函数式编程在容器类上应用时的威力。</p><p>这里希望筛选出列表中大于 10 的数字。为了着重强调不可变容器的缺陷，我们用 Java 而非 Kotlin 编写。</p><p>传统的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Integer&gt; <span class="title function_">filterNumbersGreaterThanTen</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbersGreaterThanTen = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br><span class="line">    <span class="keyword">for</span>(Integer number: list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">10</span>) numbersGreaterThanTen.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbersGreaterThanTen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Streams API 的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Integer&gt; <span class="title function_">filterNumbersGreaterThanTen</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream()</span><br><span class="line">        .filter(number -&gt; number &gt; <span class="number">10</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设上面的需求变更为“取前 5 个大于 10 的元素，并累加”，传统的修改方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">filterFiveNumbersGreaterThanTenAndSum</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbersGreaterThanTen = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Integer number : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbersGreaterThanTen.size() &gt;= <span class="number">5</span>) <span class="keyword">break</span>; <span class="comment">// 新增</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">10</span>) numbersGreaterThanTen.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 新增</span></span><br><span class="line">    <span class="keyword">for</span> (Integer n : numbersGreaterThanTen) &#123; <span class="comment">// 新增</span></span><br><span class="line">        sum += n; <span class="comment">// 新增</span></span><br><span class="line">    &#125; <span class="comment">// 新增</span></span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Streams API，函数式编程的修改方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">filterFiveNumbersGreaterThanTenAndSum2</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream()</span><br><span class="line">            .filter(number -&gt; number &gt; <span class="number">10</span>)</span><br><span class="line">            .limit(<span class="number">5</span>) <span class="comment">//新增</span></span><br><span class="line">            .reduce(Integer::sum).orElse(<span class="number">0</span>); <span class="comment">// 修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者在代码复杂度、可读性、可维护性上的差异一目了然。</p><p>此外，Java 中容器接口默认可变，在工程实践中带来了无数麻烦：</p><ul><li>业务代码可能意外篡改上层使用的可变容器，导致数据不一致;</li><li>多线程同时修改可变容器，容易导致 <code>ConcurrentModificationException</code></li><li>缺乏“不可变容器”的接口与概念，不可变容器只能通过抛出异常来曲折实现，而这一实现方式违背了里氏替换原则。</li></ul><p>以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; filtered = filterNumbersGreaterThanTen(list);</span><br><span class="line">showList(filtered); <span class="comment">// 可能抛到主线程执行，导致可能展示 filtered.remove 后的列表，这并不是我们期望的</span></span><br><span class="line"><span class="comment">// 返回不可变列表时，修改列表会抛出运行时错误，在编译期检查不到这样的错误</span></span><br><span class="line"><span class="comment">// 返回可变列表时，修改列表可能导致使用同一个列表引用的逻辑出现错误或 `ConcurrentModificationException`，这类错误很难排查</span></span><br><span class="line">filtered.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>Java 16 中引入的 <code>Stream.toList()</code> 方法返回的是不可变列表（<code>Collectors.toList()</code> 返回的是可变列表），也是为了鼓励使用不可变容器。</p><p>Kotlin 的容器接口(<code>Collection</code>/<code>Map</code>/<code>Set</code>/<code>List</code>)默认不可变，而可变容器是扩展自不可变容器的独立接口 <code>MutableCollection</code>/<code>MutableMap</code>/<code>MutableSet</code>/<code>MutableList</code>。<br />这样，即使函数内部处理时使用了可变容器，返回的容器对象也默认是不可变的（不存在 <code>add/remove</code> 这样修改容器的接口，从而在编译期检查到错误）。</p><h1 id="懒求值消除多余操作"><a class="markdownIt-Anchor" href="#懒求值消除多余操作"></a> 懒求值：消除多余操作</h1><p>在使用 Java Streams API 时，你或许会有这样的担心：如果我使用 <code>limit()</code> 函数声明只取列表中的头几个元素，实际执行时会不会先取全部元素，再移除多余的元素？在数据量大时会不会影响性能？</p><p>不必担心，因为 Java Streams API 的函数调用都是懒求值的：当你链式调用 <code>filter / map / limit</code> 这类返回 <code>Stream</code> 对象的函数时，<code>Stream</code> 内部并不会立即执行声明的操作，而是将其暂存下来。<br />只有当 <code>Stream</code> 进入末端操作（转换为列表、容器、进行归并）时，才会实际发生计算，而多余的计算不会执行。</p><p><strong>懒求值（Lazy evaluation）<strong>的概念对许多人应该并不陌生。最常见的，使用逻辑或串联的表达式中，如果前面的表达式求值结果为 <code>true</code>，则后面的表达式不会被求值，因为整个表达式的值已经确定为 <code>true</code> 了，只有真正需要子表达式的值来判断整体的值时，子表达式才会求值。这就是一种懒求值。<br />与之相对的是</strong>积极求值（Eager evaluation）</strong>，也就是表达式定义出现时就对其进行求值。</p><p>函数式编程中头等函数的设计，方便了懒求值的应用。将函数作为参数传递时，执行函数所需的上下文也会一并捕获，作为闭包传递。因此，我们可以延迟函数的执行，直到真正需要获取函数执行结果时，才对函数进行求值。</p><p>Kotlin 中，针对容器类操作，既有积极求值的 API (<code>kotlin.collections.filter/map/take</code>)，也有类似 Java Streams API，使用懒求值的 Sequences API。下面是 <a href="https://kotlinlang.org/docs/sequences.html">Kotlin 官方文档</a>中给出的两个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lengthsList = words.filter &#123; println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>); it.length &gt; <span class="number">3</span> &#125;</span><br><span class="line">    .map &#123; println(<span class="string">&quot;length: <span class="subst">$&#123;it.length&#125;</span>&quot;</span>); it.length &#125;</span><br><span class="line">    .take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Lengths of first 4 words longer than 3 chars:&quot;</span>)</span><br><span class="line">println(lengthsList)</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">filter: The</span></span><br><span class="line"><span class="comment">filter: quick</span></span><br><span class="line"><span class="comment">filter: brown</span></span><br><span class="line"><span class="comment">filter: fox</span></span><br><span class="line"><span class="comment">filter: jumps</span></span><br><span class="line"><span class="comment">filter: over</span></span><br><span class="line"><span class="comment">filter: the</span></span><br><span class="line"><span class="comment">filter: lazy</span></span><br><span class="line"><span class="comment">filter: dog</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">length: 4</span></span><br><span class="line"><span class="comment">length: 4</span></span><br><span class="line"><span class="comment">Lengths of first 4 words longer than 3 chars:</span></span><br><span class="line"><span class="comment">[5, 5, 5, 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment">//convert the List to a Sequence</span></span><br><span class="line"><span class="keyword">val</span> wordsSequence = words.asSequence()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lengthsSequence = wordsSequence.filter &#123; println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>); it.length &gt; <span class="number">3</span> &#125;</span><br><span class="line">    .map &#123; println(<span class="string">&quot;length: <span class="subst">$&#123;it.length&#125;</span>&quot;</span>); it.length &#125;</span><br><span class="line">    .take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Lengths of first 4 words longer than 3 chars&quot;</span>)</span><br><span class="line"><span class="comment">// terminal operation: obtaining the result as a List</span></span><br><span class="line">println(lengthsSequence.toList())</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">Lengths of first 4 words longer than 3 chars</span></span><br><span class="line"><span class="comment">filter: The</span></span><br><span class="line"><span class="comment">filter: quick</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">filter: brown</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">filter: fox</span></span><br><span class="line"><span class="comment">filter: jumps</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">filter: over</span></span><br><span class="line"><span class="comment">length: 4</span></span><br><span class="line"><span class="comment">[5, 5, 5, 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以注意到以下两点：</p><ol><li><code>kotlin.collections</code> API 对列表元素的操作是立即执行的（内部输出在打印标题语句之前）；而 Sequences API 对 <code>Sequence</code> 中元素的操作延迟到了 <code>toList()</code> 调用之后才实际发生（内部输出在打印标题语句之后）</li><li><code>kotlin.collections</code> API 先对列表中的所有元素进行了 <code>filter</code> 操作，再对过滤后的列表所有元素进行了 <code>map</code> 操作，最后将映射后的列表缩减到要求的大小；而 Sequence API 在列表中的元素达到 4 个之后，就停止了 <code>filter</code> 和 <code>map</code> 操作，没有多余的计算发生。</li></ol><p><img src="https://kotlinlang.org/docs/images/list-processing.png" alt="list processing" /></p><p><img src="https://kotlinlang.org/docs/images/sequence-processing.png" alt="sequence processing" /></p><p>这就是懒求值的好处：直到收集完所有信息并不得不完成计算时，计算才会发生，此时，我们可以利用之前收集到的信息消除冗余操作，避免无谓的计算资源的消耗。</p><p>不过，无论是 Java Streams API，还是 Kotlin Sequences API，实现懒求值的代价是一些额外的性能开销，在小的集合上，这些 API 的效率可能不如传统的积极求值方式，使用者应该根据实际情况选择合适的 API。</p><h1 id="硬币的反面性能与可读性"><a class="markdownIt-Anchor" href="#硬币的反面性能与可读性"></a> 硬币的反面：性能与可读性</h1><p>如果你是初次接触函数式编程的新手，看了这些眼花缭乱的例子，你或许会对这种新颖的组织程序逻辑的方式与“状态不可变”的思想感到新奇。</p><p>但在拥抱函数式编程之前，你或许还有一些不确定：</p><ol><li><strong>函数式编程会影响性能吗？</strong> 将过程式的写法改写成函数式写法后，平白无故多了许多次函数调用，带来压栈出栈的开销；每次函数作为参数传递时，又会创建闭包，这样做对性能是否有影响？</li><li><strong>函数式编程是否会导致项目的可读性与可维护性变差？</strong> 相对于传统编程范式，函数式编程可以将函数作为函数参数或返回值，不熟悉函数式编程的人员阅读这种代码时容易感到困惑。另外，函数式编程的特点，使得其代码执行流不容易一下子看出来（控制经常会从一个函数转移到另一个函数，而这些函数又往往是作为函数参数传入的，增加了复杂度），也增大了调试程序的难度。</li></ol><p>这些问题的答案也不是简单的“是”或“否”能概括的，经常需要具体情况具体分析。</p><h2 id="函数式编程的性能问题"><a class="markdownIt-Anchor" href="#函数式编程的性能问题"></a> 函数式编程的性能问题</h2><p><strong>简短回答</strong>：<br />某些情况下，函数式编程可能会负面影响性能，但大多数情况下不像你想象的那么大。大多数情况下，你更应该关心更高级的抽象是否带来了开发速度与项目管理上的优势。此外，函数式编程使得编写大规模并行代码变得更容易，在某些场景下（服务器编程、并行计算）会提供性能优势。</p><p><strong>较长的回答</strong>：<br />函数式编程的一些特征，会使其在运行时使用更多的内存空间与计算资源，具体来说体现于以下方面：</p><ol><li><strong>上下文切换频繁</strong>：函数式编程往往会对方法进行过度包装，产生许多中间调用，导致上下文切换的性能开销。</li><li><strong>资源占用</strong>：为了实现对象状态的不可变，函数式编程倾向于创建新的对象，这会对垃圾回收产生压力。</li><li><strong>递归陷阱</strong>：函数式编程中，为了实现迭代，通常会采用递归操作，但递归可能导致性能问题。</li></ol><p>针对这些问题，现代编程语言（特别是鼓励函数式编程范式的语言）在编译时与运行时，会进行大量的性能优化。</p><p>编译时常见的优化策略有：</p><ol><li><strong>内联（Inlining）</strong>：编译器可以将函数调用处的代码直接替换为函数体，减少函数调用开销。</li><li><strong>尾递归优化（Tail recursion optimization）</strong>：对尾递归函数进行优化，通过消除压栈退栈操作，避免递归栈溢出。</li><li><strong>常量折叠（Constant Folding）</strong>：在编译时计算常量表达式的值，减少运行时计算开销。</li><li><strong>静态类型检查</strong>：在编译时检查类型错误，避免运行时类型转换开销。</li></ol><p>运行时常见的优化策略有：</p><ol><li><strong>缓存</strong>：缓存中间结果，避免重复计算。</li><li><strong>懒加载（Lazy Evaluation）</strong>：延迟计算，只在需要时才进行计算，减少不必要的开销。</li><li><strong>不可变数据结构</strong>：使用针对不可变对象进行优化的数据结构（如写时复制列表），避免频繁的对象创建和拷贝，并减少内存占用。</li><li><strong>并发和并行</strong>：对于明确没有副作用的代码块，可以利用多线程并发执行任务，提高性能。</li></ol><h2 id="函数式编程的可读性与可维护性问题"><a class="markdownIt-Anchor" href="#函数式编程的可读性与可维护性问题"></a> 函数式编程的可读性与可维护性问题</h2><p><strong>简短回答</strong>：<br />用好函数式编程，确实需要开发者对其有一定程度了解，对开发者的逻辑思维能力提出了更高要求，但这对任何编程范式或技术来说都是如此。工程使用中应当扬长避短，将函数式编程范式用在其适合的领域。</p><p><strong>较长的回答</strong>：<br />软件工程没有银弹，正如其他所有编程范式一样，大量使用函数式编程的实际工程项目中，不可避免会出现一些可读性与可维护性问题，典型的如下：</p><ol><li><strong>嵌套函数层级过深</strong>：函数式编程使用函数组合与嵌套实现封装与模块化，但就像面向对象编程过于复杂的继承关系会使代码难以阅读和维护，函数式编程中嵌套函数层级过深，也容易导致可读性和可维护性降低；</li><li><strong>隐式依赖</strong>：函数式编程中，参数的输入与输出除了通过参数列表与返回值传递，还可能通过闭包或其他上下文传递。这可能造成不易发现的隐式依赖，增加代码重构与问题排查的难度。</li><li><strong>新人训练成本较高</strong>：对于习惯了过程式与面向对象编程，而不熟悉函数式编程的新人，上手项目可能需要一定时间，因为常见的一些概念（可变状态与数据结构，类封装）在函数式编程中并没有对应物，而头等函数、状态传递、柯里化等函数式编程的概念需要多加联系才能理解并掌握。</li><li><strong>调试难度较大</strong>：函数式编程中不鼓励使用可变状态，因此调试时往往不能直接修改状态来查看效果；在不可避免地需要处理副作用的逻辑时（如IO操作、网络请求），往往难以追踪其状态变化。</li></ol><p>针对函数式编程的特点，最好是将其应用于其适合的领域，而不是试图将其用于解决所有业务问题。</p><ol><li><strong>适合的领域</strong>：<ul><li><strong>数学和科学问题</strong>：函数式编程的数学基础使其在解决数学和科学领域的问题时非常有效。纯函数的不变性有助于确保正确性。</li><li><strong>数据处理和转换</strong>：函数式编程适用于数据流处理、转换和过滤。例如，处理大量数据、清洗数据、映射、过滤等操作。</li><li><strong>并发和分布式系统</strong>：函数式编程的不可变性和纯函数特性使其在并发和分布式环境中更易于调试和维护。</li></ul></li><li><strong>不适合的领域</strong>：<ul><li><strong>复杂业务逻辑</strong>：对于复杂的业务逻辑，函数式编程可能过于抽象，难以理解和维护。在这些情况下，面向对象编程可能更合适。</li><li><strong>性能要求极高的场景</strong>：函数式编程的函数调用开销较大，不适合对性能要求极高的场景。在这些情况下，结构化编程或优化的面向对象编程可能更合适。</li><li><strong>与外部状态强相关的问题</strong>：函数式编程不擅长处理与外部状态强相关的问题，例如GUI应用程序、游戏引擎等。</li></ul></li></ol><h1 id="进一步阅读"><a class="markdownIt-Anchor" href="#进一步阅读"></a> 进一步阅读</h1><ul><li><a href="https://www.bilibili.com/video/BV1Zg4y1r7n3/?share_source=copy_web&amp;vd_source=b3eb8a434e0491220a8192266e606984">【熟】代码美学：亲爱的函数式大佬</a></li><li><a href="https://zhuanlan.zhihu.com/p/57972301">Y分钟入门lambda演算 - 李欣宜的文章 - 知乎</a></li><li><a href="https://ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 Android 开发经验包</title>
      <link href="/posts/1377966510/"/>
      <url>/posts/1377966510/</url>
      
        <content type="html"><![CDATA[<p>作为 Android 开发工作了三年多，见过许许多多的屎山代码与令人血压上升的操作，在这里总结一些个人开发经验，希望有所帮助。</p><ul><li><a href="/posts/299597505/">自定义 View 推荐实践</a></li><li><a href="/posts/211138720/">Fragment 开发推荐实践</a></li><li><a href="/posts/1604513434/">整洁代码推荐实践</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 推荐实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整洁代码推荐实践</title>
      <link href="/posts/1604513434/"/>
      <url>/posts/1604513434/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>这里的建议大多数应用于 Java 语言，其他编程语言也可以适当参考。<br />有一些更通用的、关于如何编写整洁代码的建议，可以参考《整洁代码之道》</p><!-- toc --><ul><li><a href="/posts/1604513434/#%E5%87%8F%E5%B0%91%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%88%A4%E7%A9%BA%EF%BC%9B%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8-Nullable-NonNull-%E6%B3%A8%E8%A7%A3">减少无意义的判空；学会使用 <code>@Nullable</code> <code>@NonNull</code> 注解</a></li><li><a href="/posts/1604513434/#%E5%B0%BD%E9%87%8F-%E9%81%BF%E5%85%8D-%E4%BD%BF%E7%94%A8-checked-exceptions">尽量<em>避免</em>使用 checked exceptions</a></li><li><a href="/posts/1604513434/#%E4%B8%8D%E4%BB%85%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%88%96%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%9B%BF%E4%BB%A3%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">不仅是语法糖：尽量使用 Lambda 表达式或方法引用替代匿名内部类</a></li><li><a href="/posts/1604513434/#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E3%80%81%E7%94%B1%E6%8A%BD%E8%B1%A1%E5%88%B0%E5%85%B7%E4%BD%93%E5%9C%B0%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81">自顶向下、由抽象到具体地组织代码</a></li><li><a href="/posts/1604513434/#%E4%B8%8D%E8%A6%81%E6%83%A7%E6%80%95%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%9B%B4%E4%B8%8D%E8%A6%81%E9%9A%90%E8%97%8F%E5%BC%82%E5%B8%B8%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E5%A5%BD%E8%BF%87%E5%A4%84%E5%A4%84%E5%85%9C%E5%BA%95">不要惧怕异常，更不要隐藏异常：快速失败好过处处兜底</a></li></ul><!-- tocstop --><span id="more"></span><h1 id="减少无意义的判空学会使用-nullable-nonnull-注解"><a class="markdownIt-Anchor" href="#减少无意义的判空学会使用-nullable-nonnull-注解"></a> 减少无意义的判空；学会使用 <code>@Nullable</code> <code>@NonNull</code> 注解</h1><p>如果已知引用不可能为空，就无需判空。例如，在以下情况下，Java 语言会保证变量不为空：</p><ul><li>前面的代码已经做了判空处理；</li><li>待检查的对象是由一个保证非空返回值的方法返回的，如构造工厂方法或 <code>Objects.requireNonNull</code> 方法；</li><li>待检查的对象是由基本类型自动装箱得到的。</li><li>在 switch-case 语句中，<code>switch</code> 的变量不用再判空，因为如果为空会抛出 <code>NullPointerException</code>（建议在 switch-case 之前加上判空）；</li><li>变量 <code>instanceof</code> 操作符返回 <code>true</code> 时，不用再判空。因为如果为空，<code>instanceof</code> 操作符会返回 <code>false</code>；</li><li>通过 try-catch 捕获的异常对象不用判空；</li><li><code>new</code> 方法创建的对象一定不为空；</li></ul><p>可空性和非空性是可以传递的，但 Java 语言没有提供这样的语法检查机制，这被称为“十亿美元的错误”。一些新兴的语言通过将可空性纳入类型系统来解决这个问题。如果你仍然需要维护 Java 代码或者不能使用 Kotlin，你可以考虑使用 <code>@Nullable</code> 和 <code>@NonNull</code> 注解来标注可空性和非空性。</p><h1 id="尽量避免使用-checked-exceptions"><a class="markdownIt-Anchor" href="#尽量避免使用-checked-exceptions"></a> 尽量<em>避免</em>使用 checked exceptions</h1><p>Java 语言中，异常分为两种：checked exceptions 和 unchecked exceptions。Checked exceptions 是指那些必须在编译时被捕获或者抛出的异常，而 unchecked exceptions 是指那些可以在运行时被忽略的异常。虽然 checked exceptions 的设计初衷是为了提高程序的健壮性和可靠性，但是在实际开发中，它们也带来了一些问题和挑战：</p><ol><li><strong>增加代码复杂性</strong>： 强制性的异常处理导致代码复杂度提升。当方法声明了 checked exceptions，调用者被迫处理这些异常，即便在某些情况下这些异常的发生概率极低，这可能导致代码冗余。更进一步，强制性的异常处理使得处理异常的代码散布在各个调用处，这对代码的内聚性和可复用性产生了负面影响。</li><li><strong>异常处理流于形式</strong>： 由于对 checked exceptions 的处理是强制性的，开发者往往会选择使用空的 catch 块或者仅仅重新抛出异常，这并没有真正地处理异常，而只是在形式上遵守了规则。</li><li><strong>限制运行时灵活性</strong>：Checked exceptions 需要在编译时进行处理，这可能会对程序的运行时灵活性造成限制。例如，当使用反射或者其他动态技术时，编译时的异常声明可能变得不再适用。</li><li><strong>不兼容 Lambda 表达式</strong>：Lambda 表达式的方法签名是由调用处接口的方法签名推断得出的，checked exceptions 作为方法签名的一部分，通常不会在调用处接口中声明，因此该异常不能通过函数式接口界面传递给上层调用者。因此，使用 checked exceptions 会阻碍方法在 Lambda 表达式中的使用。</li></ol><p>总的来说，开发者需要全面理解和应对 checked exceptions 的各种挑战，在代码中审慎使用该特性，以提高代码的质量和可维护性。</p><h1 id="不仅是语法糖尽量使用-lambda-表达式或方法引用替代匿名内部类"><a class="markdownIt-Anchor" href="#不仅是语法糖尽量使用-lambda-表达式或方法引用替代匿名内部类"></a> 不仅是语法糖：尽量使用 Lambda 表达式或方法引用替代匿名内部类</h1><p>相比匿名内部类，Lambda 表达式有以下好处：</p><ol><li>更加简短，便于阅读，特别是在方法体本身只有一两行的情况下，大大减少冗余信息展示，而聚焦业务逻辑本身。</li><li>不会隐式捕获外部类的 <code>this</code> 指针，能在很多情形下避免内存泄露。</li><li>不能获取指向自身的<code>this</code> 指针：在 Lambda 方法体内调用 <code>this</code> 指向的实际上是其外部类对象。这在某些特殊情况下会有些小小的不便，但大多数情况下会避免潜在的错误：比如在使用入参为 “Lambda 类型与外部类类型的公共类”（最常见的如<code>Object</code>）的方法时，不会在应该传入外部类对象时，错误传入匿名内部类对象。</li><li>鼓励使用函数式的表达方式，简化业务代码。</li></ol><p>如果你一时想不起方法签名，而使用了匿名内部类的表示，Intellij 或者 Android Studio 这样的 IDE 也会在可转化为 Lambda 表达式的情况下提醒你。不用担心，大胆应用建议的操作吧！</p><h1 id="自顶向下-由抽象到具体地组织代码"><a class="markdownIt-Anchor" href="#自顶向下-由抽象到具体地组织代码"></a> 自顶向下、由抽象到具体地组织代码</h1><p>好的代码就像一篇良好组织的文章或报告，首先是概述或总结，然后是具体的章节和详细信息。即使只是更换方法在文件中的先后顺序，也能有效提高编写和阅读代码的效率。下面是编写和组织代码的一些建议：</p><ol><li><strong>首先定义接口和抽象类</strong>：在编码开始时，先确定并定义系统的高层次结构，如接口和抽象类，以概述主要功能和行为。</li><li><strong>模块化高层逻辑</strong>：创建清晰的高层模块来表示系统的核心逻辑，隔离复杂性并提供一个简单的外部视图。</li><li><strong>方法实现紧跟声明</strong>：代码中的某个方法 A 调用私有方法 B 时，应将方法 B 的代码放在方法 A 后面。这样，读者可以在了解方法 A 的功能后，马上看到方法 B 的实现，避免分散注意力。</li><li><strong>清晰注释关键接口</strong>：对于关键的接口和抽象类，提供清晰的注释来说明其用途和作用，便于理解和后续维护。</li><li><strong>避免混淆抽象和具体实现</strong>：在代码中明确区分抽象概念和具体实现，避免在一个区域混合使用，以免造成混乱。</li></ol><h1 id="不要惧怕异常更不要隐藏异常快速失败好过处处兜底"><a class="markdownIt-Anchor" href="#不要惧怕异常更不要隐藏异常快速失败好过处处兜底"></a> 不要惧怕异常，更不要隐藏异常：快速失败好过处处兜底</h1><p>对线上异常的恐惧根植在许多开发者的内心，以至于恨不得每一个方法外面都包裹一层 try-catch。</p><p>但异常不是洪水猛兽，它是对你代码出现问题的强有力的提醒，也是对践行“快速失败”这一开发原则的有效工具。</p><p>“快速失败”（Fail-fast）是一种设计哲学，它鼓励软件在检测到问题的第一时间立即报告错误，而不是尝试继续运行并可能导致更多的错误。这个原则背后的理念是，“早期发现并处理错误”比“错误被隐藏，并在未来某个不确定的时间点引发更严重问题”要好。</p><p>具体来说，“快速失败”原则可以为软件开发提供以下好处：</p><ul><li><strong>提早发现问题：</strong> 通过快速失败，开发者可以更快地识别出代码中的问题，从而在问题变得复杂和难以追踪之前就及时修复它们。</li><li><strong>简化调试过程：</strong> 当程序在出现问题时立即停止，开发者可以更容易地定位问题发生的具体位置，这比在程序的后期阶段追踪错误要简单得多。</li><li><strong>防止错误累积：</strong> 如果错误没有被及时发现和处理，它们可能会在系统中累积，导致更大的问题，甚至可能导致系统崩溃。快速失败有助于防止这种情况的发生。</li><li><strong>提高系统的健壮性：</strong> 系统在面对潜在的错误时能够迅速响应并采取措施，这表明系统具备良好的错误处理能力，从而提高了系统的整体健壮性。</li><li><strong>促进良好的编程习惯：</strong> 遵循快速失败原则的开发者往往会更加关注代码的质量和健壮性，从而促进更好的编程实践和习惯。</li></ul><p>开发者常常对程序可能出现的失败或异常感到恐惧，主要是因为他们担心这些错误会使系统变得不稳定或难以维护。然而，快速失败原则实际上鼓励开发者将这种担忧转化为积极的行动，通过提前处理错误，从而降低长期的风险和成本。</p><p>以 GUI 应用程序为例，如果在每个地方都捕获异常，可能会导致一些比应用程序崩溃更糟糕的情况：</p><ol><li>异常发生了，但被悄悄地捕获了，没有错误日志被记录，也没有人注意到这个问题。</li><li>由于捕获异常的地方可能在调用栈的很上层，距离异常发生的地方很远，应用程序不会自动从异常中恢复。如果你没有告诉它在异常发生时应该做什么（例如显示错误信息并提供一个重试按钮），它就什么也不会做。</li><li>应用程序就这样尴尬地处于一个错误的中间状态，向用户展示一个空白的或错乱的屏幕，用户除了完全退出并重新启动应用程序，没有其他办法回到之前的流程中。</li><li>另一种可能是，应用程序从错误的中间状态开始继续运行，它带着重伤继续艰难地运行，一个错误引发了无数个错误，直到最后另一个异常结束了它。这个最后的异常与最初的异常发生的地方相距甚远，你完全不知道应用程序经历了什么，才会发生如此离谱的错误。</li></ol><p>这种情况比应用程序直接崩溃更可怕，原因如下：</p><ol><li>你对应用程序出现问题一无所知，没有在第一时间修复它，直到愤怒的用户投诉过来你才知道发生了什么。而在此之前，已经有许多沉默的用户悄悄地流失了，还有一些用户面对白屏或错误的页面束手无策，不知道如何恢复正常。</li><li>你发现出了问题，但你完全不知道为什么。由于异常发生的第一现场被悄悄掩盖了，你失去了问题发生的上下文，找出问题出现的具体位置变得极其困难。</li><li>表面上看起来一切都没有问题，但代码复杂度增加、资源泄露、安全隐患等隐性风险会一直累积，直到应用程序的体验极差、项目难以维护。</li></ol><p>当然，事情也没必要走向另一个极端。快速失败原则并不意味着开发者不应该捕获和处理任何异常。相反，它强调的是在发现错误时应该立即采取行动，这可能包括记录错误、通知开发者、终止当前操作或者采取其他适当的错误处理措施。关键在于如何响应这些异常：</p><ol><li><strong>输入验证：</strong> 在用户输入或者接收到外部数据时，立即进行验证。如果数据不符合预期，应立即返回错误或提示用户，而不是让错误的数据影响程序的其他部分。</li><li><strong>错误日志记录：</strong> 当异常发生时，应该记录详细的错误信息和堆栈跟踪。<strong>不要捕获异常而不进行任何处理</strong>，即使是打印日志也好。这样可以避免程序在不透明的状态下继续运行。</li><li><strong>使用断言：</strong> 在开发期间，使用断言检查不应该发生的条件。例如，在测试渠道包使用<code>Objects.requireNonNull</code>检查某个重要的变量不为空。这些断言在生产环境中通常是禁用的，但它们在开发和测试阶段可以帮助及早发现问题。</li><li><strong>及时的异常处理：</strong> 在可能抛出异常的代码块周围使用 try-catch 语句，但<strong>只捕获那些你知道如何处理的异常</strong>。例如，当处理网络请求时，捕获<code>IOException</code>并提供用户重试的选项，或者试图从容器中取元素时，捕获 <code>IndexOutOfBoundsException</code> 并视作&quot;没有对应的元素&quot;来处理。</li><li><strong>优化异常传播：</strong> 如果你不知道如何处理可能发生的异常，应当将其抛出，将异常传播到可以处理它的地方。例如，如果一个低级方法遇到无法解决的异常，它应该将异常传播到上层，让更高层的逻辑处理这个异常。捕获异常的最佳地点是在各个业务层级、各套独立 API 之间的交接点。</li><li><strong>用户友好的错误处理：</strong> 当错误发生时，尝试提供清晰的用户反馈，而不是让应用崩溃。使用<code>Toast</code>、<code>Snackbar</code>或者错误界面来通知用户发生了错误，并可能提供解决步骤。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 推荐实践 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 View 推荐实践</title>
      <link href="/posts/299597505/"/>
      <url>/posts/299597505/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="/posts/299597505/#%E5%B0%BD%E5%8F%AF%E8%83%BD%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89-View">尽可能避免使用自定义 View</a></li><li><a href="/posts/299597505/#%E4%BD%BF%E7%94%A8-Presenter-%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%AE%9A%E4%B9%89-View-%E5%B0%81%E8%A3%85%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E9%80%BB%E8%BE%91">使用 Presenter 代替自定义 View 封装数据绑定逻辑</a></li><li><a href="/posts/299597505/#%E4%BD%BF%E7%94%A8%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E4%BB%A3%E6%9B%BF%E9%87%8D%E5%86%99-View-%E6%96%B9%E6%B3%95">使用注册回调代替重写 View 方法</a></li><li><a href="/posts/299597505/#View-%E7%9A%84%E8%81%8C%E8%B4%A3%E4%BB%85%E6%9C%89%E5%B1%95%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%93%8D%E5%BA%94%E4%BA%A4%E4%BA%92%EF%BC%8C%E5%B0%86%E5%85%B6%E4%BB%96%E6%89%80%E6%9C%89%E9%80%BB%E8%BE%91%E7%A7%BB%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89-View">View 的职责仅有展示数据与响应交互，将其他所有逻辑移出自定义 View</a></li></ul><!-- tocstop --><span id="more"></span><h1 id="尽可能避免使用自定义-view"><a class="markdownIt-Anchor" href="#尽可能避免使用自定义-view"></a> 尽可能避免使用自定义 View</h1><p>Android View 系统是个技术债务极重的系统：API 30 的 View.java 有 30409 行！这一债务如此沉重，以至于 Google 最终决定另起一套视图系统（Jetpack Compose）而非在现有系统基础上继续修补。</p><p>当你继承 View 类时，你也继承了这一沉重的技术债务。</p><ul><li>对 View 进行单元测试非常困难，因为其严重依赖 Android 运行时环境。</li><li>如果你的自定义 View 中有业务相关的初始化逻辑，在 Layout Inspector 中预览视图可能会失败，因为其不能脱离真实 Android 设备正确模拟视图创建过程。这很影响开发效率。</li><li>对于重建 Activity/Fragment 的场景，系统会重新创建视图层级，这可能会绕过你自定义的初始化逻辑。</li></ul><p>如果你只是想要一个编写业务逻辑的地方，请使用 Presenter 设计模式。如果你需要重写 View 方法以实现业务逻辑，请考虑使用监听器能否实现相同功能。</p><h1 id="使用-presenter-代替自定义-view-封装数据绑定逻辑"><a class="markdownIt-Anchor" href="#使用-presenter-代替自定义-view-封装数据绑定逻辑"></a> 使用 Presenter 代替自定义 View 封装数据绑定逻辑</h1><p>经常有需求需要封装一组视图，并对外提供数据绑定的方法。相对于使用自定义视图，更推荐使用 Presenter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextView</span> <span class="keyword">extends</span> <span class="title class_">TextView</span> &#123;</span><br><span class="line">  <span class="comment">// 要写四个对你业务毫无作用的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs,</span></span><br><span class="line"><span class="params">            <span class="meta">@AttrRes</span> <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs,</span></span><br><span class="line"><span class="params">            <span class="meta">@AttrRes</span> <span class="type">int</span> defStyleAttr, <span class="meta">@StyleRes</span> <span class="type">int</span> defStyleRes)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">         initViews();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initViews</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do whatever</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setText(<span class="string">&quot;my &quot;</span> + text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyTextView</span> <span class="variable">mtv</span> <span class="operator">=</span> findViewById(R.id.my_text);</span><br><span class="line">mtv.setMyText(<span class="string">&quot;computer&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyTextPresenter</span> <span class="keyword">extends</span> <span class="title class_">TextView</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TextView myView;</span><br><span class="line">  <span class="comment">// 推荐用工厂模式提供实例，以避免对一个视图创建多个 Presenter，造成不一致</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> MyTextPresenter <span class="title function_">bind</span><span class="params">(TextView tv)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在这里添加去重逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyTextPresenter</span>(tv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有一个构造器，好耶</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">MyTextPresenter</span><span class="params">(TextView tv)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.myView = tv;</span><br><span class="line">      initViews();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initViews</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// do whatever</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        myView.setText(<span class="string">&quot;my &quot;</span> + text);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyTextPresenter</span> <span class="variable">presenter</span> <span class="operator">=</span> MyTextPresenter.bind(findViewById(R.id.my_text));</span><br><span class="line">presenter.setMyText(<span class="string">&quot;computer&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样做有以下好处：</p><ul><li>封装了 View 的接口方法，避免外界随意调用篡改其内容；</li><li>将视图布局本身与数据绑定接口解耦，便于以后修改布局；</li></ul><h1 id="使用注册回调代替重写-view-方法"><a class="markdownIt-Anchor" href="#使用注册回调代替重写-view-方法"></a> 使用注册回调代替重写 View 方法</h1><p>有时自定义 View 的目的是为了重写特定的 View 以实现业务逻辑，但大部分这样的场景都可以通过注册 Listener 实现，以下是一些例子。</p><table><thead><tr><th>可重写的方法</th><th>相应的监听器或接口</th></tr></thead><tbody><tr><td>onClick</td><td>OnClickListener</td></tr><tr><td>onLongClick</td><td>OnLongClickListener</td></tr><tr><td>onFocusChange</td><td>OnFocusChangeListener</td></tr><tr><td>onKey</td><td>OnKeyListener</td></tr><tr><td>onTouchEvent</td><td>OnTouchListener</td></tr><tr><td>onGenericMotion</td><td>OnGenericMotionListener</td></tr><tr><td>onSystemUiVisibilityChange</td><td>OnSystemUiVisibilityChangeListener</td></tr></tbody></table><h1 id="view-的职责仅有展示数据与响应交互将其他所有逻辑移出自定义-view"><a class="markdownIt-Anchor" href="#view-的职责仅有展示数据与响应交互将其他所有逻辑移出自定义-view"></a> View 的职责仅有展示数据与响应交互，将其他所有逻辑移出自定义 View</h1><p>这样符合单一职责原则，也便于业务逻辑复用。</p><p>另外，业务逻辑的生命周期不一定与 View 一致，将两者分离可以减少潜在的 bug 风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 推荐实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment 开发推荐实践</title>
      <link href="/posts/211138720/"/>
      <url>/posts/211138720/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="/posts/211138720/#Fragment-%E8%A7%86%E5%9B%BE%E5%86%85%E5%B5%8C%E5%A5%97-Fragment-%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8-getChildFragmentManager-%E8%80%8C%E9%9D%9E-getActivity-getSupportFragmentManager"><code>Fragment</code> 视图内嵌套 <code>Fragment</code> 时，使用 <code>getChildFragmentManager()</code> 而非 <code>getActivity().getSupportFragmentManager()</code></a></li><li><a href="/posts/211138720/#%E5%88%9B%E5%BB%BA-Fragment-%E6%97%B6%EF%BC%8C%E5%85%88%E5%B0%9D%E8%AF%95%E5%A4%8D%E7%94%A8%E5%B7%B2%E6%9C%89%E7%9A%84-Fragment">创建 <code>Fragment</code> 时，先尝试复用已有的 <code>Fragment</code></a></li><li><a href="/posts/211138720/#%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%9E%84%E9%80%A0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%86%85%E4%B8%BA-Fragment-%E6%B3%A8%E5%85%A5-Bundle-Arguments-%E4%BB%A5%E5%A4%96%E7%9A%84%E4%BE%9D%E8%B5%96">不可以在构造工厂方法内为 <code>Fragment</code> 注入 Bundle Arguments 以外的依赖</a></li><li><a href="/posts/211138720/#%E6%8F%90%E4%BA%A4-FragmentTransaction-%E6%97%B6%EF%BC%8C%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-commit-%E8%80%8C%E9%9D%9E-commitNow">提交 <code>FragmentTransaction</code> 时，优先使用 <code>commit()</code> 而非 <code>commitNow()</code></a></li><li><a href="/posts/211138720/#%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8-commit-%E5%89%8D%E6%A3%80%E6%9F%A5%E7%8A%B6%E6%80%81%EF%BC%8C%E8%80%8C%E9%9D%9E%E6%97%A0%E8%84%91%E4%BD%BF%E7%94%A8-commitAllowingStateLoss">考虑使用 <code>commit()</code> 前检查状态，而非无脑使用 <code>commitAllowingStateLoss()</code></a></li><li><a href="/posts/211138720/#FAQ">FAQ</a></li></ul><!-- tocstop --><span id="more"></span><h1 id="fragment-视图内嵌套-fragment-时使用-getchildfragmentmanager-而非-getactivitygetsupportfragmentmanager"><a class="markdownIt-Anchor" href="#fragment-视图内嵌套-fragment-时使用-getchildfragmentmanager-而非-getactivitygetsupportfragmentmanager"></a> <code>Fragment</code> 视图内嵌套 <code>Fragment</code> 时，使用 <code>getChildFragmentManager()</code> 而非 <code>getActivity().getSupportFragmentManager()</code></h1><p>如果子 <code>Fragment</code> <em>视图</em>是在某个 <code>Fragment</code> 视图内创建的，那么应该使用该 <code>Fragment</code> 的 <code>ChildFragmentManager</code> 管理其状态。</p><p><code>FragmentManager</code> 不仅负责 <code>Fragment</code> 状态切换，还负责在重建 <code>Activity</code> 时恢复 <code>Fragment</code> 状态。在恢复 <code>Fragment</code> 状态时，如果使用了错误的 <code>FragmentManager</code>，可能会导致 <code>Fragment</code> 状态恢复错误，引起界面异常、崩溃或逻辑错误。</p><p>考虑以下错误情形：</p><ol><li>使用视图容器 id 添加 <code>SubFragment</code> 到 <code>MainFragment</code> 的子视图，但使用了 <code>MainFragment</code> 对应 <code>Activity</code> 的 <code>FragmentManager</code></li><li>对应 <code>Activity</code> 动态添加了有相同 id  的视图到视图树（例如 <code>ViewPager</code>）</li><li>恢复 <code>Fragment</code> 状态时，从视图树找到了动态添加的视图，而非先前作为容器的视图，造成界面异常或崩溃。</li></ol><p>此外，Lifecycle 相关 API 支持锁定 <code>Fragment</code> 的 <code>maxLifeCycle</code>，此设置会应用到其 <code>ChildFragmentManager</code> 管理的子 <code>Fragment</code>。如果使用了错误的 <code>FragmentManager</code>，会导致生命周期表现不符合预期，造成意外的 <code>LiveData</code> 更新、业务逻辑错误等问题。</p><h1 id="创建-fragment-时先尝试复用已有的-fragment"><a class="markdownIt-Anchor" href="#创建-fragment-时先尝试复用已有的-fragment"></a> 创建 <code>Fragment</code> 时，先尝试复用已有的 <code>Fragment</code></h1><p>由于 <code>FragmentManager</code> 保存了 Fragment 的状态，在配置变更造成 <code>Activity</code> 和 <code>Fragment</code> 重建时，会先从保存的状态创建 Fragment，并试图关联到对应的视图层级。</p><p>如果不加判断地创建和添加 <code>Fragment</code>，轻则丢失保存的状态，重则重复添加 <code>Fragment</code> 导致 crash。</p><p>如果实际添加到视图的 <code>Fragment</code> 实例是由系统恢复的，而业务逻辑依赖的 <code>Fragment</code> 实例是自己创建的，则可能造成难以复现和排查的问题。</p><p>为此，在创建 <code>Fragment</code> 时，尝试复用已有的 <code>Fragment</code>。如果判断已有的 <code>Fragment</code> 不能复用，要显式移除该 <code>Fragment</code>，避免内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    containerPageFragment = ContainerFragment.newInstance(containerBundle);</span><br><span class="line">  <span class="comment">// 这里用 add 的话，重建会出错，正是由于系统已经帮忙恢复了 Fragment，再 add 到同一个容器会抛异常。用 replace 相当于丢弃了系统恢复的实例</span></span><br><span class="line">      getSupportFragmentManager()</span><br><span class="line">              .beginTransaction()</span><br><span class="line">              .replace(R.id.fragment_container, containerPageFragment)</span><br><span class="line">              .commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐实践</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line">    containerPageFragment = getOrCreateFragment(fm, R.id.fragment_container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ContainerFragment <span class="title function_">getOrCreateFragment</span><span class="params">(FragmentManager fm, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="type">Fragment</span> <span class="variable">fragment</span> <span class="operator">=</span> fm.findFragmentById(id);</span><br><span class="line">    <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> ContainerPageFragment) &#123;</span><br><span class="line">      <span class="keyword">return</span> (ContainerPageFragment) fragment; <span class="comment">// 直接返回可以复用的 Fragment</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">FragmentTransaction</span> <span class="variable">ft</span> <span class="operator">=</span> fm.beginTransaction();</span><br><span class="line">    <span class="keyword">if</span> (fragment != <span class="literal">null</span>) &#123;</span><br><span class="line">        ft.remove(fragment); <span class="comment">// 移除不能复用的 Fragment</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ContainerFragment</span> <span class="variable">containerPageFragment</span> <span class="operator">=</span> ContainerFragment.newInstance(containerBundle);</span><br><span class="line">  <span class="comment">// 前面已经移除了可能在这个 id 上的 Fragment，这里可以放心用 add</span></span><br><span class="line">    ft.add(id, containerPageFragment)</span><br><span class="line">              .commit();</span><br><span class="line">    <span class="keyword">return</span> containerPageFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>androidx.fragment.app</code> 1.2.0 以上的版本引入了基于类的 <code>add()</code> 和 <code>replace()</code> 方法，推荐使用这些方法替代显式创建新实例的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> fragment.getChildFragmentManager();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">args.putLong(<span class="string">&quot;userId&quot;</span>, getUser().getUserId());</span><br><span class="line"><span class="comment">// 可以使用该方法一并传入 arguments bundle，省去构造工厂方法</span></span><br><span class="line">fm.beginTransaction().add(id, ContainerPageFragment.class, args).commit();</span><br></pre></td></tr></table></figure><h1 id="不可以在构造工厂方法内为-fragment-注入-bundle-arguments-以外的依赖"><a class="markdownIt-Anchor" href="#不可以在构造工厂方法内为-fragment-注入-bundle-arguments-以外的依赖"></a> 不可以在构造工厂方法内为 <code>Fragment</code> 注入 Bundle Arguments 以外的依赖</h1><p>由于 <code>Fragment</code> 重建机制的存在，在构造工厂方法里注入 Bundle Arguments 以外的依赖是不可靠的：<code>Fragment</code> 重建时，只会恢复保存的 Bundle Arguments，并不会恢复其他依赖。</p><p>虽然可以对这种情况判断并单独注入依赖，但相对更好的方式是在 <code>FragmentLifecycleCallbacks</code> 统一处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的做法</span></span><br><span class="line">MyBusinessLogic logic;</span><br><span class="line"><span class="type">ContainerFragment</span> <span class="variable">containerFragment</span> <span class="operator">=</span> ContainerFragment.newInstance(containerBundle, logic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment 构造工厂里，对于不能保存在 Bundle Arguments 里的依赖项，不应该进行注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ContainerFragment <span class="title function_">newInstance</span><span class="params">(Bundle bundle, MyBusinessLogic logic)</span> &#123;</span><br><span class="line">    <span class="type">ContainerFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerFragment</span>();</span><br><span class="line">    fragment.setArguments(bundle); <span class="comment">// 系统重建 Fragment 时，会恢复保存的 Arguments</span></span><br><span class="line">    fragment.setBusinessLogic(logic); <span class="comment">// 系统重建 Fragment 时，可不会帮你注入这个依赖</span></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 FragmentLifecycleCallbacks 注入依赖</span></span><br><span class="line">MyBusinessLogic logic;</span><br><span class="line"><span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> parent.getChildFragmentManager();</span><br><span class="line">fm.registerFragmentLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">FragmentManager</span>.FragmentLifecycleCallbacks() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentPreAttached</span><span class="params">(FragmentManager fm, Fragment f, Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ContainerFragment) &#123;</span><br><span class="line">            ((ContainerFragment) f).setBusinessLogic(logic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>也可以使用 Hilt 之类的依赖注入框架，这样开发者不必自己考虑如何注入依赖的问题。</p><p>最后，建议使用 <code>androidx.fragment.app</code> 1.2.0 以上版本引入的基于类的 <code>add()</code> 和 <code>replace()</code> 方法，逐步弃用传入 Fragment 实例的 <code>add()</code> 和 <code>replace()</code> ，最终完全弃用 Fragment 构造工厂方法，以避免潜在风险。</p><h1 id="提交-fragmenttransaction-时优先使用-commit-而非-commitnow"><a class="markdownIt-Anchor" href="#提交-fragmenttransaction-时优先使用-commit-而非-commitnow"></a> 提交 <code>FragmentTransaction</code> 时，优先使用 <code>commit()</code> 而非 <code>commitNow()</code></h1><p>使用 <code>commit()</code> 而非 <code>commitNow()</code> 有助于 <code>FragmentManager</code> 合并执行多个 <code>FragmentTransaction</code>，重排其内部操作的顺序、消除冗余操作。</p><h1 id="考虑使用-commit-前检查状态而非无脑使用-commitallowingstateloss"><a class="markdownIt-Anchor" href="#考虑使用-commit-前检查状态而非无脑使用-commitallowingstateloss"></a> 考虑使用 <code>commit()</code> 前检查状态，而非无脑使用 <code>commitAllowingStateLoss()</code></h1><p>开发过程中不时遇到使用 <code>commit()</code> 时抛出  <code>IllegalStateException</code> 异常，为应对该异常，许多开发者倾向于使用 <code>try-catch</code> 捕获，或使用 <code>commitAllowingStateLoss()</code> 代替 <code>commit()</code>。但这样做是有其副作用的，最好是理解框架抛异常的原因，并针对性地应对。</p><p><code>commit()</code> 时抛出 <code>IllegalStateException</code> 异常的原因有以下几种：</p><ol><li>当前 <code>FragmentManager</code> 已经保存了 <code>Fragment</code> 状态（宿主调用了 <code>onSaveInstanceState</code>），并且还没有重新恢复（还没有调用 <code>onCreate/onStart/onResume</code> ），因此此后的提交操作不会记录到保存的状态中，因此也不会在重建时恢复；</li><li>当前 <code>FragmentManager</code> 对应的 <code>LoaderManager</code> 已经完成了加载或正在重置，在 <code>onLoadFinished</code> 或 <code>onLoaderReset</code>回调返回前，不允许执行 <code>commit</code>，因为官方认为这个回调可能在任何时间返回（包括 <code>Fragment</code> 状态已保存或已被销毁），因此并不安全。（我个人认为这属于设计失误，用户应该自己确保调用安全）</li></ol><p>对于 <code>Fragment</code> 状态保存后抛出异常，其实是框架的预期行为，旨在提醒开发者确认并正确处理方法调用时机。</p><p>考虑以下使用场景：</p><ol><li>在网络数据返回时，创建并展示 <code>Fragment</code>，更新某个 <code>LiveData</code> 状态值，表示该 <code>Fragment</code> 处于展示状态；</li><li>如果此时用户实际上已经离开 app，<code>onSaveInstanceState</code> 已经调用，此时直接调用 <code>commit()</code> 添加了该 <code>Fragment</code>，应用将抛出异常；</li><li>如果此时改为使用<code>commitAllowingStateLoss()</code> 添加了该 <code>Fragment</code> ，将不会抛出异常。<ol><li>如果用户返回 app 时，app 没有被回收，页面没有被重建，表现也符合预期：<code>Fragment</code> 正常展示，<code>LiveData</code> 的值正常更新；</li><li>但如果用户返回 app 时，页面经历了重建过程，将出现不符合预期的表现：<code>Fragment</code> 没有正常展示，但 <code>LiveData</code> 的值被更新了，导致状态不一致，进而引起功能逻辑异常。这样的问题由于偶发性，也比较难以排查。</li></ol></li></ol><p>因此，调用 <code>commit()</code> 时抛出异常，是框架在提醒开发者，<code>Fragment</code> 状态的变更不会在重建之后恢复，当页面重建时可能会出现不一致的问题。对此开发者有两种应对方式：</p><ol><li><p>事前预防：尽量不要在启动生命周期回调（<code>onCreate/onStart/onResume</code>）之外，直接调用 <code>FragmentTransaction.commit()</code> 。<br />在需要在用户点击时、网络数据返回等异步回调中展示 <code>Fragment</code> 的场景，通过设置 <code>LiveData</code> ，将调用延迟到合适的时机。</p><p>如果不想或不适合使用 <code>LiveData</code>，则在调用 <code>commit()</code> 前，需要使用 <code>FragmentManager#isStateSaved()</code>检查状态是否已经被保存：如果状态尚未被保存，则调用 <code>commit()</code> 提交变更；如果状态已经被保存，则不调用 <code>commit()</code> 提交变更，并自行处理恢复逻辑。</p></li><li><p>事后处理：使用 <code>commitAllowingStateLoss()</code> 方法。<br />这意味着：开发者充分了解 <code>Fragment</code> 状态丢失的可能结果，并确认该情况不影响业务流程，或针对该情况调整了业务逻辑。<br />一种处理方案是：在处理 <code>Fragment</code> 状态变更前，使用 <code>ViewModel + LiveData</code> 记录将要进行的操作：在使用与 <code>Fragment</code> 状态相关的逻辑前，检查 <code>Fragment</code> 状态是否符合预期：如果不符合预期，则要根据之前的记录，进行必要的操作，以恢复预期的状态。<br />这种方案的维护成本较高，容易出错，因为往往不能确定在业务逻辑的何处会判断 <code>Fragment</code> 的状态，因此不推荐使用。</p></li></ol><p>对于 <code>LoaderManager</code> 引起的问题，Android 官方文档已经废弃 <code>LoaderManager</code>，建议是在新代码中不再使用 <code>LoaderManager</code> ，并尽快将已有的相关业务逻辑迁移到使用 <code>ViewModel + LiveData</code> 开发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐在回调用 commitAllowingStateLoss</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallback</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">   getChildFragmentManager().beginTransaction()</span><br><span class="line">            .replace(R.id.placeholder,MyFragment.newInstance(data))</span><br><span class="line">            .commitAllowingStateLoss();</span><br><span class="line">    pageShowStatus.setValue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐：使用 LiveData 推送变更，系统会在合适的时机回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallback</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">    pendingData.setValue(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LiveData 只会在页面活跃状态下推送变更，因此可以直接 commit()</span></span><br><span class="line">pendingData.addObserver(data -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> getChildFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (fm.isStateSaved()) &#123;</span><br><span class="line">        <span class="comment">// 怎么会走到这里来呢？就不处理了吧</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      getChildFragmentManager().beginTransaction()</span><br><span class="line">              .replace(R.id.placeholder, MyFragment.newInstance(data))</span><br><span class="line">              .commit();</span><br><span class="line">      pageShowStatus.setValue(<span class="literal">true</span>);</span><br><span class="line">      pendingData.setValue(<span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h1><h2 id="使用-commit-提交事务时fragment-状态变更是异步进行的-如果调用-commit-方法前尚未保存状态因此可以提交但在事务真正执行前插入了-onsaveinstancestate-调用是否会触发异常"><a class="markdownIt-Anchor" href="#使用-commit-提交事务时fragment-状态变更是异步进行的-如果调用-commit-方法前尚未保存状态因此可以提交但在事务真正执行前插入了-onsaveinstancestate-调用是否会触发异常"></a> 使用 <code>commit()</code> 提交事务时，<code>Fragment</code> 状态变更是异步进行的。如果调用 <code>commit()</code> 方法前尚未保存状态（因此可以提交），但在事务真正执行前，插入了 <code>onSaveInstanceState</code> 调用，是否会触发异常？</h2><p>答：<strong>不会</strong>。在 <code>onSaveInstanceState</code> 调用之前，会先执行<em>已提交但尚未执行</em>的事务，因此这些事务的状态会正确保存，也不会触发异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 推荐实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 遍历 PriorityQueue 注意事项</title>
      <link href="/posts/3921235105/"/>
      <url>/posts/3921235105/</url>
      
        <content type="html"><![CDATA[<p>最近写 LeetCode 踩了个坑，记录一下。</p><p>对于 PriorityQueue 和 ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue;</span><br><span class="line">ArrayList&lt;Integer&gt; list;</span><br></pre></td></tr></table></figure><p>下面两个操作是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="keyword">for</span> (Integer i: list)</span><br><span class="line">    queue.add(i);</span><br><span class="line"><span class="comment">// #2</span></span><br><span class="line">queue.addAll(list);</span><br></pre></td></tr></table></figure><p>然而下面代码中，前两个操作与第三个操作是<strong>不等价</strong>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="keyword">for</span> (Integer i: queue)</span><br><span class="line">    list.add(i);</span><br><span class="line"><span class="comment">// #2</span></span><br><span class="line">list.addAll(i);</span><br><span class="line"><span class="comment">// #3</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">    list.add(queue.poll());</span><br></pre></td></tr></table></figure><p>原因是 <code>PriorityQueue.poll</code> 操作会改变原有队列：弹出堆顶元素，再调整堆使其保持最小堆性质，这一改变对于维护其出列的有序性是必要的。另一方面，如果没有出列再调整这一过程，优先队列并不能保证遍历的有序性：只是简单的前序遍历。<br />换句话说就是 <code>queue.poll</code> 方法取出元素的顺序是有序的，而 <code>addAll</code> 方法与使用 for-each 循环遍历优先队列不改变原有优先队列，也就不能保证遍历顺序是有序的。这两个顺序<strong>不一样</strong>！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 应用组件源码分析 PPT 分享</title>
      <link href="/posts/2137979396/"/>
      <url>/posts/2137979396/</url>
      
        <content type="html"><![CDATA[<p>关于之前源码分析做的 PPT，总结了一些重点内容，包含了详细备注，有兴趣的可以下载下来。</p><p><a href="/attachments/2020-03-19-Android-%E5%BA%94%E7%94%A8%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-PPT-%E5%88%86%E4%BA%AB/Android%20%E5%BA%94%E7%94%A8%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.pptx">PPT 下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service 源码分析</title>
      <link href="/posts/2681383033/"/>
      <url>/posts/2681383033/</url>
      
        <content type="html"><![CDATA[<h1 id="android-service-简介"><a class="markdownIt-Anchor" href="#android-service-简介"></a> Android Service 简介</h1><blockquote><p>Service 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外，组件可通过绑定到服务与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可在后台处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序进行交互。</p></blockquote><p>服务分三种类型：</p><ol><li>前台服务：执行一些用户能注意到的操作，如播放音乐。前台服务必须显示通知。</li><li>后台服务：执行用户不会直接注意到的操作。</li><li>绑定服务：应用组件通过调用 <code>bindService</code> 绑定到服务。绑定服务提供客户端-服务器接口，以便组件与服务进行交互。绑定服务仅当应用组件绑定时才会启动，当全部绑定被取消时，服务会被销毁。</li></ol><p>服务可以既是启动服务（通过 <code>startService</code> 启动）又是绑定服务（通过 <code>bindService</code> 启动），取决于是否实现 <code>onStartCommand()</code> 和 <code>onBind()</code> 回调方法。</p><span id="more"></span><h2 id="创建服务"><a class="markdownIt-Anchor" href="#创建服务"></a> 创建服务</h2><p>如要创建服务，必须创建或使用 Service 类的子类。在实现中，必须实现一些处理服务生命周期的回调方法：</p><ul><li><code>onStartCommand()</code>: 当另一个组件通过 <code>startService</code> 请求启动服务时，系统会调用该方法。通过该方法调用的服务可以无限期运行。服务可以通过 <code>stopSelf()</code> 来自行停止运行。</li><li><code>onBind()</code>: 当另一组件通过 <code>bindService</code> 与服务绑定时，系统会调用该方法。该方法必须返回一个 <code>IBinder</code> 接口，以供客户端与服务通信。</li><li><code>onCreate()</code>: 首次创建服务时，系统会在调用 <code>onStartCommand()</code> 或 <code>onBind()</code> 前调用此方法。如果服务已在运行，则不会调用此方法。</li><li><code>onDestroy()</code>: 当不在使用服务并准备将其销毁时，系统会调用该方法。</li></ul><p>创建服务后，还必须在应用清单文件中声明所有服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.ExampleService&quot;</span> /&gt;</span></span><br><span class="line">      ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绑定到服务"><a class="markdownIt-Anchor" href="#绑定到服务"></a> 绑定到服务</h2><p>调用 <code>bindService(Intent, ServiceConnection, int)</code> 方法的组件必须实现 ServiceConnection 接口并将其传入 <code>bindService</code>。当应用组件调用 <code>bindService</code> 方法，系统将服务端 <code>onBind</code> 方法返回的 IBinder 对象传入 <code>ServiceConnection.onServiceConnected(ComponentName, IBinder)</code> 回调。客户端组件可通过此 IBinder 对象与客户端进行通信。</p><p>如果需要创建尚未处于活动状态的服务，则必须在 <code>flag</code> 参数中设置 <code>BIND_AUTO_CREATE</code> 标志，否则只能绑定到已经启动的服务。</p><h2 id="服务生命周期"><a class="markdownIt-Anchor" href="#服务生命周期"></a> 服务生命周期</h2><ol><li>通过 <code>startService</code> 方法启动的服务：<ol><li>除非通过 <code>stopService</code> 方法或服务自身调用 <code>stopSelf</code> 方法，将会无限期保持运行，即使进程被杀死也会重新启动；</li><li>如果运行过程中接收过 <code>bindService</code> 方法调用，必须等待所有设置 <code>BIND_AUTO_CREATE</code> 标志的客户端解绑，<code>stopService</code> 才会停止服务；</li></ol></li><li>通过 <code>bindService</code> 方法启动的服务：<ol><li>在所有 <code>bindService</code> 的客户端都调用 <code>unbindService</code> 解绑之后自动停止；</li><li>如果运行过程中接收过 <code>startService</code> 调用，必须调用 <code>stopService</code> 才会停止。</li></ol></li></ol><p>总结：<code>startService</code> 与 <code>stopService</code> 配对，<code>bindService</code> 与 <code>unbindService</code> 配对，只有完成配对，服务才会停止运行，除非调用 <code>stopService</code> 时所有活跃绑定都没有设置 <code>BIND_AUTO_CREATE</code>。详细说明参照 <a href="#service-%e5%81%9c%e6%ad%a2%e6%b5%81%e7%a8%8b">Service 停止流程</a>。</p><p>PS：<code>stopSelf</code> 方法的限制与 <code>stopService</code> 相同。</p><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><h2 id="service-启动流程"><a class="markdownIt-Anchor" href="#service-启动流程"></a> Service 启动流程</h2><p><img src="/images/2020-02-24-Service-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startService.svg" alt="Service 启动流程" /></p><p>我们从 <code>startService(Intent)</code> 方法开始分析。这个方法的实现在 ContextImpl 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ComponentName <span class="title function_">startService</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, <span class="literal">false</span>, mUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startForegroundService(Intent)</code> 方法与之几乎相同，除了调用 <code>startServiceCommon</code> 的第二个参数 <code>requireForeground</code> 为 <code>true</code>。</p><p><code>startServiceCommon</code> 对 Intent 进行检查，之后调用 AMS 的 <code>startService</code> 方法；</p><p><code>AMS.startService</code> 方法检查文件描述符泄漏和调用者之后，调用 <code>ActiveServices.startServiceLocked</code> 方法。</p><h3 id="startservicelocked"><a class="markdownIt-Anchor" href="#startservicelocked"></a> <code>startServiceLocked</code></h3><p><code>com.android.server.am.ActiveServices</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ComponentName <span class="title function_">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, <span class="type">boolean</span> fgRequired, String callingPackage,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">int</span> userId, <span class="type">boolean</span> allowBackgroundActivityStarts)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> callerFg;</span><br><span class="line">    ...... <span class="comment">// 判断调用者是否在前台</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">        retrieveServiceLocked(service, <span class="literal">null</span>, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="literal">true</span>, callerFg, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;!&quot;</span>, res.permission != <span class="literal">null</span></span><br><span class="line">                ? res.permission : <span class="string">&quot;private to package&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">r</span> <span class="operator">=</span> res.record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.exists(r.userId)) &#123;...; <span class="keyword">return</span> nulll;&#125;</span><br></pre></td></tr></table></figure><p>这一节做的事情有：</p><ol><li>判断调用者是否在前台；</li><li>调用 <code>retrieveServiceLocked</code> 方法解析 <code>service</code> 这个 Intent，得到 ServiceLookupResult，从中取得 ServiceRecord；</li><li>处理这个服务记录的用户不存在的情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we&#x27;re starting indirectly (e.g. from PendingIntent), figure out whether</span></span><br><span class="line"><span class="comment">// we&#x27;re launching into an app in a background state.  This keys off of the same</span></span><br><span class="line"><span class="comment">// idleness state tracking as e.g. O+ background service start policy.</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">bgLaunch</span> <span class="operator">=</span> !mAm.isUidActiveLocked(r.appInfo.uid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the app has strict background restrictions, we treat any bg service</span></span><br><span class="line"><span class="comment">// start analogously to the legacy-app forced-restrictions case, regardless</span></span><br><span class="line"><span class="comment">// of its target SDK version.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">forcedStandby</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (bgLaunch &amp;&amp; appRestrictedAnyInBackground(r.appInfo.uid, r.packageName)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    forcedStandby = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is a direct-to-foreground start, make sure it is allowed as per the app op.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">forceSilentAbort</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> mAm.mAppOpsService.checkOperation(</span><br><span class="line">            AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName);</span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> AppOpsManager.MODE_ALLOWED:</span><br><span class="line">        <span class="keyword">case</span> AppOpsManager.MODE_DEFAULT:</span><br><span class="line">            <span class="comment">// All okay.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AppOpsManager.MODE_IGNORED:</span><br><span class="line">            <span class="comment">// Not allowed, fall back to normal start service, failing siliently</span></span><br><span class="line">            <span class="comment">// if background check restricts that.</span></span><br><span class="line">            ...</span><br><span class="line">            fgRequired = <span class="literal">false</span>;</span><br><span class="line">            forceSilentAbort = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;!!&quot;</span>, <span class="string">&quot;foreground not allowed as per app op&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this isn&#x27;t a direct-to-foreground start, check our ability to kick off an</span></span><br><span class="line"><span class="comment">// arbitrary service</span></span><br><span class="line"><span class="keyword">if</span> (forcedStandby || (!r.startRequested &amp;&amp; !fgRequired)) &#123;</span><br><span class="line">    <span class="comment">// Before going further -- if this app is not allowed to start services in the</span></span><br><span class="line">    <span class="comment">// background, then at this point we aren&#x27;t going to let it period.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">allowed</span> <span class="operator">=</span> mAm.getAppStartModeLocked(r.appInfo.uid, r.packageName,</span><br><span class="line">            r.appInfo.targetSdkVersion, callingPid, <span class="literal">false</span>, <span class="literal">false</span>, forcedStandby);</span><br><span class="line">    <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DELAYED || forceSilentAbort) &#123;</span><br><span class="line">            <span class="comment">// In this case we are silently disabling the app, to disrupt as</span></span><br><span class="line">            <span class="comment">// little as possible existing apps.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (forcedStandby) &#123;</span><br><span class="line">            <span class="comment">// This is an O+ app, but we might be here because the user has placed</span></span><br><span class="line">            <span class="comment">// it under strict background restrictions.  Don&#x27;t punish the app if it&#x27;s</span></span><br><span class="line">            <span class="comment">// trying to do the right thing but we&#x27;re denying it for that reason.</span></span><br><span class="line">            <span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This app knows it is in the new model where this operation is not</span></span><br><span class="line">        <span class="comment">// allowed, so tell it what has happened.</span></span><br><span class="line">        <span class="type">UidRecord</span> <span class="variable">uidRec</span> <span class="operator">=</span> mAm.mProcessList.getUidRecordLocked(r.appInfo.uid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;?&quot;</span>, <span class="string">&quot;app is in background uid &quot;</span> + uidRec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point we&#x27;ve applied allowed-to-start policy based on whether this was</span></span><br><span class="line"><span class="comment">// an ordinary startService() or a startForegroundService().  Now, only require that</span></span><br><span class="line"><span class="comment">// the app follow through on the startForegroundService() -&gt; startForeground()</span></span><br><span class="line"><span class="comment">// contract if it actually targets O+.</span></span><br><span class="line"><span class="keyword">if</span> (r.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O &amp;&amp; fgRequired) &#123;</span><br><span class="line">    ...</span><br><span class="line">    fgRequired = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NeededUriGrants</span> <span class="variable">neededGrants</span> <span class="operator">=</span> mAm.mUgmInternal.checkGrantUriPermissionFromIntent(</span><br><span class="line">        callingUid, r.packageName, service, service.getFlags(), <span class="literal">null</span>, r.userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If permissions need a review before any of the app components can run,</span></span><br><span class="line"><span class="comment">// we do not start the service and launch a review activity if the calling app</span></span><br><span class="line"><span class="comment">// is in the foreground passing it a pending intent to start the service when</span></span><br><span class="line"><span class="comment">// review is completed.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX This is not dealing with fgRequired!</span></span><br><span class="line"><span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage,</span><br><span class="line">        callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行一系列与后台启动限制相关的检查。TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">r.startRequested = <span class="literal">true</span>;</span><br><span class="line">r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">r.fgRequired = fgRequired;</span><br><span class="line">r.pendingStarts.add(<span class="keyword">new</span> <span class="title class_">ServiceRecord</span>.StartItem(r, <span class="literal">false</span>, r.makeNextStartId(),</span><br><span class="line">        service, neededGrants, callingUid));</span><br></pre></td></tr></table></figure><p>设置 ServiceRecord，新建 StartItem 加入到其 pendingStarts 列表。这个列表包含了准备发送给服务以执行其 <code>onStartCommand</code> 方法的的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">    <span class="comment">// We are now effectively running a foreground service.</span></span><br><span class="line">    ...</span><br><span class="line">    mAm.mAppOpsService.startOperation(AppOpsManager.getToken(mAm.mAppOpsService),</span><br><span class="line">            AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要启动前台服务，调用 <code>AppOpsService.startOperation</code> 方法 TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="type">ServiceMap</span> <span class="variable">smap</span> <span class="operator">=</span> getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">addToStarting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!callerFg &amp;&amp; !fgRequired &amp;&amp; r.app == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="literal">null</span> || proc.getCurProcState() &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            <span class="comment">// If this is not coming from a foreground caller, then we may want</span></span><br><span class="line">            <span class="comment">// to delay the start if there are already other background services</span></span><br><span class="line">            <span class="comment">// that are starting.  This is to avoid process start spam when lots</span></span><br><span class="line">            <span class="comment">// of applications are all handling things like connectivity broadcasts.</span></span><br><span class="line">            <span class="comment">// We only do this for cached processes, because otherwise an application</span></span><br><span class="line">            <span class="comment">// can have assumptions about calling startService() for a service to run</span></span><br><span class="line">            <span class="comment">// in its own process, and for that process to not be killed before the</span></span><br><span class="line">            <span class="comment">// service is started.  This is especially the case for receivers, which</span></span><br><span class="line">            <span class="comment">// may start a service in onReceive() to do some additional work and have</span></span><br><span class="line">            <span class="comment">// initialized some global state as part of that.</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">                <span class="comment">// This service is already scheduled for a delayed start; just leave</span></span><br><span class="line">                <span class="comment">// it still waiting.</span></span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123;</span><br><span class="line">                <span class="comment">// Something else is starting, delay!</span></span><br><span class="line">                ...</span><br><span class="line">                smap.mDelayedStartList.add(r);</span><br><span class="line">                r.delayed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            addToStarting = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc.getCurProcState() &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">            <span class="comment">// We slightly loosen when we will enqueue this new service as a background</span></span><br><span class="line">            <span class="comment">// starting service we are waiting for, to also include processes that are</span></span><br><span class="line">            <span class="comment">// currently running other services or receivers.</span></span><br><span class="line">            addToStarting = <span class="literal">true</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125; ...</span><br><span class="line">    &#125; ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowBackgroundActivityStarts) &#123;</span><br><span class="line">        r.whitelistBgActivityStartsOnServiceStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ComponentName</span> <span class="variable">cmp</span> <span class="operator">=</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果服务对应进程没有启动，或者正在处理接收器，延迟启动服务，以避免大量服务同时启动：<ol><li>如果已经设置延迟启动，直接返回；</li><li>如果正在后台启动的服务 <code>smap.mStartingBackground</code> 大于上限，将当前启动服务记录设为延迟启动，并加入延迟启动清单 <code>smap.mDelayedStartList</code>，最后返回；</li></ol></li><li>没有延迟启动的，调用 <code>startServiceInnerLocked</code> 继续服务启动的流程。</li></ol><h3 id="startserviceinnerlocked"><a class="markdownIt-Anchor" href="#startserviceinnerlocked"></a> <code>startServiceInnerLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ComponentName <span class="title function_">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> callerFg, <span class="type">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line">    r.callStart = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;!!&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStartsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg || r.fgRequired) &#123;</span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新 ServiceRecord 的状态，调用 <code>bringUpServiceLocked</code> 拉起服务。</p><p>后台启动限制：TODO</p><h3 id="bringupservicelocked"><a class="markdownIt-Anchor" href="#bringupservicelocked"></a> <code>bringUpServiceLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="type">int</span> intentFlags, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> whileRestarting, <span class="type">boolean</span> permissionsReviewRequired)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="comment">// If waiting for a restart, then do nothing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// We are now bringing the service up, so no longer in the</span></span><br><span class="line">    <span class="comment">// restarting state.</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this service is no longer considered delayed, we are starting it now.</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        ...</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this service is started.  If not,</span></span><br><span class="line">    <span class="comment">// we don&#x27;t want to allow it to run.</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ...;</span><br><span class="line">        ...</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Service is now being launched, its package can&#x27;t be stopped.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, <span class="literal">false</span>, r.userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li>如果 <code>r.app != null &amp;&amp; r.app.thread != null</code>，表明此 Service 已经启动过，调用 <code>sendServiceArgsLocked</code> 方法，这个方法会执行 <code>Service.onStartCommand</code> 方法，之后返回；</li><li>如果 <code>!whileRestarting &amp;&amp; mRestartingServices.contains(r)</code>，服务正在等待重启，直接返回；</li><li>如果之前在等待重启列表，移除之，并清除正在重启状态；</li><li>如果之前设置延迟启动状态，移除之；</li><li>确认 Service 所在用户已启动，否则销毁服务；</li><li>设置 Service 所在 App 不可被 PackageManager 停止；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isolated</span> <span class="operator">=</span> (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">procName</span> <span class="operator">=</span> r.processName;</span><br><span class="line"><span class="type">HostingRecord</span> <span class="variable">hostingRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;service&quot;</span>, r.instanceName);</span><br><span class="line">ProcessRecord app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">    app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">            realStartServiceLocked(r, app, execInFg);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If this service runs in an isolated process, then each time</span></span><br><span class="line">    <span class="comment">// we call startProcessLocked() we will get a new isolated</span></span><br><span class="line">    <span class="comment">// process, starting another process if we are currently waiting</span></span><br><span class="line">    <span class="comment">// for a previous process to come up.  To deal with this, we store</span></span><br><span class="line">    <span class="comment">// in the service any current isolated process it is running in or</span></span><br><span class="line">    <span class="comment">// waiting to have come up.</span></span><br><span class="line">    app = r.isolatedProc;</span><br><span class="line">    <span class="keyword">if</span> (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">            &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">        hostingRecord = HostingRecord.byWebviewZygote(r.instanceName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != <span class="number">0</span>) &#123;</span><br><span class="line">        hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName,</span><br><span class="line">                r.definingUid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断服务是不是独立进程，获取 ServiceRecord 的 <code>processName</code> 属性，也就是清单中的 <code>android:process</code> 属性；</li><li>如果不是独立进程，通过进程名和 UID 获取对应的 ProcessRecord，检查用来启动这个 Service 的进程是否已存在，如果存在，调用 <code>realStartServiceLocked</code> 启动这个 Service 组件并返回；</li><li>如果是独立进程，尝试从 ServiceRecord 的 <code>isolatedProc</code> 获取当前服务的 ProcessRecord；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="literal">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="literal">true</span>, intentFlags,</span><br><span class="line">                hostingRecord, <span class="literal">false</span>, isolated, <span class="literal">false</span>)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ...;</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        mAm.tempWhitelistUidLocked(r.appInfo.uid,</span><br><span class="line">                SERVICE_START_FOREGROUND_TIMEOUT, <span class="string">&quot;fg-service-launch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we&#x27;ve already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果用来启动服务的进程没有启动，调用 <code>AMS.startProcessLocked</code> 来启动该进程，如果启动失败则销毁服务，如果是独立进程的服务，将启动的 ProcessRecord 保存到 ServiceRecord 的 <code>isolatedProc</code> 成员；</li><li>如果是前台服务，加入进程到 tempWhitelist；</li><li>加入 ServiceRecord 到 <code>mPendingServices</code> 列表；</li><li>如果是延迟停止的服务，这里直接停止？TODO</li></ol><p>总结下来，这个方法最主要做了三件事：</p><ol><li>如果 Service 已经启动过，执行 <code>Service.onStartCommand</code> 方法；</li><li>如果此 Service 未启动，但所属进程已启动，则调用 <code>realStartServiceLocked</code> 进入真正启动 Service 的流程；</li><li>如果 Service 所属进程尚未启动，则先启动进程，如 app 进程启动失败则销毁此 Service ；如启动成功，则加入 <code>mPendingServices</code> 列表，待 App 进程启动结束后再启动 Service。此过程参见 <a href="#attachapplicationlocked"><code>attachApplicationLocked</code></a>。</li></ol><h3 id="realstartservicelocked"><a class="markdownIt-Anchor" href="#realstartservicelocked"></a> <code>realStartServiceLocked</code></h3><p>如果 Service 所属进程已存在，启动 Service 组件。这个方法在 <code>bindService</code> 时也可能调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span><br><span class="line"><span class="params">        ProcessRecord app, <span class="type">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    r.setProcess(app);</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newService</span> <span class="operator">=</span> app.services.add(r);</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>);</span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="literal">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.getReportedProcState());</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cleanup.</span></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.setProcess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Retry.</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>向 ProcessRecord 添加这条 ServiceRecord；</li><li>调整 LruProcess 列表，调整进程 OomAdj，更新 ProcessRecord 中的进程状态；</li><li>调用 <code>ActivityThread.ApplicationThread.scheduleCreateService</code> 在目标线程初始化服务实例；</li><li>调用 <code>ServiceReocord.postNotification()</code>，如果是前台服务，发布通知；</li><li>如果服务拉起失败，做好清理，按情况尝试重启服务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">    app.whitelistManager = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">updateServiceClientActivitiesLocked(app, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newService &amp;&amp; created) &#123;</span><br><span class="line">    app.addBoundClientUidsOfNewService(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the service is in the started state, and there are no</span></span><br><span class="line"><span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></span><br><span class="line"><span class="comment">// be called.</span></span><br><span class="line"><span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> <span class="title class_">ServiceRecord</span>.StartItem(r, <span class="literal">false</span>, r.makeNextStartId(),</span><br><span class="line">            <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendServiceArgsLocked(r, execInFg, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ol start="7"><li>调用 <code>requestServiceBindingsLocked</code>，准备调用 <code>onBind</code> 方法；</li><li>调用 <code>sendServiceArgsLocked</code>，准备调用 <code>onStartCommand</code> 方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we&#x27;ve already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台启动限制：<br />9. 如果之前设置了延迟启动，取消设置；<br />10. 如果之前设置延迟停止，调用 <code>stopServiceLocked</code> 停止。</p><h3 id="activitythreadhandlecreateservice"><a class="markdownIt-Anchor" href="#activitythreadhandlecreateservice"></a> <code>ActivityThread.handleCreateService</code></h3><p>正如 ApplicationThread 的其他 schedule 方法，<code>scheduleCreateService</code> 将收到的传入参数打包到 <code>CreateServiceData</code> 对象，向 ActivityThread 的 Handler 发送 <code>CREATE_SERVICE</code> 消息，Handler 收到消息后调用 <code>handleCreateService</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCreateService</span><span class="params">(CreateServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> packageInfo.getClassLoader();</span><br><span class="line">        service = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="built_in">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过反射实例化了需要的 Service 对象；</li><li>创建用于 Service 的 ContextImpl 对象，获取 Application 对象，调用 <code>Service.attach</code> 方法进行绑定；</li><li>调用 <code>Service.onCreate()</code> 方法；</li><li>记录服务到 <code>mServices</code> 成员；</li><li>最后调用 <code>AMS.serviceDoneExecuting</code> 方法。</li></ol><h3 id="sendserviceargslocked"><a class="markdownIt-Anchor" href="#sendserviceargslocked"></a> <code>sendServiceArgsLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> r.pendingStarts.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ServiceStartArgs&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord.<span class="type">StartItem</span> <span class="variable">si</span> <span class="operator">=</span> r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (si.intent == <span class="literal">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// If somehow we got a dummy null intent in the middle,</span></span><br><span class="line">            <span class="comment">// then skip it.  DO NOT skip a null intent when it is</span></span><br><span class="line">            <span class="comment">// the only one in the list -- this is to support the</span></span><br><span class="line">            <span class="comment">// onStartCommand(null) case.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">            oomAdjusted = <span class="literal">true</span>;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>, OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.fgRequired &amp;&amp; !r.fgWaiting) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!r.isForeground) &#123;</span><br><span class="line">                scheduleServiceForegroundTransitionTimeoutLocked(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.fgRequired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">        &#125;</span><br><span class="line">        args.add(<span class="keyword">new</span> <span class="title class_">ServiceStartArgs</span>(si.taskRemoved, si.id, flags, si.intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParceledListSlice&lt;ServiceStartArgs&gt; slice = <span class="keyword">new</span> <span class="title class_">ParceledListSlice</span>&lt;&gt;(args);</span><br><span class="line">    slice.setInlineCountLimit(<span class="number">4</span>);</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">caughtException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (caughtException != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Keep nesting count correct</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (caughtException <span class="keyword">instanceof</span> TransactionTooLargeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (TransactionTooLargeException)caughtException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历 ServiceRecord 的 <code>pendingStarts</code> 列表，取出其中需要使用的 StartItem：<ol><li>调用 <code>bumpServiceExecutingLocked</code> 标记开始启动服务过程；</li><li>将其中的 Intent 保存到 <code>args</code> 列表，最后保存到 <code>slice</code> 中，</li></ol></li><li>将 ServiceRecord 与之前生成的 <code>slice</code> 传入 <code>ApplicationThread.scheduleServiceArgs</code> 方法；</li><li>如果上一步捕获到异常，对 <code>args</code> 列表中的每个对象，调用 <code>serviceDoneExecutingLocked</code> 方法，保持计数正确（？TODO）</li></ol><p><code>ApplicationThread.scheduleServiceArgs</code> 遍历传入的 <code>args</code> 列表，向 ActivityThread 的 Handler 发送 <code>SERVICE_ARGS</code> 消息以及从 ServiceStartArgs 构建的 ServiceArgsData。Handler 接到消息后会调用 <code>handleServiceArgs</code> 方法处理。</p><h3 id="activitythreadhandleserviceargs"><a class="markdownIt-Anchor" href="#activitythreadhandleserviceargs"></a> <code>ActivityThread.handleServiceArgs</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.args != <span class="literal">null</span>) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据 <code>data.token</code>，也就是 ServiceRecord 对象从 <code>mServices</code> 获取对应的 Service 对象，这里的 Service 对象是在 <code>handleCreateService</code> 方法中创建并存入的；</li><li>如果没有设定 <code>taskRemoved</code> 标志，就执行 <code>Service.onStartCommand</code> 方法，否则执行 <code>Service.onTaskRemoved</code> 方法；</li><li>等待 QueuedWork 队列完成，调用 <code>AMS.serviceDoneExecuting</code>，这个方法调用 <code>ActiveServices.serviceDoneExecutingLocked</code> 方法。</li></ol><h3 id="bumpserviceexecutinglocked"><a class="markdownIt-Anchor" href="#bumpserviceexecutinglocked"></a> <code>bumpServiceExecutingLocked</code></h3><p>处理服务启动超时，调用 <code>scheduleServiceTimeoutLocked</code>。TODO</p><h3 id="servicedoneexecutinglocked"><a class="markdownIt-Anchor" href="#servicedoneexecutinglocked"></a> <code>serviceDoneExecutingLocked</code></h3><p>有两个形参列表不同的重载方法：</p><ol><li><code>(ServiceRecord, int, int, int)</code>: 根据情况设置 ServiceRecord 和 StartItem 的一些信息；</li><li><code>(ServiceRecord, boolean, boolean)</code>: 负责在停止服务后清除剩余的记录。</li></ol><p>TODO</p><h2 id="service-绑定流程"><a class="markdownIt-Anchor" href="#service-绑定流程"></a> Service 绑定流程</h2><p><img src="/images/2020-02-24-Service-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/bindService.svg" alt="Service 绑定流程" /></p><p>应用组件绑定服务从 <code>bindService</code> 方法开始，这个方法调用 <code>bindServiceCommon</code> 。</p><h3 id="bindservicecommon"><a class="markdownIt-Anchor" href="#bindservicecommon"></a> <code>bindServiceCommon</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="literal">null</span> &amp;&amp; executor != <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> getActivityToken();</span><br><span class="line">        ...</span><br><span class="line">        service.prepareToLeaveProcess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 <code>LoadedApk.getServiceDispatcher</code> 获取实现了 IServiceConnection 接口的 Binder 对象，也就是 <code>ServiceDispatcher.InnerConnection</code>，这个方法进一步调用 <code>getServiceDispatcherCommon</code>；</li><li>调用 AMS 的 <code>bindIsolatedService</code> 方法，这个方法进一步调用 <code>ActiveServices.bindServiceLocked</code> 方法。</li></ol><h3 id="loadedapkgetservicedispatcher"><a class="markdownIt-Anchor" href="#loadedapkgetservicedispatcher"></a> <code>LoadedApk.getServiceDispatcher</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IServiceConnection <span class="title function_">getServiceDispatcherCommon</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, Executor executor, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, executor, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Service 组件与 Activity 组件的绑定在 LoadedApk 类的 <code>mService</code> 都对应一个 ServiceDispatcher 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol><li>如果找到已有的 ServiceDispatcher，就返回其 InnerConnection；</li><li>如果没有，就新建一个，保存到 <code>mService</code> 中，返回其 InnerConnection；</li></ol><h3 id="bindservicelocked"><a class="markdownIt-Anchor" href="#bindservicelocked"></a> <code>bindServiceLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (callerApp == <span class="literal">null</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(...);&#125;</span><br><span class="line"></span><br><span class="line">    ActivityServiceConnectionsHolder&lt;ConnectionRecord&gt; activity = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">        activity = mAm.mAtmInternal.getServiceConnectionsHolder(token);</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 权限检查</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">callerFg</span> <span class="operator">=</span> callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isBindExternal</span> <span class="operator">=</span> (flags &amp; Context.BIND_EXTERNAL_SERVICE) != <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">        retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="literal">true</span>,</span><br><span class="line">                callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> res.record;</span><br></pre></td></tr></table></figure><ol><li>获取调用者对应的 ProcessRecord 和 ActivityServiceConnectionsHolder&lt;ConnectionRecord&gt;；</li><li>检查调用者是否在前台（<code>callerFg</code>），是否绑定了外部服务（<code>isBindExternal</code>）；</li><li>获取对应的 ServiceLookupResult，取出其中的 ServiceRecord；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">... <span class="comment">// 如有必要，显示申请权限对话框</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">    <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionRecord</span>(b, activity,</span><br><span class="line">            connection, flags, clientLabel, clientIntent,</span><br><span class="line">            callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line"></span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">    s.addConnection(binder, c);</span><br><span class="line">    b.connections.add(c);</span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">        activity.addConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">    b.client.connections.add(c);</span><br><span class="line">    c.startAssociationIfNeeded();</span><br><span class="line">    ...</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist == <span class="literal">null</span>) &#123;</span><br><span class="line">        clist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        mServiceConnections.put(binder, clist);</span><br><span class="line">    &#125;</span><br><span class="line">    clist.add(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="literal">false</span>,</span><br><span class="line">                permissionsReviewRequired) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取或初始化相关变量：<ol><li>调用 <code>ServiceRecord.retrieveAppBindingLocked</code> 方法获取 AppBindRecord；</li><li>新建 ConnectionRecord 存入连接相关信息；</li><li>从 IServiceConnection 获取对应的 IBinder 对象；</li></ol></li><li>记录连接：<ol><li>在 ServiceRecord 记录；</li><li>在 AppBindRecord 以及对应客户端的 ProcessRecord 中记录；</li><li>在 <code>mServiceConnections</code> 列表中记录；</li></ol></li><li>如果调用 <code>bindService</code> 方法时设置了 <code>BIND_AUTO_CREATE</code> 标志，表示如果绑定服务尚未运行，则进行创建，调用 <code>bringUpServiceLocked</code> 启动服务，如果启动失败（返回值不为 <code>null</code>），直接返回结束；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// This could have made the service more important.</span></span><br><span class="line">            mAm.updateLruProcessLocked(s.app,</span><br><span class="line">                    (callerApp.hasActivitiesOrRecentTasks() &amp;&amp; s.app.hasClientActivities())</span><br><span class="line">                            || (callerApp.getCurProcState() &lt;= ActivityManager.PROCESS_STATE_TOP</span><br><span class="line">                                    &amp;&amp; (flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>),</span><br><span class="line">                    b.client);</span><br><span class="line">            mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_BIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">            <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">            <span class="comment">// publish the connection.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.conn.connected(s.name, b.intent.binder, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">            <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">            <span class="comment">// rebound, then do so.</span></span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>更新 LruProcess 和进程 OomAdj；</li><li>如果服务已经在运行，调用 <code>ServiceDispatcher.InnerConnection.connected</code> 方法，最终调用 <code>ServiceDispatcher.doConnected</code> 方法。还记得我们在<code>bindService</code> 的<em>调用方</em>获取或新建了一个 ServiceDispatcher 对象，返回了其实现了 IServiceConnection 接口的成员。因此这个方法实现位于 <code>LoadedApk.ServiceDispatcher.InnerConnection</code>，实际上调用 <code>LoadedApk.ServiceDispatcher.doConnected</code> 方法。这个方法实际上是处理调用者在 ServiceConnection 中实现的回调，在这里是 <code>onServiceConnected</code> 回调；</li><li>否则，调用 <code>requestServiceBindingLocked</code> 方法，最后一个参数 <code>rebind</code> 表明是重新绑定还是首次绑定。</li></ol><h3 id="requestservicebindinglocked"><a class="markdownIt-Anchor" href="#requestservicebindinglocked"></a> <code>requestServiceBindingLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> execInFg, <span class="type">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="literal">null</span> || r.app.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If service is not currently running, can&#x27;t yet bind.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.getReportedProcState());</span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="literal">true</span>;</span><br><span class="line">            i.doRebind = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123; <span class="comment">/* 同上 */</span> <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果服务所在进程还没有运行，直接返回；</li><li>检查是否已经为 IntentBindRecord 对象 <code>i</code> 对应的应用进程请求过 Binder 本地对象，如果还没有则 <code>i.quested = false</code>，参数 <code>rebind</code> 表示是否需要将 Service 组件重新绑定到 <code>IntentBindRecord</code> 对象 <code>i</code>；</li><li>如果满足条件判断，调用 <code>ApplicationThread.scheduleBindService</code> 方法进行绑定，该方法会调用 <code>ActivityThread.handleBindService</code> 方法；</li><li>如果出现异常，销毁服务。</li></ol><h3 id="activitythreadhandlebindservice"><a class="markdownIt-Anchor" href="#activitythreadhandlebindservice"></a> <code>ActivityThread.handleBindService</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;...&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果是首次绑定，调用 <code>onBind</code> 方法，调用 <code>AMS.publishService</code> 发布服务，此方法调用 <code>ActiveServices.publishServiceLocked</code> 方法；</li><li>否则，调用 <code>onRebind</code> 方法，调用 <code>AMS.serviceDoneExecuting</code> 通知操作已完成。</li></ol><h3 id="publishservicelocked"><a class="markdownIt-Anchor" href="#publishservicelocked"></a> <code>publishServiceLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">            Intent.<span class="type">FilterComparison</span> <span class="variable">filter</span></span><br><span class="line">                    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>.FilterComparison(intent);</span><br><span class="line">            <span class="type">IntentBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="literal">true</span>;</span><br><span class="line">                b.received = <span class="literal">true</span>;</span><br><span class="line">                ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">conni</span> <span class="operator">=</span> connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            c.conn.connected(r.name, service, <span class="literal">false</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>设置 IntentBindRecord，将 <code>binder</code> 赋值为 <code>Service.onBind</code> 返回的 Binder 对象，将 <code>requested</code> 设置为 <code>true</code>，表示已调用 <code>onBind</code>；</li><li>遍历 ServiceRecord 中的连接记录，调用其成员 <code>IServiceConnection conn</code> 的 <code>connected</code> 方法。</li><li>调用 <code>ServiceDoneExecutingLocked</code> 方法结束。</li></ol><h3 id="loadedapkservicedispatcherconnected"><a class="markdownIt-Anchor" href="#loadedapkservicedispatcherconnected"></a> <code>LoadedApk.ServiceDispatcher.connected</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunConnection</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, <span class="type">int</span> command, <span class="type">boolean</span> dead) &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) &#123;</span><br><span class="line">            doConnected(mName, mService, mDead);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果 ServiceDispatcher 是用 Executor 初始化，调用 Executor 的 <code>execute</code> 方法执行 <code>RunConnection.run()</code> 方法，这一方法最终执行 <code>doConnected</code> 方法；</li><li>如果是用 ActivityThread 的 Handler 初始化，调用 Handler 的 <code>post</code> 方法执行该方法；</li><li>如果以上两种情况都不是，直接执行 <code>doConnected</code> 方法。</li></ol><h3 id="loadedapkservicedispatcherdoconnected"><a class="markdownIt-Anchor" href="#loadedapkservicedispatcherdoconnected"></a> <code>LoadedApk.ServiceDispatcher.doConnected</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol><li>如果收到连接请求前已经 unbind，就不作处理直接返回；</li><li>从 <code>mActiveConnections</code> 获取组件目前活跃的连接。如果这个组件已经持有当前服务的连接，直接返回；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">        info = <span class="keyword">new</span> <span class="title class_">ConnectionInfo</span>();</span><br><span class="line">        info.binder = service;</span><br><span class="line">        info.deathMonitor = <span class="keyword">new</span> <span class="title class_">DeathMonitor</span>(name, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">            mActiveConnections.put(name, info);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">            <span class="comment">// don&#x27;t do anything with it.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">        mActiveConnections.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">        old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>处理新连接:<ol><li>创建新 ConnectionInfo，存入要连接的服务和死亡回调信息；</li><li>服务调用 <code>linkToDeath</code> 注册死亡回调；</li><li>将新的 ConnectionInfo 存入 <code>mActiveConnections</code>；</li><li>如果发生异常，远程对象已死，则移除之前添加的 ConnectionInfo；</li><li>如果之前持有旧连接，注销旧连接的服务的死亡回调；</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new viable service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>处理 ServiceConnection 回调：<ol><li>如果组件之前绑定其他服务，调用 <code>onServiceDisconnected</code> 回调；</li><li>如果是 <code>bringDownService</code> 方法调用的，<code>dead = true</code>，调用 <code>onBindingDied</code> 回调；</li><li>如果有新服务连接上，调用 <code>onServiceConnected</code> 回调；</li><li>否则，调用 <code>onNullBinding</code> 回调。</li></ol></li></ol><h2 id="service-解绑流程"><a class="markdownIt-Anchor" href="#service-解绑流程"></a> Service 解绑流程</h2><p><img src="/images/2020-02-24-Service-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unbindService.svg" alt="Service 解绑流程" /></p><p>应用组件调用 <code>Context.unbindService</code> 方法解除与 Service 的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unbindService</span><span class="params">(ServiceConnection conn)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">IServiceConnection</span> <span class="variable">sd</span> <span class="operator">=</span> mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                getOuterContext(), conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().unbindService(sd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AMS.unbindService</code> 调用 <code>ActiveServices.unbindServiceLocked</code> 方法。</p><h3 id="activeservicesunbindservicelocked"><a class="markdownIt-Anchor" href="#activeservicesunbindservicelocked"></a> <code>ActiveServices.unbindServiceLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> &#123;</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ConnectionRecord</span> <span class="variable">r</span> <span class="operator">=</span> clist.get(<span class="number">0</span>);</span><br><span class="line">            removeConnectionLocked(r, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">                clist.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ... <span class="comment">// 调整 LruProcess</span></span><br><span class="line">        &#125;</span><br><span class="line">        mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作是从 <code>mServiceConnections</code> 中找到对应的连接记录列表，对列表中的每一个连接调用 <code>removeConnectionLocked</code> 方法。</p><h3 id="activeservicesremoveconnectionlocked"><a class="markdownIt-Anchor" href="#activeservicesremoveconnectionlocked"></a> <code>ActiveServices.removeConnectionLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeConnectionLocked</span><span class="params">(ConnectionRecord c, ProcessRecord skipApp,</span></span><br><span class="line"><span class="params">        ActivityServiceConnectionsHolder skipAct)</span> &#123;</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> c.conn.asBinder();</span><br><span class="line">    <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> c.binding;</span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> b.service;</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.getConnections().get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="literal">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            s.removeConnection(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    c.stopAssociation();</span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="literal">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        c.activity.removeConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.client != skipApp) &#123;</span><br><span class="line">        b.client.connections.remove(c);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="literal">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid,</span><br><span class="line">            s.appInfo.longVersionCode, s.instanceName, s.processName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; s.app.thread != <span class="literal">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="literal">false</span>, <span class="string">&quot;unbind&quot;</span>);</span><br><span class="line">                ... <span class="comment">// 调整 LruProcess 和 OomAdj，又来一遍？</span></span><br><span class="line">                b.intent.hasBound = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Assume the client doesn&#x27;t want to know about a rebind;</span></span><br><span class="line">                <span class="comment">// we will deal with that later if it asks for one.</span></span><br><span class="line">                b.intent.doRebind = <span class="literal">false</span>;</span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If unbound while waiting to start, remove the pending service</span></span><br><span class="line">        mPendingServices.remove(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="literal">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>移除连接记录 ConnectionRecord：<ol><li>获取 ServiceRecord 中的连接列表，从该列表中移除；</li><li>从 AppBindRecord 中移除连接记录；</li><li>从 <code>mServiceConnections</code> 中移除连接记录；</li><li>如果 AppBindRecord 中记录为空了，从 <code>b.intent.apps</code> 中移除客户端；</li></ol></li><li>如果服务还存在，调用 <code>ApplicationThread.scheduleUnbindServie</code>，该方法通过 Handler 调用 <code>ActivityThread.handleUnbindService</code> 方法；</li><li>从 <code>mPendingServices</code> 中移除 ServiceRecord；</li><li>调用 <code>bringDownServiceIfNeededLocked</code> 方法，如果服务不再被需要，就关闭服务。</li></ol><h3 id="activitythreadhandleunbindservice"><a class="markdownIt-Anchor" href="#activitythreadhandleunbindservice"></a> <code>ActivityThread.handleUnbindService</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleUnbindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">doRebind</span> <span class="operator">=</span> s.onUnbind(data.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                    ActivityManager.getService().unbindFinished(</span><br><span class="line">                            data.token, data.intent, doRebind);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;...&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 <code>Service.onUnbind</code> 方法，返回值表示是否需要在新的客户端绑定到该服务时调用 <code>onRebind</code> 方法；</li><li>如果需要，调用 <code>AMS.unbindFinished</code> 方法，进一步调用 <code>ActiveServices.unbindFinishedLocked</code> 方法；</li><li>否则，调用 <code>AMS.serviceDoneExecuting</code> 方法；</li></ol><h3 id="activeservicesunbindfinishedlocked"><a class="markdownIt-Anchor" href="#activeservicesunbindfinishedlocked"></a> <code>ActiveServices.unbindFinishedLocked</code></h3><p>这个方法没有用到 <code>doRebind</code> 参数，因为 ActivityThread 只会在 <code>doRebind = true</code> 时调用这个方法，因此这个方法实际上做的事情总是要求服务调用 <code>onRebind</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">unbindFinishedLocked</span><span class="params">(ServiceRecord r, Intent intent, <span class="type">boolean</span> doRebind)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">            Intent.<span class="type">FilterComparison</span> <span class="variable">filter</span></span><br><span class="line">                    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>.FilterComparison(intent);</span><br><span class="line">            <span class="type">IntentBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> r.bindings.get(filter);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b.apps.size() &gt; <span class="number">0</span> &amp;&amp; !inDestroying) &#123;</span><br><span class="line">                    <span class="comment">// Applications have already bound since the last</span></span><br><span class="line">                    <span class="comment">// unbind, so just rebind right here.</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">inFg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=b.apps.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="type">ProcessRecord</span> <span class="variable">client</span> <span class="operator">=</span> b.apps.valueAt(i).client;</span><br><span class="line">                        <span class="keyword">if</span> (client != <span class="literal">null</span> &amp;&amp; client.setSchedGroup</span><br><span class="line">                                != ProcessList.SCHED_GROUP_BACKGROUND) &#123;</span><br><span class="line">                            inFg = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        requestServiceBindingLocked(r, b, inFg, <span class="literal">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                        <span class="comment">// Don&#x27;t pass this back to ActivityThread, it&#x27;s unrelated.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Note to tell the service the next time there is</span></span><br><span class="line">                    <span class="comment">// a new client.</span></span><br><span class="line">                    b.doRebind = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 ServiceRecord 中获取相应的 IntentBindRecord，获取绑定和应用的当前状态；</li><li>如果应用在上次解绑之后已经重新绑定，就直接调用 <code>requestServiceBindingLocked</code> 方法，最后一个参数 <code>rebind = true</code>；</li><li>否则，令 IntentBindRecord 的 <code>doRebind = true</code>，以通知服务有新的客户端时调用 <code>onRebind</code> 方法；</li></ol><h3 id="amsstopassociationlocked"><a class="markdownIt-Anchor" href="#amsstopassociationlocked"></a> <code>AMS.stopAssociationLocked</code></h3><p>TODO</p><h2 id="service-停止流程"><a class="markdownIt-Anchor" href="#service-停止流程"></a> Service 停止流程</h2><h3 id="服务停止的方式"><a class="markdownIt-Anchor" href="#服务停止的方式"></a> 服务停止的方式</h3><p>应用组件可以通过两种方式停止服务：</p><ol><li><code>stopService</code></li><li><code>unbindService</code></li></ol><p>此外，服务自身可以调用 <code>stopSelf</code> 停止自身。</p><p>这三种方式最终都会调用 <code>bringDownServiceIfNeededLocked</code> 方法。然而这种方法并不保证停止服务：服务启动完成，并且没有自动创建服务的连接（见 <a href="#servicerecordhasautocreateconnection"><code>hasAutoCreateConnection</code></a>）时，才会调用 <code>bringDownServiceLocked</code> 真正停止服务。</p><h4 id="调用-stopservice-停止服务"><a class="markdownIt-Anchor" href="#调用-stopservice-停止服务"></a> 调用 <code>stopService</code> 停止服务</h4><p><code>stopService -&gt; ContextImpl.stopServiceCommon -&gt; AMS.stopService -&gt; ActiveServices.stopServiceLocked(IApplicationThread, Intent, String, int) -&gt; stopServiceLocked(ServiceRecord) -&gt; bringDownServiceIfNeededLocked</code></p><p><img src="/images/2020-02-24-Service-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/stopService.svg" alt="Service 停止流程" /></p><h4 id="调用-unbindservice-解绑最后一个客户端"><a class="markdownIt-Anchor" href="#调用-unbindservice-解绑最后一个客户端"></a> 调用 <code>unbindService</code> 解绑最后一个客户端</h4><p><code>unbindService -&gt; unbindServiceLocked -&gt; bringDownServiceIfNeededLocked</code></p><h4 id="服务调用-stopself-停止"><a class="markdownIt-Anchor" href="#服务调用-stopself-停止"></a> 服务调用 <code>stopSelf</code> 停止</h4><p><code>stopSelf -&gt; AMS.stopServiceToken -&gt; ActiveServices.stopServiceTokenLocked -&gt; bringDownServiceIfNeededLocked</code></p><h3 id="bringdownserviceifneededlocked"><a class="markdownIt-Anchor" href="#bringdownserviceifneededlocked"></a> <code>bringDownServiceIfNeededLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> knowConn,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasConn)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isserviceneededlocked"><a class="markdownIt-Anchor" href="#isserviceneededlocked"></a> <code>isServiceNeededLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isServiceNeededLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> knowConn,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasConn)</span> &#123;</span><br><span class="line">    <span class="comment">// Are we still explicitly being asked to run?</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is someone still bound to us keeping us running?</span></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>stopServiceLocked(ServiceRecord)</code> 方法时会将 <code>startRequested</code> 标志设为 <code>false</code>，因此<strong>调用 <code>stopService</code> 时</strong>实际检查的只有是否还有活跃的绑定。</p><h3 id="servicerecordhasautocreateconnection"><a class="markdownIt-Anchor" href="#servicerecordhasautocreateconnection"></a> <code>ServiceRecord.hasAutoCreateConnection</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAutoCreateConnections</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// XXX should probably keep a count of the number of auto-create</span></span><br><span class="line">    <span class="comment">// connections directly in the service.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> conni=connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; cr = connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cr.get(i).flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历保存的连接列表，当有在 <code>bindService</code> 时设置了 <code>BIND_AUTO_CREATE</code> 标志的活跃连接，就返回 <code>true</code>。因此只有所有设置了 <code>BIND_AUTO_CREATE</code> 标志的客户端调用了 <code>unbindService</code> 时，服务才会停止。</p><h3 id="bringdownservicelocked"><a class="markdownIt-Anchor" href="#bringdownservicelocked"></a> <code>bringDownServiceLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> &#123;</span><br><span class="line">    ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">conni</span> <span class="operator">=</span> connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c = connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c.size(); i++) &#123;</span><br><span class="line">            <span class="type">ConnectionRecord</span> <span class="variable">cr</span> <span class="operator">=</span> c.get(i);</span><br><span class="line">            <span class="comment">// There is still a connection to the service that is</span></span><br><span class="line">            <span class="comment">// being brought down.  Mark it as dead.</span></span><br><span class="line">            cr.serviceDead = <span class="literal">true</span>;</span><br><span class="line">            cr.stopAssociation();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cr.conn.connected(r.name, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>对所有活跃绑定，调用 <code>ServiceDispatcher.InnerDispatcher.connected</code> 以发送 <code>onBindingDied</code> 回调；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tell the service that it has been unbound.</span></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needOomAdj</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.bindings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">IntentBindRecord</span> <span class="variable">ibr</span> <span class="operator">=</span> r.bindings.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="literal">false</span>, <span class="string">&quot;bring down unbind&quot;</span>);</span><br><span class="line">                needOomAdj = <span class="literal">true</span>;</span><br><span class="line">                ibr.hasBound = <span class="literal">false</span>;</span><br><span class="line">                ibr.requested = <span class="literal">false</span>;</span><br><span class="line">                r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                        ibr.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123; serviceProcessGoneLocked(r); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needOomAdj) &#123;</span><br><span class="line">        mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>,</span><br><span class="line">                OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>如果有活跃绑定，更新 IntentBindRecord 状态，调用 <code>ApplicationThread.scheduleUnbindService</code> 安排解绑，调整 OomAdj；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check to see if the service had been started as foreground, but being</span></span><br><span class="line"><span class="comment">// brought down before actually showing a notification.  That is not allowed.</span></span><br><span class="line"><span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">    r.fgRequired = <span class="literal">false</span>;</span><br><span class="line">    r.fgWaiting = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    mAm.mAppOpsService.finishOperation(AppOpsManager.getToken(mAm.mAppOpsService),</span><br><span class="line">            AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName);</span><br><span class="line">    mAm.mHandler.removeMessages(</span><br><span class="line">            ActivityManagerService.SERVICE_FOREGROUND_TIMEOUT_MSG, r);</span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">                ActivityManagerService.SERVICE_FOREGROUND_CRASH_MSG);</span><br><span class="line">        msg.obj = r.app;</span><br><span class="line">        msg.getData().putCharSequence(</span><br><span class="line">            ActivityManagerService.SERVICE_RECORD_KEY, r.toString());</span><br><span class="line">        mAm.mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ServiceMap</span> <span class="variable">smap</span> <span class="operator">=</span> getServiceMapLocked(r.userId);</span><br><span class="line"><span class="type">ServiceRecord</span> <span class="variable">found</span> <span class="operator">=</span> smap.mServicesByInstanceName.remove(r.instanceName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note when this method is called by bringUpServiceLocked(), the service is not found</span></span><br><span class="line"><span class="comment">// in mServicesByInstanceName and found will be null.</span></span><br><span class="line"><span class="keyword">if</span> (found != <span class="literal">null</span> &amp;&amp; found != r) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(...); &#125;</span><br><span class="line">smap.mServicesByIntent.remove(r.intent);</span><br><span class="line">r.totalRestartCount = <span class="number">0</span>;</span><br><span class="line">unscheduleServiceRestartLocked(r, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also make sure it is not on the pending list.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.get(i) == r) &#123;</span><br><span class="line">        mPendingServices.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelForegroundNotificationLocked(r);</span><br><span class="line"><span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">    decActiveForegroundAppLocked(smap, r);</span><br><span class="line">    ...</span><br><span class="line">    mAm.mAppOpsService.finishOperation(</span><br><span class="line">            AppOpsManager.getToken(mAm.mAppOpsService),</span><br><span class="line">            AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName);</span><br><span class="line">    mAm.updateForegroundServiceUsageStats(r.name, r.userId, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.isForeground = <span class="literal">false</span>;</span><br><span class="line">r.foregroundId = <span class="number">0</span>;</span><br><span class="line">r.foregroundNoti = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear start entries.</span></span><br><span class="line">r.clearDeliveredStartsLocked();</span><br><span class="line">r.pendingStarts.clear();</span><br><span class="line">smap.mDelayedStartList.remove(r);</span><br></pre></td></tr></table></figure><ol start="3"><li>从 ServiceMap 中移除服务记录；</li><li>调用 <code>unscheduleServiceRestartLocked</code> 取消重启服务的安排；</li><li>从 <code>mPendingServices</code> 中移除记录；</li><li>如果是前台服务，取消前台通知；</li><li>清除在 <code>ServiceRecord.pendingStarts</code> 队列中的参数；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r.app.services.remove(r);</span><br><span class="line">        r.app.updateBoundClientUids();</span><br><span class="line">        <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">            updateWhitelistManagerLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="literal">false</span>, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">                mDestroyingServices.add(r);</span><br><span class="line">                r.destroying = <span class="literal">true</span>;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123; serviceProcessGoneLocked(r); &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;...&#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.bindings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.bindings.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>移除 ProcessRecord 中的记录；</li><li>加入 <code>mDestroyingServices</code> 列表；</li><li>调用 <code>ApplicationThread.scheduleStopService</code> 停止服务，跟之前类似，这个方法调用 <code>ActivityThread.handleStopService</code> 方法；</li></ol><h3 id="activitythreadhandlestopservice"><a class="markdownIt-Anchor" href="#activitythreadhandlestopservice"></a> <code>ActivityThread.handleStopService</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleStopService</span><span class="params">(IBinder token)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.remove(token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.onDestroy();</span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> s.getBaseContext();</span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">who</span> <span class="operator">=</span> s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        token, SERVICE_DONE_EXECUTING_STOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>移除服务在 <code>mServices</code> 中的引用；</li><li>调用 <code>Service.onDestroy</code> 回调；</li><li>调用 <code>Service.detachAndCleanUp</code> ，令 <code>mToken = null</code> 以移除其引用；</li><li>调用 <code>ContextImpl.scheduleFinalCleanup</code>，最终调用 <code>LoadedApk.removeContextRegistration</code>，清除其对应 Context 注册的 BroadcastReceiver。</li><li>调用 <code>AMS.serviceDoneExecuting</code> 回调，清除剩余的服务记录。</li></ol><h2 id="service-被杀重新启动的流程"><a class="markdownIt-Anchor" href="#service-被杀重新启动的流程"></a> Service 被杀重新启动的流程</h2><p><img src="/images/2020-02-24-Service-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/restartService.svg" alt="Service 重启流程" /></p><h3 id="应用被杀的回调"><a class="markdownIt-Anchor" href="#应用被杀的回调"></a> 应用被杀的回调</h3><p>在 ContentProvider 源码分析中提到过，在 <code>AMS.attachApplicationLocked</code> 方法中，添加了 ActivityThread 对象的死亡回调，调用了 <code>appDiedLocked</code> 方法，这样 AMS 就可以在进程死亡时完成善后工作。</p><p>对于 Service 被杀后重新启动这一过程，相关的调用过程为：<br /><code>appDiedLocked -&gt; handleAppDiedLocked -&gt; cleanUpApplicationRecordLocked -&gt; ActiveServices.killServicesLocked</code></p><h4 id="killserviceslocked"><a class="markdownIt-Anchor" href="#killserviceslocked"></a> <code>killServicesLocked</code></h4><ol><li>遍历 ProcessRecord 中的 <code>services</code> 列表，判断其中的服务是否需要重启，如果需要则调用 <code>scheduleServiceRestartLocked</code> 安排启动服务，否则调用 <code>bringDownServiceLocked</code> 将其清理干净；</li><li>如果设置传入形参 <code>allowRestart = false</code>，从 ProcessRecord，<code>mRestartingServices</code>，<code>mPendingServices</code> 中清除相应记录；</li><li>从 <code>mDestroyingServices</code> 清除这个进程待销毁的服务记录；</li></ol><h3 id="ams-发起重启服务"><a class="markdownIt-Anchor" href="#ams-发起重启服务"></a> AMS 发起重启服务</h3><h4 id="scheduleservicerestartlocked"><a class="markdownIt-Anchor" href="#scheduleservicerestartlocked"></a> <code>scheduleServiceRestartLocked</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">scheduleServiceRestartLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> allowCancel)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAm.mAtmInternal.isShuttingDown()) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServiceMap</span> <span class="variable">smap</span> <span class="operator">=</span> getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="keyword">if</span> (smap.mServicesByInstanceName.get(r.instanceName) != r) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r.serviceInfo.applicationInfo.flags</span><br><span class="line">            &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Any delivered but not yet finished starts should be put back</span></span><br><span class="line">        <span class="comment">// on the pending list.</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        ...... <span class="comment">// 设置 ServiceRecord 与重启服务相关变量，为服务启动加上延迟，防止大量服务同时启动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that we don&#x27;t end up restarting a bunch of services</span></span><br><span class="line">        <span class="comment">// all at the same time.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Persistent processes are immediately restarted, so there is no</span></span><br><span class="line">        <span class="comment">// reason to hold of on restarting their services.</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        r.createdFromFg = <span class="literal">false</span>;</span><br><span class="line">        mRestartingServices.add(r);</span><br><span class="line">        r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cancelForegroundNotificationLocked(r);</span><br><span class="line"></span><br><span class="line">    mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line">    mAm.mHandler.postAtTime(r.restarter, r.nextRestartTime);</span><br><span class="line">    r.nextRestartTime = SystemClock.uptimeMillis() + r.restartDelay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>排除系统关机和服务已存在的情形；</li><li>将已送达但未完成的 StartItem 放回 <code>mPendingStarts</code> 列表；</li><li>为服务启动加上延迟，防止扎堆启动；</li><li>将记录加入 <code>mRestartingServices</code> 列表；</li><li>将 ServiceRecord 的 <code>restarter</code> 成员 <code>post</code> 到 AMS 的 Handler，这是个实现了 Runnable 接口的 ServiceRestarter 对象，调用 <code>performServiceRestartLocked</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ServiceRestarter</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceRecord mService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setService</span><span class="params">(ServiceRecord service)</span> &#123;</span><br><span class="line">        mService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">            performServiceRestartLocked(mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performServiceRestartLocked</code> 方法调用 <code>bringUpServiceLocked</code> 启动服务。</p><h3 id="应用重新启动时带起服务"><a class="markdownIt-Anchor" href="#应用重新启动时带起服务"></a> 应用（重新）启动时带起服务</h3><h4 id="attachapplicationlocked"><a class="markdownIt-Anchor" href="#attachapplicationlocked"></a> <code>attachApplicationLocked</code></h4><p>应用启动后，<code>AMS.attachApplicationLocked</code> 调用 <code>ActiveServices.attachApplicationLocked</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ServiceRecord</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line">                didSomething = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeededLocked(sr, <span class="literal">false</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// We were waiting for this service to start, but it is actually no</span></span><br><span class="line">                    <span class="comment">// longer needed.  This could happen because bringDownServiceIfNeeded</span></span><br><span class="line">                    <span class="comment">// won&#x27;t bring down a service that is pending...  so now the pending</span></span><br><span class="line">                    <span class="comment">// is done, so let&#x27;s drop it.</span></span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123; <span class="keyword">throw</span> e; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>遍历 <code>mPendingServices</code> 列表，找到进程名与当前启动进程名相同的 ServiceRecord，调用 <code>realStartServiceLocked</code> 启动该服务。如果判断当前启动服务不再需要，调用 <code>bringDownServiceLocked</code> 关闭之。</p><p>Q: <code>mPendingServices</code> 采用 ArrayList 存储是否影响查找效率？</p><p>Q: 为什么不前置判断，直接不启动不需要的服务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Also, if there are any services that are waiting to restart and</span></span><br><span class="line">    <span class="comment">// would run in this process, now is a good time to start them.  It would</span></span><br><span class="line">    <span class="comment">// be weird to bring up the process but arbitrarily not let the services</span></span><br><span class="line">    <span class="comment">// run at this point just because their restart time hasn&#x27;t come up.</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line">            sr = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 <code>mRestartingServices</code> 列表，移除 AMS 的 Handler 中延时重启服务的消息，再重新添加立即启动服务的消息。</p><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>后台启动限制的梳理</li><li>数据结构的梳理</li><li>流程图</li></ol><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1><ol><li>服务概览 | Android 开发者, <a href="https://developer.android.com/guide/components/services?hl=zh-cn">https://developer.android.com/guide/components/services?hl=zh-cn</a></li><li>Android系统源码分析–Service启动流程, <a href="http://codemx.cn/2018/04/24/AndroidOS010-Service/">http://codemx.cn/2018/04/24/AndroidOS010-Service/</a></li></ol><h1 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ConnectionRecord.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ProcessRecord.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/core/java/android/app/LoadedApk.java</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentProvider 源码分析</title>
      <link href="/posts/3663140717/"/>
      <url>/posts/3663140717/</url>
      
        <content type="html"><![CDATA[<h1 id="contentprovider-简介"><a class="markdownIt-Anchor" href="#contentprovider-简介"></a> ContentProvider 简介</h1><p>内容提供程序(Content Provider)是 Android 应用程序四大组件之一，它提供了对应用使用的底层数据的抽象，使其他应用可以通过 ContentResolver 接口访问其数据，而无需了解数据的具体存储方式。</p><h2 id="使用-contentprovider"><a class="markdownIt-Anchor" href="#使用-contentprovider"></a> 使用 ContentProvider</h2><h3 id="实现-contentprovider-类"><a class="markdownIt-Anchor" href="#实现-contentprovider-类"></a> 实现 ContentProvider 类</h3><p>ContentProvider 是一个抽象类，开发者需要实现其中一些方法才能使用：</p><ul><li><code>onCreate()</code>: 用来初始化内容提供程序提供程序。</li><li><code>query(Uri, String[], Bundle, CancellationSignal)</code>: 返回数据给调用者。</li><li><code>insert(Uri, ContentValues)</code>: 插入新数据。</li><li><code>update(Uri, ContentValues, String, String[])</code>: 更新现有的数据。</li><li><code>delete(Uri, String, String[])</code>: 删除数据。</li><li><code>getType(Uri)</code>: 返回数据的 MIME 类型。</li></ul><p>注意数据访问的方法可能被多个线程同时访问，因此需要做到线程安全。</p><h3 id="配置清单文件"><a class="markdownIt-Anchor" href="#配置清单文件"></a> 配置清单文件</h3><p>仅仅一个自定义类还不够，ContentProvider与activity、service一样，需要在AndroidManifest.xml文件中进行配置。</p><span id="more"></span><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MyContentProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.content.provider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:multiprocess</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>name</code> 为自定义的 ContentProvider 子类名称</li><li><code>authorities</code> 类似 URL 的域名，其他应用使用该值获取访问内容提供程序的 URI，需要保证全局唯一。</li><li><code>exported</code> 为 true 则表示允许其他应用访问应用中的 ContentProvider（跨应用访问），默认为 false。</li><li><code>process</code> 表示 ContentProvider 所在的进程。</li><li><code>multiprocess</code> 为 true 表示每个调用者进程都会创建一个 <code>ContentProvider</code> 实例，默认为 false。</li></ul><p>当 multiprocess、process 这两个参数结合起来会产生以下几种情况。</p><ul><li><code>android:process=&quot;:remote&quot;、android:multiprocess=&quot;true&quot;</code>，ContentProvider 不会随应用的启动而加载，当调用 ContentProvider 的时候才会加载，并且 ContentProvider 是在调用者的进程中初始化。这时候可能定义 ContentProvider 的&quot;:remote&quot;进程还没有启动。</li><li><code>android:process=&quot;:remote&quot;、android:multiprocess=&quot;false&quot;</code>（默认情况） ，ContentProvider 不会随应用的启动而加载，当调用到 ContentProvider 的时候才会加载，并且 ContentProvider 是在“:remote”进程中初始化。</li><li><code>android:multiprocess=&quot;true&quot;</code>，ContentProvider 会随着应用的启动而加载，并且 ContentProvider 是在应用进程的主线程中初始化的。当被调用时会在调用者进程中实例化一个 ContentProvider 对象。</li><li><code>android:multiprocess=&quot;false&quot;</code>（默认情况），ContentProvider 会随着应用的启动而加载，并且 ContentProvider 是在应用主进程的主线程中初始化的。这种 ContentProvider 只有一个实例，运行在自己 App 的进程中。所有调用者共享该 ContentProvider 实例，调用者与 ContentProvider 实例位于两个不同的进程。</li></ul><h3 id="获取-uri"><a class="markdownIt-Anchor" href="#获取-uri"></a> 获取 URI</h3><p>ContentProvider 的使用者需要获取 URI，再使用 ContentResolver 对象进行 CRUD 操作。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri_user</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.example.content.provider&quot;</span>);</span><br><span class="line"><span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line">resolver.insert(uri_user, ...);</span><br><span class="line">resolver.query(uri_user,...);</span><br><span class="line">resolver.update(uri_user,...);</span><br><span class="line">resolver.delete(uri_user,...);</span><br></pre></td></tr></table></figure><p>URI 类似 URL，由四个部分组成：</p><ol><li>URI Scheme，固定为 <code>&quot;content://&quot;</code>；</li><li>Content Provider 组件的 <code>authorities</code> 属性值；</li><li>资源相对路径；</li><li>资源 ID。</li></ol><p>如果这个 ContentProvider 只有一个资源，那么资源相对路径和资源 ID 不是必须的。</p><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><p><img src="/images/2020-02-18-ContentProvider-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Classes.svg" alt="ContentProvider 类图" /></p><p>读者可以参考这张类图，对 ContentProvider 使用到的类和方法建立一个初步印象。</p><h2 id="contentresolver"><a class="markdownIt-Anchor" href="#contentresolver"></a> ContentResolver</h2><h3 id="getcontentresolver"><a class="markdownIt-Anchor" href="#getcontentresolver"></a> <code>getContentResolver</code></h3><p>应用开发者使用 <code>Context.getContentResolver()</code> 方法获取 ContentResolver，其实现在 ContextImpl 类中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ContentResolver <span class="title function_">getContentResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mContentResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>mContentResolver</code> 是 ApplicationContentResolver 类型的私有变量，该类型实现了 ContentResolver，提供了一系列 <code>ActivityThread mainThread</code> 的代理方法。</p><h3 id="contentresolver-交互过程"><a class="markdownIt-Anchor" href="#contentresolver-交互过程"></a> ContentResolver 交互过程</h3><p><img src="/images/2020-02-18-ContentProvider-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/query.svg" alt="ContentResolver 交互过程" /></p><p>下面从 <code>ContentResolver.query</code> 入手，分析 ContentResolver 如何解析并获取对应的 ContentProvider 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Cursor <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> <span class="meta">@RequiresPermission</span>.Read <span class="meta">@NonNull</span> Uri uri,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String[] projection, <span class="meta">@Nullable</span> Bundle queryArgs,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> CancellationSignal cancellationSignal)</span> &#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, <span class="string">&quot;uri&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWrapped != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mWrapped.query(uri, projection, queryArgs, cancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IContentProvider</span> <span class="variable">unstableProvider</span> <span class="operator">=</span> acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IContentProvider</span> <span class="variable">stableProvider</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Cursor</span> <span class="variable">qCursor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">ICancellationSignal</span> <span class="variable">remoteCancellationSignal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="literal">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></span><br><span class="line">            <span class="comment">// reference though, so we might recover!!!  Let&#x27;s try!!!!</span></span><br><span class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qCursor = stableProvider.query(</span><br><span class="line">                    mPackageName, uri, projection, queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qCursor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force query execution.  Might fail and throw a runtime exception here.</span></span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrap the cursor object into CursorWrapperInner object.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IContentProvider</span> <span class="variable">provider</span> <span class="operator">=</span> (stableProvider != <span class="literal">null</span>) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CursorWrapperInner</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CursorWrapperInner</span>(qCursor, provider);</span><br><span class="line">        stableProvider = <span class="literal">null</span>;</span><br><span class="line">        qCursor = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// Arbitrary and not worth documenting, as Activity</span></span><br><span class="line">        <span class="comment">// Manager will kill this process shortly anyway.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ... <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 Preconditions 检查 <code>uri</code> 是否为空，若为空抛出 NullPointerException；</li><li>检查是否设定对象成员<code>ContentInterface mWrapped</code>，若设定则直接使用其 <code>query</code> 方法返回值；</li><li>尝试调用 <code>acquireUnstableProvider(Uri)</code> 方法获取 <code>IContentProvider unstableProvider</code>，如果获取失败则直接返回 null；</li><li>如果传入了 <code>cancellationSignal</code>，处理之；</li><li>调用 <code>unstableProvider.query</code> 方法，获取 <code>qCursor</code>；<ol><li>如果这时远程进程已结束(DeadObjectException)，尝试获取 <code>stableProvider</code>：调用 <code>unstableProviderDied</code> 释放相关引用，再尝试用 <code>acquireProvider</code> 方法获取 <code>stableProvider</code>，最后调用其 <code>query</code> 方法获取 <code>qCursor</code>；</li></ol></li><li>如果之前没有获取 <code>stableProvider</code>，获取之；</li><li>将 <code>stableProvider</code> 与 <code>qCursor</code> 包装到 <code>CursorWrapperInner</code> 对象，返回这个对象；</li><li>最后释放资源。</li></ol><p>unstableProvider 与 stableProvider 在 ActivityThread 和 AMS 都有各自独立的引用计数，区别在于使用 unstableProvider 的客户端进程不会受到 ContentProvider 服务端进程死亡的牵连，而使用 stableProvider，服务端死亡将导致客户端进程也被杀死。</p><p><code>insert, update, delete</code> 方法直接使用 <code>stableProvider</code>。这一设计的目的是保证客户端与服务端的数据一致性。</p><h2 id="获取-contentprovider-过程"><a class="markdownIt-Anchor" href="#获取-contentprovider-过程"></a> 获取 ContentProvider 过程</h2><h3 id="acquireunstableprovider-acquireprovider"><a class="markdownIt-Anchor" href="#acquireunstableprovider-acquireprovider"></a> <code>acquireUnstableProvider</code> &amp; <code>acquireProvider</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title function_">acquireUnstableProvider</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">    ... <span class="comment">// 检查 URI scheme</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireUnstableProvider(Uri)</code> 方法检查 URI sheme，再调用 <code>acquireUnstableProvider(Context, String)</code> 方法。这个方法的实现在之前介绍的 ApplicationContentResolver 中，实际上是代理了 ActivityThread 中的 acquireProvider 方法。</p><p><code>android.app.ContextImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> IContentProvider <span class="title function_">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireProvider(Uri)</code> 方法的情况与 <code>acquireUnstableProvider</code> 的情况相似，唯一要注意的是调用 <code>ActivityThread.acquireProvider</code> 方法时最后一个参数为 <code>true</code> 而非 <code>false</code>。</p><h4 id="activitythreadacquireprovider"><a class="markdownIt-Anchor" href="#activitythreadacquireprovider"></a> <code>ActivityThread.acquireProvider</code></h4><p><code>android.app.ActivityThread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title function_">acquireProvider</span><span class="params">(</span></span><br><span class="line"><span class="params">        Context c, String auth, <span class="type">int</span> userId, <span class="type">boolean</span> stable)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IContentProvider</span> <span class="variable">provider</span> <span class="operator">=</span> acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is a possible race here.  Another thread may try to acquire</span></span><br><span class="line">    <span class="comment">// the same provider at the same time.  When this happens, we want to ensure</span></span><br><span class="line">    <span class="comment">// that the first one wins.</span></span><br><span class="line">    <span class="comment">// Note that we cannot hold the lock while acquiring and installing the</span></span><br><span class="line">    <span class="comment">// provider since it might take a long time to run and it could also potentially</span></span><br><span class="line">    <span class="comment">// be re-entrant in the case where the provider is in the same process.</span></span><br><span class="line">    <span class="type">ContentProviderHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getGetProviderLock(auth, userId)) &#123;</span><br><span class="line">            holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                    getApplicationThread(), c.getOpPackageName(), auth, userId, stable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;...&#125; <span class="comment">// return null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install provider will increment the reference count for us, and break</span></span><br><span class="line">    <span class="comment">// any ties in the race.</span></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>尝试调用 <code>acquireExistingProvider</code> 获取已有的 ContentProvider，如果成功则直接返回；</li><li>获取锁，再调用 AMS 的 <code>getContentProvider</code> 方法获取 ContentProviderHolder 对象；</li><li>使用 <code>installProvider</code> 方法安装内容提供程序；</li><li>返回 ContentProviderHolder 的 <code>provider</code> 成员；</li></ol><h4 id="activitythreadacquireexistingprovider"><a class="markdownIt-Anchor" href="#activitythreadacquireexistingprovider"></a> <code>ActivityThread.acquireExistingProvider</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title function_">acquireExistingProvider</span><span class="params">(</span></span><br><span class="line"><span class="params">        Context c, String auth, <span class="type">int</span> userId, <span class="type">boolean</span> stable)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProviderKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderKey</span>(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProviderClientRecord</span> <span class="variable">pr</span> <span class="operator">=</span> mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">IContentProvider</span> <span class="variable">provider</span> <span class="operator">=</span> pr.mProvider;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">jBinder</span> <span class="operator">=</span> provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;...&#125; <span class="comment">// return null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only increment the ref count if we have one.  If we don&#x27;t then the</span></span><br><span class="line">        <span class="comment">// provider is not reference counted and never needs to be released.</span></span><br><span class="line">        <span class="type">ProviderRefCount</span> <span class="variable">prc</span> <span class="operator">=</span> mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc != <span class="literal">null</span>) &#123;</span><br><span class="line">            incProviderRefLocked(prc, stable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>以 <code>auth</code> 和 <code>userId</code> 为 key，从 <code>ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</code> 中查询已有的记录。</li><li>如果找到记录，获取对应的 Binder 对象，尝试获取并增加引用计数；</li><li>返回 ProviderClientRecord 的 <code>mProvider</code> 成员。</li></ol><p>调用 <code>incProviderPrefLocked</code> 方法增加引用计数时会传入 <code>stable</code> 标志，因为需要 AMS 对 stableProvider 和 unstableProvider 做区别处理，所以需要分别计数。ActivityThread 在增加本地计数时，也会通知 AMS 增加那里的引用计数，以使两边计数保持同步。</p><p>注意不是所有 provider 都需要引用计数，因为有的系统内容提供程序从不需要被释放，也就完全没有引用计数来管理其生命周期。</p><h3 id="activitymanagerservicegetcontentprovider"><a class="markdownIt-Anchor" href="#activitymanagerservicegetcontentprovider"></a> ActivityManagerService.getContentProvider</h3><p>这个方法调用 <code>getContentProviderImpl</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ContentProviderHolder <span class="title function_">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span><br><span class="line"><span class="params">        String name, IBinder token, <span class="type">int</span> callingUid, String callingPackage, String callingTag,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> stable, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    <span class="type">ContentProviderConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ProviderInfo</span> <span class="variable">cpi</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">providerRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">            r = getRecordForAppLocked(caller);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">checkCrossUser</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First check if this content provider has been published...</span></span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">        <span class="comment">// If that didn&#x27;t work, check if it exists for user 0 and then</span></span><br><span class="line">        <span class="comment">// verify that it&#x27;s a singleton provider before using it.</span></span><br><span class="line">        <span class="keyword">if</span> (cpr == <span class="literal">null</span> &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">            <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">                cpi = cpr.info;</span><br><span class="line">                <span class="keyword">if</span> (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                        cpi.name, cpi.flags)</span><br><span class="line">                        &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                    userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                    checkCrossUser = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cpr = <span class="literal">null</span>;</span><br><span class="line">                    cpi = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span> &amp;&amp; cpr.proc != <span class="literal">null</span>) &#123;</span><br><span class="line">            providerRunning = !cpr.proc.killed;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cpr.proc.killed &amp;&amp; cpr.proc.killedByAm) &#123;...&#125; <span class="comment">// 调用 appDiedLocked() 清理进程</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先检查请求的内容提供程序是否已经发布并记录在 <code>ProviderMap mProviderMap</code> 中，注意这里的<code>mProviderMap</code> 是存在于 AMS 中的 ProviderMap 对象，与 ActivityThread 中的 <code>mProviderMap</code> 不是一个东西。如果当前用户中找不到，再从系统用户(UserId = 0)的内容提供程序中寻找合法的单例调用。找到的记录在  <code>ContentProviderRecord cpr</code> 中。</p><p>接下来检查这个记录对应的进程是否还在运行。如果是被 ActivityManager 所杀，就主动清理进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized(this)</span></span><br><span class="line"><span class="keyword">if</span> (providerRunning) &#123;</span><br><span class="line">    cpi = cpr.info;</span><br><span class="line">    String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">        ...... <span class="comment">// 权限检查</span></span><br><span class="line">        <span class="type">ContentProviderHolder</span> <span class="variable">holder</span> <span class="operator">=</span> cpr.newHolder(<span class="literal">null</span>);</span><br><span class="line">        holder.provider = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 权限检查</span></span><br><span class="line">    <span class="comment">// In this case the provider instance already exists, so we can</span></span><br><span class="line">    <span class="comment">// return it right away.</span></span><br><span class="line">    conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag,</span><br><span class="line">            stable);</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span> &amp;&amp; (conn.stableCount+conn.unstableCount) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpr.proc != <span class="literal">null</span> &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_LOW_APP_ADJ) &#123;</span><br><span class="line">            mProcessList.updateLruProcessLocked(cpr.proc, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 调整进程 OOM Adj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果内容提供程序对应进程正在运行，这里分两种情况处理：</p><ol><li>这个 ContentProvider 能在调用者的进程中直接运行，就不建立调用者和当前运行进程的连接，而是使调用者启动自己的 ContentProvider 实例（通过设置 <code>holder.provider = null</code>），向调用者返回 ContentProviderHolder。</li><li>不能在调用者进程运行，需要连接到服务端进程，就获取一个 ContentProviderConnection，同时增加提供程序的引用计数。如果这个连接的总引用计数为 1，需要更新 LruProcess 列表。最后还要调整 OOM Adj。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized(this)</span></span><br><span class="line"><span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cpi = AppGlobals.getPackageManager().</span><br><span class="line">            resolveContentProvider(name,</span><br><span class="line">                STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cpi == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the provider is a singleton AND</span></span><br><span class="line">    <span class="comment">// (it&#x27;s a call within the same user || the provider is a</span></span><br><span class="line">    <span class="comment">// privileged app)</span></span><br><span class="line">    <span class="comment">// Then allow connecting to the singleton provider</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">singleton</span> <span class="operator">=</span> isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">            cpi.name, cpi.flags)</span><br><span class="line">            &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid);</span><br><span class="line">    <span class="keyword">if</span> (singleton) &#123;</span><br><span class="line">        userId = UserHandle.USER_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);</span><br><span class="line"></span><br><span class="line">...... <span class="comment">// 检查权限，处理异常情况</span></span><br></pre></td></tr></table></figure><p>如果对应进程没有在运行，首先利用 authorities 从 PackageManager 获取 ProviderInfo。处理提供者是系统单例提供者的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ComponentName</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(cpi.packageName, cpi.name);</span><br><span class="line">cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">firstClass</span> <span class="operator">=</span> cpr == <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">    ... <span class="comment">// 要求权限确认，return null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ApplicationInfo</span> <span class="variable">ai</span> <span class="operator">=</span></span><br><span class="line">            AppGlobals.getPackageManager().</span><br><span class="line">                getApplicationInfo(</span><br><span class="line">                        cpi.applicationInfo.packageName,</span><br><span class="line">                        STOCK_PM_FLAGS, userId);</span><br><span class="line">        <span class="keyword">if</span> (ai == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ai = getAppInfoForUser(ai, userId);</span><br><span class="line">        cpr = <span class="keyword">new</span> <span class="title class_">ContentProviderRecord</span>(<span class="built_in">this</span>, cpi, ai, comp, singleton);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试调用 <code>mProviderMap.getProviderByClass</code> 方法获取 ContentProviderRecord。如果获取失败，说明这个 ContentProvider 是第一次运行。调用 <code>PackageManager.getApplicationInfo</code> 获取应用信息，创建 ContentProviderRecord。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">    <span class="comment">// If this is a multiprocess provider, then just return its</span></span><br><span class="line">    <span class="comment">// info and allow the caller to instantiate it.  Only do</span></span><br><span class="line">    <span class="comment">// this if the provider is the same user as the caller&#x27;s</span></span><br><span class="line">    <span class="comment">// process, or can run as root (so can be in any process).</span></span><br><span class="line">    <span class="keyword">return</span> cpr.newHolder(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果内容提供程序是多进程的，只需要返回一个新的 ContentProviderHolder，让调用者去初始化其余内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is single process, and our app is now connecting to it.</span></span><br><span class="line"><span class="comment">// See if we are already in the process of launching this</span></span><br><span class="line"><span class="comment">// provider.</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> mLaunchingProviders.size();</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLaunchingProviders.get(i) == cpr) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the provider is not already being launched, then get it</span></span><br><span class="line"><span class="comment">// started.</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= N) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Content provider is now in use, its package can&#x27;t be stopped.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                    cpr.appInfo.packageName, <span class="literal">false</span>, userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use existing process if already started</span></span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> getProcessRecordLocked(</span><br><span class="line">                cpi.processName, cpr.appInfo.uid, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">null</span> &amp;&amp; proc.thread != <span class="literal">null</span> &amp;&amp; !proc.killed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            proc = startProcessLocked(cpi.processName,</span><br><span class="line">                    cpr.appInfo, <span class="literal">false</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;content provider&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ComponentName</span>(cpi.applicationInfo.packageName,</span><br><span class="line">                            cpi.name)), <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (proc == <span class="literal">null</span>) &#123;...&#125; <span class="comment">// return null</span></span><br><span class="line">        &#125;</span><br><span class="line">        cpr.launchingApp = proc;</span><br><span class="line">        mLaunchingProviders.add(cpr);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试启动内容提供程序。</p><p>首先遍历 <code>ArrayList&lt;ContentProviderRecord&gt; mLaunchingProviders</code>，检查之前是否已经安排启动了该内容提供程序。</p><p>如果没有找到，尝试启动之：</p><ol><li>调用 <code>PackageManager.setStoppedState</code> 方法，使应用不能被停止；</li><li>尝试获取应用的 ProcessRecord，如果获取成功，调用其 <code>ActivityThread.scheduleInstallProvider</code> 方法；</li><li>如果获取失败，说明应用进程没有启动，调用 <code>startProcessLocked</code> 方法启动该进程</li><li>设置 <code>cpr</code> 的 <code>launchingApp</code> 变量，将其加入到 <code>mLaunchingProviders</code> 中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Make sure the provider is published (the same provider class</span></span><br><span class="line">    <span class="comment">// may be published under multiple names).</span></span><br><span class="line">    <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">        mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">    conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag,</span><br><span class="line">            stable);</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        conn.waiting = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果是首次启动，向 <code>mProviderMap</code> 添加 ComponentName 记录；</li><li>向 <code>mProviderMap</code> 添加 authorities 的记录；</li><li>尝试获取 ContentProviderConnection，设定其 <code>waiting</code> 标志为 true。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">    <span class="comment">// Wait for the provider to be published...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> SystemClock.uptimeMillis() + CONTENT_PROVIDER_WAIT_TIMEOUT;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cpr.launchingApp == <span class="literal">null</span>) &#123;... <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">wait</span> <span class="operator">=</span> Math.max(<span class="number">0L</span>, timeout - SystemClock.uptimeMillis());</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cpr.wait(wait);</span><br><span class="line">                <span class="keyword">if</span> (cpr.provider == <span class="literal">null</span>) &#123;</span><br><span class="line">                    timedOut = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timedOut) &#123;... <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cpr.newHolder(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待内容提供程序启动完成并发布。当前设置的超时时间 <code>CONTENT_PROVIDER_WAIT_TIMEOUT = 20000</code>，单位毫秒，也就是 20 秒。<code>cpr</code> 将等待 <code>cpr.provider</code> 就绪，直到超时时间已过或 <code>publishContentProviders</code> 方法调用 <code>notify</code> 唤醒线程。如果超时时间已过，就返回 <code>null</code>。</p><p>最后，<code>cpr</code> 以获取的 conn(可能为 null)创建 ContentProviderHolder 返回给调用者。</p><h2 id="与-contentprovider-交互过程"><a class="markdownIt-Anchor" href="#与-contentprovider-交互过程"></a> 与 ContentProvider 交互过程</h2><p><img src="/images/2020-02-18-ContentProvider-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/transact.svg" alt="ContentResolver 交互过程" /></p><p>ContentResolver 与 ContentProvider 实现了相同的接口 ContentInterface，但 IPC 通信时调用的是 IContentProvider 这套接口。</p><p>ContentResolver 通过 <code>acquireProvider</code> 方法获取的 IContentProvider 接口，得到的实际上是 ContentProviderPorxy 对象。我们来看这个代理如何处理 <code>insert</code> 请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method of class ContentProviderProxy</span></span><br><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(String callingPkg, Uri url, ContentValues values)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        data.writeInterfaceToken(IContentProvider.descriptor);</span><br><span class="line"></span><br><span class="line">        data.writeString(callingPkg);</span><br><span class="line">        url.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        values.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mRemote.transact(IContentProvider.INSERT_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        DatabaseUtils.readExceptionFromParcel(reply);</span><br><span class="line">        <span class="type">Uri</span> <span class="variable">out</span> <span class="operator">=</span> Uri.CREATOR.createFromParcel(reply);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        data.recycle();</span><br><span class="line">        reply.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理对象把数据打包发送到服务端对象处理，在这里是 ContentProviderNative。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onTransact method of abstract class ContentProviderNative</span></span><br><span class="line"><span class="keyword">case</span> INSERT_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">    data.enforceInterface(IContentProvider.descriptor);</span><br><span class="line">    <span class="type">String</span> <span class="variable">callingPkg</span> <span class="operator">=</span> data.readString();</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">url</span> <span class="operator">=</span> Uri.CREATOR.createFromParcel(data);</span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> ContentValues.CREATOR.createFromParcel(data);</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">out</span> <span class="operator">=</span> insert(callingPkg, url, values);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    Uri.writeToParcel(reply, out);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到数据后调用 IContentProvider 接口的 <code>insert</code> 方法，其实现位于 Transport 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method of class Transport</span></span><br><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(String callingPkg, Uri uri, ContentValues initialValues)</span> &#123;</span><br><span class="line">    ...... <span class="comment">// 验证 URI 和权限</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maybeAddUserId(mInterface.insert(uri, initialValues), userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123; ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>ContentInterface mInterface</code> 接口的 <code>insert</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method of abstract class ContentProvider</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setTransportLoggingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">        mTransport.mInterface = <span class="keyword">new</span> <span class="title class_">LoggingContentInterface</span>(getClass().getSimpleName(), <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTransport.mInterface = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transport 类作为 ContentProvider 的成员 <code>mTransport</code> 实例化。ContentProvider 在初始化时，会设置其 <code>mInterface</code> 成员为自身(<code>this</code>)。终于，服务端 ContentProvider 中的各种方法可以被客户端所使用。</p><h2 id="contentprovider-初始化过程"><a class="markdownIt-Anchor" href="#contentprovider-初始化过程"></a> ContentProvider 初始化过程</h2><p>应用的内容提供程序初始化有两个入口。</p><ol><li>应用进程已存在时，由 AMS 远程调用 ActivityThread 进行实例化；</li><li>应用进程启动时，进行批量安装；</li></ol><h3 id="ams-发起的-contentprovider-安装"><a class="markdownIt-Anchor" href="#ams-发起的-contentprovider-安装"></a> AMS 发起的 ContentProvider 安装</h3><p><img src="/images/2020-02-18-ContentProvider-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/scheduleInstallProvider.svg" alt="AMS 发起 ContentProvider 安装时序图" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleInstallProvider</span><span class="params">(ProviderInfo provider)</span> &#123;</span><br><span class="line">    sendMessage(H.INSTALL_PROVIDER, provider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMessage</span></span><br><span class="line"><span class="keyword">case</span> INSTALL_PROVIDER:</span><br><span class="line">    handleInstallProvider((ProviderInfo) msg.obj);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>AMS 首先调用 <code>ActivityThread.ApplicationThread.scheduleInstallProvider</code> 这个方法向 ActivityThread 的 Handler 发送消息以安排 provider 的安装。Handler 收到消息后启动 <code>handleInstallProvider</code> 方法。这个方法进一步调用 <code>installContentProviders</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installContentProviders</span><span class="params">(</span></span><br><span class="line"><span class="params">        Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">ContentProviderHolder</span> <span class="variable">cph</span> <span class="operator">=</span> installProvider(context, <span class="literal">null</span>, cpi,</span><br><span class="line">                <span class="literal">false</span> <span class="comment">/*noisy*/</span>, <span class="literal">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="literal">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="literal">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="literal">true</span>;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ActivityManager.getService().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法遍历接收到的 ProviderInfo 列表，对每个 ProviderInfo 调用 <code>installProvider</code> 方法。随后，调用 AMS 的 <code>publishContentProviders</code> 方法，发布成功安装的 ContentProvider。</p><h3 id="应用进程启动时的-contentprovider-安装"><a class="markdownIt-Anchor" href="#应用进程启动时的-contentprovider-安装"></a> 应用进程启动时的 ContentProvider 安装</h3><p><img src="/images/2020-02-18-ContentProvider-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity.svg" alt="进程启动时序图" /></p><p>进程启动完成时，会调用 AMS 的 <code>attachApplication</code> 方法，进一步调用 <code>installContentProviders</code> 方法，将清单声明在进程启动时安装的 ContentProvider 批量安装。</p><h3 id="activitythreadinstallprovider"><a class="markdownIt-Anchor" href="#activitythreadinstallprovider"></a> <code>ActivityThread.installProvider</code></h3><p>这一方法负责安装内容提供程序。根据官方文档，同一进程或来自 system server 的内容提供程序可以永久安装，因此设置 <code>noReleaseNeeded</code> 为 true。其他内容提供程序使用引用计数来管理其生命周期。这个方法还会检测当前内容提供程序是否已经安装。如果已经安装，就增加引用计数，返回已有的内容提供程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ContentProviderHolder <span class="title function_">installProvider</span><span class="params">(Context context,</span></span><br><span class="line"><span class="params">        ContentProviderHolder holder, ProviderInfo info,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> noisy, <span class="type">boolean</span> noReleaseNeeded, <span class="type">boolean</span> stable)</span> &#123;</span><br><span class="line">    <span class="type">ContentProvider</span> <span class="variable">localProvider</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span> || holder.provider == <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">Context</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ApplicationInfo</span> <span class="variable">ai</span> <span class="operator">=</span> info.applicationInfo;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context; <span class="comment">// ContentProvider 在主进程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInitialApplication != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication; <span class="comment">// ContentProvider 在其他进程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// 尝试就地创建请求的 Context 对象</span></span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;...; <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info.splitName != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = c.createContextForSplit(info.splitName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;...&#125; <span class="comment">// throw RuntimeException</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> c.getClassLoader();</span><br><span class="line">            <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> peekPackageInfo(ai.packageName, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// System startup case.</span></span><br><span class="line">                packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">            &#125;</span><br><span class="line">            localProvider = packageInfo.getAppFactory()</span><br><span class="line">                    .instantiateProvider(cl, info.name);</span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="literal">null</span>) &#123;...; <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">            <span class="comment">// XXX Need to create the correct context for this provider.</span></span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;...; <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        provider = holder.provider;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这一节获取 IContentProvider。如果 <code>holder.provider</code> 不为空，则直接使用。否则：</p><ol><li>获取 ContentProvider 所在的 Context 对象；</li><li>创建 ContentProvider 实例，获取对应的 IContentProvider 接口；</li><li>调用 <code>ContentProvider.attachInfo</code> 方法，该方法调用 <code>onCreate</code> 方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">jBinder</span> <span class="operator">=</span> provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ComponentName</span> <span class="variable">cname</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(info.packageName, info.name);</span><br><span class="line">            <span class="type">ProviderClientRecord</span> <span class="variable">pr</span> <span class="operator">=</span> mLocalProvidersByName.get(cname);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                provider = pr.mProvider;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                holder = <span class="keyword">new</span> <span class="title class_">ContentProviderHolder</span>(info);</span><br><span class="line">                holder.provider = provider;</span><br><span class="line">                holder.noReleaseNeeded = <span class="literal">true</span>;</span><br><span class="line">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                mLocalProviders.put(jBinder, pr);</span><br><span class="line">                mLocalProvidersByName.put(cname, pr);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = pr.mHolder;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ProviderRefCount</span> <span class="variable">prc</span> <span class="operator">=</span> mProviderRefCountMap.get(jBinder);</span><br><span class="line">            <span class="keyword">if</span> (prc != <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// We need to transfer our new reference to the existing</span></span><br><span class="line">                <span class="comment">// ref count, releasing the old one...  but only if</span></span><br><span class="line">                <span class="comment">// release is needed (that is, it is not running in the</span></span><br><span class="line">                <span class="comment">// system process).</span></span><br><span class="line">                <span class="keyword">if</span> (!noReleaseNeeded) &#123;</span><br><span class="line">                    incProviderRefLocked(prc, stable);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityManager.getService().removeContentProvider(</span><br><span class="line">                                holder.connection, stable);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ProviderClientRecord</span> <span class="variable">client</span> <span class="operator">=</span> installProviderAuthoritiesLocked(</span><br><span class="line">                        provider, localProvider, holder);</span><br><span class="line">                <span class="keyword">if</span> (noReleaseNeeded) &#123;</span><br><span class="line">                    prc = <span class="keyword">new</span> <span class="title class_">ProviderRefCount</span>(holder, client, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prc = stable</span><br><span class="line">                            ? <span class="keyword">new</span> <span class="title class_">ProviderRefCount</span>(holder, client, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                            : <span class="keyword">new</span> <span class="title class_">ProviderRefCount</span>(holder, client, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = prc.holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一节获取 ContentProviderHolder。</p><p>如果 <code>localProvider != null</code>，说明之前走了 <code>holder.provider == null</code> 的分支，获取了本地的 ContentProvider 实例，那么：</p><ol><li>尝试从 <code>mLocalProvidersByName</code> 查询对应的 ProviderClientRecord，如果找到，则直接返回其 mProvider 成员；</li><li>如果没有找到，创建新的 ContentProviderHolder 对象，存入所需信息，调用<code>installProviderAuthoritiesLocked</code> 注册；</li></ol><p>否则，说明引用了已有的 ContentProvider：</p><ol><li>尝试从 <code>mProviderRefCountMap</code> 查询对应的 ProviderRefCount，如果找到，更新其引用计数；</li><li>如果没有找到，调用 <code>installProviderAuthoritiesLocked</code> 注册，创建新的引用计数，存入  <code>mProviderRefCountMap</code>；</li><li>使用ProviderRefCount 的 <code>holder</code> 成员作为返回的对象。</li></ol><p>最后返回获取的 ContentProviderHolder。</p><h4 id="installproviderauthoritieslocked"><a class="markdownIt-Anchor" href="#installproviderauthoritieslocked"></a> <code>installProviderAuthoritiesLocked</code></h4><p>创建新的 ProviderClientRecord 对象，将其保存到 <code>ProviderMap mProviderMap</code> 中。</p><h3 id="amspublishcontentproviders"><a class="markdownIt-Anchor" href="#amspublishcontentproviders"></a> <code>AMS.publishContentProviders</code></h3><p>这个方法将收到的 ContentProviderHolder 对应的 ContentProviderRecord 保存到 <code>mProviderMap</code> 中，完成其初始化，并调用 <code>notifyAll</code> 唤醒之前在 <code>getContentProviderImpl</code> 方法等待其就绪的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span><br><span class="line"><span class="params">        List&lt;ContentProviderHolder&gt; providers)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (providers == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(...);&#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> providers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">ContentProviderHolder</span> <span class="variable">src</span> <span class="operator">=</span> providers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (src == <span class="literal">null</span> || src.info == <span class="literal">null</span> || src.provider == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ContentProviderRecord</span> <span class="variable">dst</span> <span class="operator">=</span> r.pubProviders.get(src.info.name);</span><br><span class="line">            <span class="keyword">if</span> (dst != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ComponentName</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(dst.info.packageName, dst.info.name);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                String names[] = dst.info.authority.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                    mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>首先获取调用者的 ProcessRecord。</p><p>接下来遍历 ContentProviderHolder 的列表，对于每一个 ContentProviderHolder:</p><ol><li>获取 ProcessRecord 的 <code>pubProviders</code> 成员中对应的 ContentProviderRecord 到 <code>dst</code>；</li><li>保存 <code>dst</code> 到 <code>mProviderMap</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">                <span class="type">int</span> <span class="variable">launchingCount</span> <span class="operator">=</span> mLaunchingProviders.size();</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">wasInLaunchingProviders</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                        mLaunchingProviders.remove(j);</span><br><span class="line">                        wasInLaunchingProviders = <span class="literal">true</span>;</span><br><span class="line">                        j--;</span><br><span class="line">                        launchingCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                    mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">                &#125;</span><br><span class="line">                ... <span class="comment">// 奇怪的 patch</span></span><br><span class="line">                <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                    dst.provider = src.provider;</span><br><span class="line">                    dst.setProcess(r);</span><br><span class="line">                    dst.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                updateOomAdjLocked(r, <span class="literal">true</span>, OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER);</span><br><span class="line">                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                        src.info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>检查 <code>dst</code> 是否在 <code>mLaunchingProviders</code> 中，如果是，就从该列表中去除，并按需从 AMS 的 Handler 中拆除发布内容提供程序超时的“定时炸弹”消息，这个“炸弹”是在 <code>attachApplicationLocked</code> 方法中安装的；</li><li>设置 <code>dst</code> 的 <code>provider</code> 和 <code>proc</code> 属性；</li><li><strong>调用 <code>notifyAll</code> 唤醒之前等待该 ContentProviderRecord 就绪的线程</strong></li><li>调整应用的 OOM Adj。</li></ol><h2 id="contentprovider-服务端被杀牵连客户端的过程"><a class="markdownIt-Anchor" href="#contentprovider-服务端被杀牵连客户端的过程"></a> ContentProvider 服务端被杀牵连客户端的过程</h2><p>在 <code>AMS.attachApplicationLocked</code> 方法中，添加了 ActivityThread 对象的死亡回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">AppDeathRecipient</span> <span class="variable">adr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppDeathRecipient</span>(</span><br><span class="line">            app, pid, thread);</span><br><span class="line">    thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">    app.deathRecipient = adr;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>这个 AppDeathRecipient 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title class_">IBinder</span>.DeathRecipient &#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> mPid;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread mAppThread;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binderDied</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="built_in">this</span>) &#123;</span><br><span class="line">            appDiedLocked(mApp, mPid, mAppThread, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了 <code>appDiedLocked</code> 方法。继续追踪：<br /><code>appDiedLocked -&gt; handleAppDiedLocked -&gt; cleanUpApplicationRecordLocked</code></p><h3 id="cleanupapplicationrecordlocked"><a class="markdownIt-Anchor" href="#cleanupapplicationrecordlocked"></a> <code>cleanUpApplicationRecordLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// Remove published content providers.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> app.pubProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">ContentProviderRecord</span> <span class="variable">cpr</span> <span class="operator">=</span> app.pubProviders.valueAt(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">always</span> <span class="operator">=</span> app.bad || !allowRestart;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inLaunching</span> <span class="operator">=</span> removeDyingProviderLocked(app, cpr, always);</span><br><span class="line">    <span class="keyword">if</span> ((inLaunching || always) &amp;&amp; cpr.hasConnectionOrHandle()) &#123;</span><br><span class="line">        <span class="comment">// We left the provider in the launching list, need to</span></span><br><span class="line">        <span class="comment">// restart it.</span></span><br><span class="line">        restart = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpr.provider = <span class="literal">null</span>;</span><br><span class="line">    cpr.setProcess(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">app.pubProviders.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take care of any launching providers waiting for this process.</span></span><br><span class="line"><span class="keyword">if</span> (cleanupAppInLaunchingProvidersLocked(app, <span class="literal">false</span>)) &#123;</span><br><span class="line">    restart = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unregister from connected content providers.</span></span><br><span class="line"><span class="keyword">if</span> (!app.conProviders.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> app.conProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">ContentProviderConnection</span> <span class="variable">conn</span> <span class="operator">=</span> app.conProviders.get(i);</span><br><span class="line">        conn.provider.connections.remove(conn);</span><br><span class="line">        stopAssociationLocked(app.uid, app.processName, conn.provider.uid,</span><br><span class="line">                conn.provider.appInfo.longVersionCode, conn.provider.name,</span><br><span class="line">                conn.provider.info.processName);</span><br><span class="line">    &#125;</span><br><span class="line">    app.conProviders.clear();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ol><li>首先移除已经发布的 ContentProvider，如有必要杀掉客户端进程；</li><li>清理正在启动且有客户端正在等待的 ContentProvider；</li><li>从关联的 ContentProviderConnection 中注销；</li></ol><h3 id="removedyingproviderlocked"><a class="markdownIt-Anchor" href="#removedyingproviderlocked"></a> <code>removeDyingProviderLocked</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">removeDyingProviderLocked</span><span class="params">(ProcessRecord proc,</span></span><br><span class="line"><span class="params">        ContentProviderRecord cpr, <span class="type">boolean</span> always)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inLaunching</span> <span class="operator">=</span> mLaunchingProviders.contains(cpr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inLaunching || always) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">            cpr.launchingApp = <span class="literal">null</span>;</span><br><span class="line">            cpr.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));</span><br><span class="line">        String names[] = cpr.info.authority.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">            mProviderMap.removeProviderByName(names[j], UserHandle.getUserId(cpr.uid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cpr.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">ContentProviderConnection</span> <span class="variable">conn</span> <span class="operator">=</span> cpr.connections.get(i);</span><br><span class="line">        <span class="keyword">if</span> (conn.waiting) &#123;</span><br><span class="line">            <span class="comment">// If this connection is waiting for the provider, then we don&#x27;t</span></span><br><span class="line">            <span class="comment">// need to mess with its process unless we are always removing</span></span><br><span class="line">            <span class="comment">// or for some reason the provider is not currently launching.</span></span><br><span class="line">            <span class="keyword">if</span> (inLaunching &amp;&amp; !always) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">capp</span> <span class="operator">=</span> conn.client;</span><br><span class="line">        conn.dead = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (conn.stableCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!capp.isPersistent() &amp;&amp; capp.thread != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; capp.pid != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; capp.pid != MY_PID) &#123;</span><br><span class="line">                capp.kill(..., <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capp.thread != <span class="literal">null</span> &amp;&amp; conn.provider.provider != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                capp.thread.unstableProviderDied(conn.provider.provider.asBinder());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In the protocol here, we don&#x27;t expect the client to correctly</span></span><br><span class="line">            <span class="comment">// clean up this connection, we&#x27;ll just remove it.</span></span><br><span class="line">            cpr.connections.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (conn.client.conProviders.remove(conn)) &#123;</span><br><span class="line">                stopAssociationLocked(capp.uid, capp.processName, cpr.uid,</span><br><span class="line">                        cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inLaunching &amp;&amp; always) &#123;</span><br><span class="line">        mLaunchingProviders.remove(cpr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inLaunching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果这个内容提供程序当前正在运行，调用 <code>notifyAll</code> （TODO)，从 mProviderMap 移除记录；</li><li>遍历所有 ContentProviderConnection：<ol><li>如果当前连接正在等待提供程序就绪，并且不是必须要移除连接的情况，就跳过处理该连接；</li><li>否则，获取当前连接的客户端程序 ProcessRecord，如果其 <code>stableCount &gt; 0</code>，不是常驻进程，且正在运行，就调用 <code>ProcessRecord.kill</code> 方法杀掉该进程；</li><li>否则（没有 stableConnection），调用 <code>ApplicationThread.unstableProviderDied</code> 方法，再从 ContentProviderRecord 中移除该连接；</li></ol></li><li>按需移除 <code>mLaunchingProviders</code> 中相应记录，返回 <code>inLaunching</code> 状态给调用者。</li></ol><h1 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h1><p>Q: <strong>ContentProviderConnection中stableCount与unstableCount的作用是什么？</strong></p><p>A： <code>stableCount</code> 与 <code>unstableCount</code> 分别记录这个 ContentProviderConnection 中使用 <code>stableProvider</code> 与 <code>unstableProvider</code> 的个数。如果 <code>stableCount &gt; 0</code>，服务端进程死亡时，AMS 就会杀掉对应的客户端进程，以确保数据一致性。</p><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1><ol><li>ContentProvider | Android 开发者, <a href="https://developer.android.com/guide/topics/providers/content-providers">https://developer.android.com/guide/topics/providers/content-providers</a></li><li>Android之ContentProvider源码解析, <a href="https://juejin.im/post/5c789ebee51d453f0d4413a2">https://juejin.im/post/5c789ebee51d453f0d4413a2</a></li><li>理解ContentProvider原理, <a href="http://gityuan.com/2016/07/30/content-provider/">http://gityuan.com/2016/07/30/content-provider/</a></li><li>ContentProvider流程解析, <a href="https://www.jianshu.com/p/f01357e6bb32">https://www.jianshu.com/p/f01357e6bb32</a></li><li>从源码角度看ContentProvider, <a href="https://juejin.im/post/5a0c611f6fb9a0450b65ee7c">https://juejin.im/post/5a0c611f6fb9a0450b65ee7c</a></li></ol><h1 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/content/ContentProvider.java</span><br><span class="line">frameworks/base/core/java/android/content/ContentResolver.java</span><br><span class="line">frameworks/base/core/java/android/content/IContentProvider.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/content/pm/ProviderInfo.java</span><br><span class="line">frameworks/base/core/java/android/content/pm/PackageManager.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">frameworks/base/core/java/android/app/ContentProviderHolder.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/services/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/core/services/com/android/server/am/ProviderMap.java</span><br><span class="line">frameworks/base/core/services/com/android/server/am/ContentProviderRecord.java</span><br><span class="line">frameworks/base/core/services/com/android/server/am/ContentProviderConnection.java</span><br><span class="line">frameworks/base/core/services/com/android/server/am/ProviderMap.java</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Broadcast 源码分析</title>
      <link href="/posts/3752956090/"/>
      <url>/posts/3752956090/</url>
      
        <content type="html"><![CDATA[<h1 id="android-广播机制介绍"><a class="markdownIt-Anchor" href="#android-广播机制介绍"></a> Android 广播机制介绍</h1><p>类似于发布-订阅设计模式，Android 应用可以与其他应用相互收发广播消息，还可以接收 Android 系统的广播消息。例如，Android 系统会在系统启动或设备开始充电时发送广播。再比如，应用可以发送自定义广播来通知其他应用它们可能感兴趣的事件。</p><p>应用可以注册接收特定的广播，这样系统会在广播发出后传送给这些应用。</p><p>按发送方式分类，广播可分为有序广播、常规广播、本地广播；按定义方式分类，可分为系统广播、自定义广播。此外，广播接收器可分为清单声明的接收器与上下文注册的接收器。</p><span id="more"></span><h2 id="接收广播"><a class="markdownIt-Anchor" href="#接收广播"></a> 接收广播</h2><h3 id="清单声明的接收器"><a class="markdownIt-Anchor" href="#清单声明的接收器"></a> 清单声明的接收器</h3><p>如果在清单中声明广播接收器，系统会在广播发出后启动该应用。</p><p>使用方法：</p><ol><li>在应用清单中指定 <code>&lt;receiver&gt;</code> 元素，<code>&lt;intent-filter&gt;</code> 指定订阅的广播操作。</li><li>创建 <code>BroadcastReceiver </code>子类，实现 <code>onReceive(Context, Intent)</code> 方法。</li></ol><p>系统软件包管理器会在应用安装时注册接收器。</p><h3 id="上下文注册的接收器"><a class="markdownIt-Anchor" href="#上下文注册的接收器"></a> 上下文注册的接收器</h3><p>使用方法：</p><ol><li>创建 <code>BroadcastReceiver</code> 子类并实例化。</li><li>创建 <code>IntentFilter</code> 并调用 <code>registerReceiver(BroadcastReceiver, IntentFilter)</code> 注册接收器。只要注册上下文有效，接收器就会接收到广播。</li><li>如有需要，调用<code>unregisterReceiver(android.content.BroadcastReceiver)</code> 停止接收广播。</li></ol><h3 id="对进程状态的影响"><a class="markdownIt-Anchor" href="#对进程状态的影响"></a> 对进程状态的影响</h3><blockquote><p><code>BroadcastReceiver</code> 的状态（无论它是否在运行）会影响其所在进程的状态，而其所在进程的状态又会影响它被系统终结的可能性。例如，当进程执行接收器（即当前在运行其 <code>onReceive()</code> 方法中的代码）时，它被认为是前台进程。除非遇到极大的内存压力，否则系统会保持该进程运行。</p><p>但是，一旦从 <code>onReceive()</code> 返回代码，BroadcastReceiver 就不再活跃。接收器的宿主进程变得与在其中运行的其他应用组件一样重要。如果该进程仅托管清单声明的接收器（这对于用户从未与之互动或最近没有与之互动的应用很常见），则从 <code>onReceive()</code> 返回时，系统会将其进程视为低优先级进程，并可能会将其终止，以便将资源提供给其他更重要的进程使用。</p></blockquote><h2 id="发送广播"><a class="markdownIt-Anchor" href="#发送广播"></a> 发送广播</h2><p>Android 为应用提供三种方式来发送广播：</p><ul><li><p><code>sendOrderedBroadcast(Intent, String)</code> 方法发送<strong>有序广播</strong>。系统按接收器的优先级逐个顺序向接收器发送广播，上一个接收器处理完广播后才发送广播到下一个接收器。当接收器逐个顺序执行时，接收器可以向下传递结果，也可以完全中止广播，使其不再传递给其他接收器。接收器的运行顺序可以通过匹配的 intent-filter 的 android:priority 属性来控制；具有相同优先级的接收器将按随机顺序运行。</p></li><li><p><code>sendBroadcast(Intent)</code> 方法发送<strong>常规广播</strong>。系统会按随机的顺序向所有接收器发送广播。这种方法效率更高，但也意味着接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播。</p></li><li><p><code>LocalBroadcastManager.sendBroadcast</code> 方法发送<strong>本地广播</strong>。这种广播只会发送给与发送器位于同一应用中的接收器，适用于无需跨应用发送广播的场景。这种实现方法的效率更高（无需进行进程间通信），而且无需担心其他应用在收发您的广播时带来的任何安全问题。</p></li></ul><p>当 BroadcastReceiver 接收到有序广播后，在 <code>onReceive</code> 方法内：</p><ul><li>使用 <code>getResultCode</code>，<code>getResultData</code>,<code>getResultExtras</code> 方法取得上个广播接收器返回的结果；</li><li>使用 <code>setResult(int, String, Bundle)</code> 以及对应的 set 方法设置结果传递给下个广播接收器；</li><li>使用 <code>abortBroadcast()</code> 方法来中止广播，使其不再传递给下个接收器。</li></ul><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><p>广播机制的“注册中心”，是由 ActivityManagerService 来担当的，这个系统组件负责处理广播接收器的注册请求，收取所有发送的广播，根据广播类型找到相应的接收器，最后将广播发送给接收器们处理。</p><h2 id="注册接收器"><a class="markdownIt-Anchor" href="#注册接收器"></a> 注册接收器</h2><h3 id="清单声明的接收器静态注册"><a class="markdownIt-Anchor" href="#清单声明的接收器静态注册"></a> 清单声明的接收器（静态注册）</h3><p>TODO</p><h3 id="上下文注册的接收器动态注册"><a class="markdownIt-Anchor" href="#上下文注册的接收器动态注册"></a> 上下文注册的接收器（动态注册）</h3><p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/registerBroadcast.svg" alt="注册广播接收器时序图" /></p><p>应用调用 Activity/Service 的 <code>registerReceiver</code> 方法注册接收器，而 Activity/Service 都继承于 Context 抽象类，最终调用的实现在 <code>ContextImpl.registerReceiverInternal</code> 方法中。</p><h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Intent <span class="title function_">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        IntentFilter filter, String broadcastPermission,</span></span><br><span class="line"><span class="params">        Handler scheduler, Context context, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">IIntentReceiver</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span> &amp;&amp; context != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="literal">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="literal">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> <span class="title class_">LoadedApk</span>.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="literal">null</span>, <span class="literal">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> ActivityManager.getService().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                broadcastPermission, userId, flags);</span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mPackageInfo</code> 是 LoadedApk 类型对象，在应用启动时创建。</p><p>如果 <code>scheduler</code> 参数没有指定 Handler， 会获取主线程的 Handler。</p><p>将广播接收器 <code>receiver</code> 封装成 LoadedApk.ReceiverDispatcher 对象，包含了传入的 BroadcastReceiver，调用者的 Context，用于处理的 Handler，主线程的 Instrumentation（用于测试）。这个 ReceiverDispatcher 对象包含一个实现了 <code>IIntentReceiver</code> AIDL 接口的 InnerReceivcer 对象 <code>mIIntentReceiver</code>。</p><p>如果 <code>mPackageInfo</code> 对象和 <code>context</code> 参数都不为空，使用 <code>LoadedApk.getReceiverDispatcher</code> 方法获取该对象，同时在 LoadedApk 的 <code>mReceivers</code> 成员注册该 ReceiverDispatcher；否则，创建 ReceiverDispatcher 对象并使用 <code>getIIntentReceiver()</code> 方法返回其 InnerReceivcer 对象。</p><p>通过 Binder 调用 ActivityManagerService 的 <code>registerReceiver</code> 方法，传入封装的 InnerReceivcer 对象、 IntentFilter 和其他调用者相关的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Intent <span class="title function_">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span><br><span class="line"><span class="params">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">            callerApp = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (callerApp == <span class="literal">null</span>) &#123;...&#125; <span class="comment">// throw SecurityException</span></span><br><span class="line">            <span class="keyword">if</span> (callerApp.info.uid != SYSTEM_UID &amp;&amp;</span><br><span class="line">                    !callerApp.pkgList.containsKey(callerPackage) &amp;&amp;</span><br><span class="line">                    !<span class="string">&quot;android&quot;</span>.equals(callerPackage)) &#123;...&#125; <span class="comment">// throw SecurityException</span></span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callerPackage = <span class="literal">null</span>;</span><br><span class="line">            callingUid = Binder.getCallingUid();</span><br><span class="line">            callingPid = Binder.getCallingPid();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">        <span class="keyword">if</span> (actions == <span class="literal">null</span>) &#123;...&#125; <span class="comment">// 新建空白迭代器</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>首先使用 <code>getRecordForAppLocked</code> 获取调用者（<code>caller</code>）的 <code>ProcessRecord</code>，如果找不到这个应用，或者应用不在运行，则抛出 SecurityException。如果 <code>caller</code> 为 <code>null</code>，则使用 Binder 获取其 UID 和 PID。</p><p>获取 IntentFilter 的 actions 迭代器（如果为空，就新建空白迭代器）。</p><h3 id="匹配粘性广播"><a class="markdownIt-Anchor" href="#匹配粘性广播"></a> 匹配粘性广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Collect stickies of users</span></span><br><span class="line">    <span class="type">int</span>[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">    <span class="keyword">while</span> (actions.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> actions.next();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : userIds) &#123;</span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">            <span class="keyword">if</span> (stickies != <span class="literal">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                <span class="keyword">if</span> (intents != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stickyIntents == <span class="literal">null</span>) &#123;</span><br><span class="line">                        stickyIntents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Intent&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    stickyIntents.addAll(intents);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//离开临界区</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Intent&gt; allSticky = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (stickyIntents != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> mContext.getContentResolver();</span><br><span class="line">    <span class="comment">// Look for any matching sticky broadcasts...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> stickyIntents.get(i);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (filter.match(resolver, intent, <span class="literal">true</span>, TAG) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allSticky == <span class="literal">null</span>) &#123;</span><br><span class="line">                allSticky = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Intent&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            allSticky.add(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The first sticky in the list is returned directly back to the client.</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">sticky</span> <span class="operator">=</span> allSticky != <span class="literal">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="literal">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (receiver == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 actions 迭代器，寻找全局和调用者所属用户的粘性广播列表中 Intent action 匹配的广播，将结果添加到 <code>stickyIntents</code> 列表。</p><p>离开临界区，如果获取到了匹配的粘性广播，遍历结果列表，使用 <code>IntentFilter.match</code> 方法进一步匹配 IntentFilter 的其他属性，将最终结果添加到 <code>allSticky</code> 列表。</p><p>如果有获取到粘性广播，将列表中的第一个粘性广播赋值给 <code>sticky</code>，准备之后返回给调用者。</p><p>如果广播接收器为 <code>null</code>，在这里直接将结果 <code>sticky</code> 返回。</p><h3 id="注册广播接收器"><a class="markdownIt-Anchor" href="#注册广播接收器"></a> 注册广播接收器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callerApp != <span class="literal">null</span> &amp;&amp; (callerApp.thread == <span class="literal">null</span></span><br><span class="line">            || callerApp.thread.asBinder() != caller.asBinder())) &#123;</span><br><span class="line">        <span class="comment">// Original caller already died</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ReceiverList</span> <span class="variable">rl</span> <span class="operator">=</span> mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">    <span class="keyword">if</span> (rl == <span class="literal">null</span>) &#123;</span><br><span class="line">        rl = <span class="keyword">new</span> <span class="title class_">ReceiverList</span>(<span class="built_in">this</span>, callerApp, callingPid, callingUid,</span><br><span class="line">                userId, receiver);</span><br><span class="line">        <span class="keyword">if</span> (rl.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalReceiversForApp</span> <span class="operator">=</span> rl.app.receivers.size();</span><br><span class="line">            <span class="keyword">if</span> (totalReceiversForApp &gt;= MAX_RECEIVERS_ALLOWED_PER_APP) &#123;...&#125; <span class="comment">// throw IllegalStateException</span></span><br><span class="line">            rl.app.receivers.add(rl);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                receiver.asBinder().linkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> sticky;</span><br><span class="line">            &#125;</span><br><span class="line">            rl.linkedToDeath = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.uid != callingUid) &#123;...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.pid != callingPid) &#123;...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.userId != userId) &#123;...&#125; <span class="comment">// throw IllegalArgumentException</span></span><br><span class="line">    <span class="type">BroadcastFilter</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastFilter</span>(filter, rl, callerPackage,</span><br><span class="line">            permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">    <span class="keyword">if</span> (rl.containsFilter(filter)) &#123; ... <span class="comment">// 警告接收器已经注册</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rl.add(bf);</span><br><span class="line">        ... <span class="comment">//debugCheck</span></span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue broadcasts for all existing stickies that match</span></span><br><span class="line">    <span class="comment">// this filter.</span></span><br><span class="line">    <span class="keyword">if</span> (allSticky != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">receivers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        receivers.add(bf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">stickyCount</span> <span class="operator">=</span> allSticky.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stickyCount; i++) &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> allSticky.get(i);</span><br><span class="line">            <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">            <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, <span class="literal">null</span>,</span><br><span class="line">                    <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, OP_NONE, <span class="literal">null</span>, receivers,</span><br><span class="line">                    <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, -<span class="number">1</span>, <span class="literal">false</span>,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/* only PRE_BOOT_COMPLETED should be exempt, no stickies */</span>);</span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sticky;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先检查调用者进程是否还存活，如果已死，则返回 null。</p><p>从 <code>mRegisteredReceiveres</code> 获取当前接收器对应的接收器列表（<code>ReceiverList rl</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>mRegisteredReceiveres</code> 保存了所有注册的广播接收器，其 hash key为 当前接收器 IBinder 对象 IIntentReceiver，值为对应的接收器列表。ReceiverList 是 ArrayList&lt;BroadcastFilter&gt; 的子类，保存了调用者的 ProcessRecord、UID、PID、UserID 以及接收器 IIntentFilter 信息。</p><p>如果还没有对应的列表，就新建一个，加入到 <code>mRegisteredReceiveres</code> 中。如果有调用者应用信息，这时还要检查调用者应用注册的接收器总数是否达到上限，超限则抛出 IllegalStateException，没有超限则加入到调用者应用的接收器列表中。如果之前没有得到调用者应用信息，在这里就向接收器列表注册当前接收器的死亡回调，检查接收器所在进程是否存活，若死亡就返回 <code>sticky</code>。</p><p>判断获取的接收器列表中，UID/PID/UserID 是否与调用者的对应值相同，不同则抛出 IllegalArgumentException。</p><p>将广播接收器的接收器列表、IntentFilter、调用者、权限等信息封装到 BroadcastFilter 对象中。检查具有相同 IntentFilter 的接收器是否已存在于接收器列表中。如果没有，就将 BroadcastFilter 加入到接收器列表和 <code>mReceiverResolver</code> 中，也就完成了广播接收器的注册。</p><p>上面注册结束以后，如果筛选出了与当前注册的 IntentFilter 匹配的粘性广播列表，就将所有这些粘性广播逐条发送给当前的接收器 <code>receivers</code>，可以看到 <code>receivers</code> 里面就只有之前创建的一个 BroadcastFilter。最后返回 <code>sticky</code>。</p><p>总结一下，通过上下文注册的广播接收器会在这些地方留下记录：</p><ul><li>AMS 的 <code>mRegisteredReceivers</code> 成员中注册 BroadcastFilter</li><li>ProcessRecord 的 <code>receivers</code> 成员中注册 BroadcastFilter</li><li>LoadedApk 的 <code>mReceivers</code> 成员中注册 ReceiverDispatcher</li><li>AMS 的 <code>mReceiverResolver</code> 成员中注册 BroadcastFilter</li></ul><h2 id="注销接收器"><a class="markdownIt-Anchor" href="#注销接收器"></a> 注销接收器</h2><p>通过 <code>registerReceiver</code> 注册的接收器可以通过 <code>unRegisterReceiver</code> 方法来注销。</p><p>类似于其配对方法，实现位于 <code>ContextImpl.unRegisterReceiver</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">IIntentReceiver</span> <span class="variable">rd</span> <span class="operator">=</span> mPackageInfo.forgetReceiverDispatcher(</span><br><span class="line">                getOuterContext(), receiver);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().unregisterReceiver(rd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>forgetReceiverDispatcher</code> 移除 LoadedApk 中注册的 ReceiverDispatcher，再交由 AMS 的同名方法继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">doTrim</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">ReceiverList</span> <span class="variable">rl</span> <span class="operator">=</span> mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (rl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> rl.curBroadcast;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; r == r.queue.getMatchingOrderedReceiver(r)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">doNext</span> <span class="operator">=</span> r.queue.finishReceiverLocked(</span><br><span class="line">                            r, r.resultCode, r.resultData, r.resultExtras,</span><br><span class="line">                            r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">                        doTrim = <span class="literal">true</span>;</span><br><span class="line">                        r.queue.processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rl.app != <span class="literal">null</span>) &#123;</span><br><span class="line">                    rl.app.receivers.remove(rl);</span><br><span class="line">                &#125;</span><br><span class="line">                removeReceiverLocked(rl);</span><br><span class="line">                <span class="keyword">if</span> (rl.linkedToDeath) &#123;</span><br><span class="line">                    rl.linkedToDeath = <span class="literal">false</span>;</span><br><span class="line">                    rl.receiver.asBinder().unlinkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doTrim) &#123;</span><br><span class="line">            trimApplications(OomAdjuster.OOM_ADJ_REASON_FINISH_RECEIVER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注销接收器也就是在之前注册的地方移除对应的记录，此外还要从广播队列中移除该接收器。具体来说：</p><ul><li>在 <code>mRegisteredReceivers</code> 中，取得对应的接收器列表，再取得该列表中正在处理的广播，再取得该广播的广播队列，调用 <code>BroadcastQueue.finishReceiverLocked</code> 方法</li><li>从 ProcessRecord 的 <code>receivers</code>  成员中注销接收器；</li><li>调用 <code>removeReceiverLocked</code> 方法，从 <code>mRegisteredReceivers</code> 中注销接收器，从 <code>mReceiverResolver</code> 中移除 BroadcastFilter。</li></ul><h2 id="发送广播-2"><a class="markdownIt-Anchor" href="#发送广播-2"></a> 发送广播</h2><p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendBroadcast.svg" alt="加入广播到 BroadcastQueue" /></p><p>应用调用 Context 类的 <code>sendBroadcast</code> 系列方法，其实现位于 ContextImpl 中，最终调用 AMS 的 <code>broadcastIntent</code> 方法。</p><h3 id="初始验证"><a class="markdownIt-Anchor" href="#初始验证"></a> 初始验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span><br><span class="line"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> resultCode, String resultData, Bundle resultExtras,</span></span><br><span class="line"><span class="params">        String[] requiredPermissions, <span class="type">int</span> appOp, Bundle bOptions,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> serialized, <span class="type">boolean</span> sticky, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;broadcastIntent&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line">        ...... <span class="comment">// 准备调用 broadcastIntentLocked 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>verifyBroadcastLocked</code> 会判断广播的 Intent 是否合法：</p><ul><li>广播 Intent 不能包含文件描述符；</li><li>如果没有设置 <code>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</code> 或 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标志，不能在系统启动完成前广播；</li><li>不能设置 <code>FLAG_RECEIVER_BOOT_UPGRADE</code> 标志；</li><li>如果设置了 <code>FLAG_RECEIVER_FROM_SHELL</code> 标志，发送者必须以 root 或 shell 用户运行，否则该标志会被移除。</li></ul><p>最后调用 <code>broadcastIntentLocked</code> 方法。这个方法很长，分段来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span><br><span class="line"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">        IIntentReceiver resultTo, <span class="type">int</span> resultCode, String resultData,</span></span><br><span class="line"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="type">int</span> appOp, Bundle bOptions,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, <span class="type">int</span> realCallingUid,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> realCallingPid, <span class="type">int</span> userId, <span class="type">boolean</span> allowBackgroundActivityStarts)</span> &#123;</span><br><span class="line">    intent = <span class="keyword">new</span> <span class="title class_">Intent</span>(intent);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// By default broadcasts do not go to stopped apps.</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line">        <span class="comment">// If we have not finished booting, don&#x27;t allow this to launch new processes.</span></span><br><span class="line">        <span class="keyword">if</span> (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) &#123;</span><br><span class="line">            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line">        userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="literal">true</span>,</span><br><span class="line">                ALLOW_NON_FULL, <span class="string">&quot;broadcast&quot;</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that the user who is receiving this broadcast or its parent is running.</span></span><br><span class="line">        <span class="comment">// If not, we will just skip it. Make an exception for shutdown broadcasts, upgrade steps.</span></span><br><span class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserOrItsParentRunning(userId)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((callingUid != SYSTEM_UID</span><br><span class="line">                    || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>)</span><br><span class="line">                    &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Skipping broadcast of &quot;</span> + intent</span><br><span class="line">                        + <span class="string">&quot;: user &quot;</span> + userId + <span class="string">&quot; and its parent (if any) are stopped&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复制一份 Intent， 设置属性，使广播不能发送到停止的应用，不能在还没有启动完成时启动新进程。</p><p>判断广播可以送达的用户。广播不能向没有在运行的用户应用发送。</p><h3 id="后台执行限制相关"><a class="markdownIt-Anchor" href="#后台执行限制相关"></a> 后台执行限制相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line"><span class="type">BroadcastOptions</span> <span class="variable">brOptions</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (bOptions != <span class="literal">null</span>) &#123;</span><br><span class="line">    brOptions = <span class="keyword">new</span> <span class="title class_">BroadcastOptions</span>(bOptions);</span><br><span class="line">    <span class="keyword">if</span> (brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (brOptions.isDontSendToRestrictedApps()</span><br><span class="line">            &amp;&amp; !isUidActiveLocked(callingUid)</span><br><span class="line">            &amp;&amp; isBackgroundRestrictedNoCheck(callingUid, callerPackage)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Not sending broadcast &quot;</span> + action + <span class="string">&quot; - app &quot;</span> + callerPackage</span><br><span class="line">                + <span class="string">&quot; has background restrictions&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.START_CANCELED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (brOptions.allowsBackgroundActivityStarts()) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入了 <code>bOptions</code> 参数，进行与后台执行限制相关的权限检查：</p><ul><li>不具有 <code>CHANGE_DEVICE_IDLE_TEMP_WHITELIST</code> 的进程不允许发送广播，并抛出 SecurityException；</li><li>应用有后台限制，则广播不会被发送；</li><li>广播选项允许后台 Activity 启动，并且发送者不具有 <code>START_ACTIVITIES_FROM_BACKGROUND</code> 权限，不允许发送广播，抛出 SecurityException。</li></ul><p>Q: 带 <code>options</code> 参数的 <code>sendBroadcast</code> 方法带有 <code>@SystemApi</code> 装饰器，不应由开发者主动调用，那系统是如何调用该方法，添加所需的 <code>options</code> 参数呢？</p><h3 id="判断与处理受保护广播"><a class="markdownIt-Anchor" href="#判断与处理受保护广播"></a> 判断与处理受保护广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isProtectedBroadcast;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isCallerSystem;</span><br><span class="line"><span class="comment">// 判断发送者是否是系统进程</span></span><br><span class="line"><span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First line security check before anything else: stop non-system apps from</span></span><br><span class="line"><span class="comment">// sending protected broadcasts.</span></span><br><span class="line"><span class="keyword">if</span> (!isCallerSystem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isProtectedBroadcast) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(msg);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">            || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查广播是否为受保护广播：只有系统能发送受保护广播，系统只能发送受保护广播。除了一个例外：为了兼容性原因，允许应用发送配置和更新应用微件（App Widget）的广播到自身的应用微件。</p><p>对一些系统广播（添加删除应用、时间更改、网络变更等）进行处理（杀进程、通知电池服务等），此处源码略过不表。</p><h3 id="处理粘性广播"><a class="markdownIt-Anchor" href="#处理粘性广播"></a> 处理粘性广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">    <span class="keyword">if</span> (checkPermission(android.Manifest.permission.BROADCAST_STICKY,...)...) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (requiredPermissions != <span class="literal">null</span> &amp;&amp; requiredPermissions.length &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() != <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="comment">// We use userId directly here, since the &quot;all&quot; target is maintained</span></span><br><span class="line">    <span class="comment">// as a separate set of sticky broadcasts.</span></span><br><span class="line">    <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">        <span class="comment">// But first, if this is not a broadcast to all users, then</span></span><br><span class="line">        <span class="comment">// make sure it doesn&#x27;t conflict with an existing broadcast to</span></span><br><span class="line">        <span class="comment">// all users.</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (stickies == <span class="literal">null</span>) &#123;</span><br><span class="line">        stickies = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">        mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stickies.put(intent.getAction(), list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">stickiesCount</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">            <span class="comment">// This sticky already exists, replace it.</span></span><br><span class="line">            list.set(i, <span class="keyword">new</span> <span class="title class_">Intent</span>(intent));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= stickiesCount) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Intent</span>(intent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段处理粘性广播(Sticky Broadcast)。</p><p>所有粘性广播列表保存在 AMS 的 <code>mStickyBroadcasts</code> 成员中。最外层的 SparseArray 以 user ID 为 key，中层的 ArrayMap 以 Intent 的 action 为 key，相同 user ID 、相同 action 的 Intent 保存在 ArrayList 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts = ...;</span><br></pre></td></tr></table></figure><p>首先检查权限：</p><ul><li>发送者没有 <code>BROADCAST_STICKY</code> 权限，则抛出 SecurityException；</li><li>如果 <code>requiredPermissions</code> 非空，则广播发送中止，因为粘性广播不能规定接收器权限。</li><li>如果广播的 Intent 指定了特定的组件作为接收器，则抛出 SecurityException，因为粘性广播不支持指定接收器。</li></ul><p>如果广播不是针对所有用户，遍历针对所有用户的粘性广播（全局粘性广播）列表，检查是否与已有的全局广播冲突。如果有冲突，抛出 IllegalArgumentException。</p><p>最后，获取广播面向的用户对应的粘性广播列表，如果已有广播的 Intent filter 与当前广播相同，则用当前广播替换，否则，将当前广播加入该列表。</p><h3 id="寻找广播接收器"><a class="markdownIt-Anchor" href="#寻找广播接收器"></a> 寻找广播接收器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] users;</span><br><span class="line"><span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">    <span class="comment">// Caller wants broadcast to go to all started users.</span></span><br><span class="line">    users = mUserController.getStartedUserArray();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Caller wants broadcast to go to one specific user.</span></span><br><span class="line">    users = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;userId&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化广播将要发送给的用户列表：</p><ul><li>如果指定发送给所有用户，就将所有<strong>已在运行的</strong>用户加入列表；</li><li>如果指定给特定用户，就只加入该用户到列表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line"><span class="type">List</span> <span class="variable">receivers</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (intent.getComponent() == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == SHELL_UID) &#123;</span><br><span class="line">        <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mUserController.hasUserRestriction(</span><br><span class="line">                    UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                    mReceiverResolver.queryIntent(intent,</span><br><span class="line">                            resolvedType, <span class="literal">false</span> <span class="comment">/*defaultOnly*/</span>, users[i]);</span><br><span class="line">            <span class="keyword">if</span> (registeredReceivers == <span class="literal">null</span>) &#123;</span><br><span class="line">                registeredReceivers = registeredReceiversForUser;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, <span class="literal">false</span> <span class="comment">/*defaultOnly*/</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果广播没有指定仅发送给上下文注册的接收器（通过设置 <code>FLAG_RECEIVER_REGISTERED_ONLY</code>），就调用 <code>collectReceiverComponents</code> 方法获取清单注册的接收器。</p><p>如果广播没有指定接收器的组件名，就获取接收器列表：如果指定发送给所有用户，遍历之前创建的正在运行用户列表，将每个用户的接收器加入到 <code>registeredReceivers</code> 列表；否则，将指定用户的接收器加入该列表。</p><h3 id="发送常规广播"><a class="markdownIt-Anchor" href="#发送常规广播"></a> 发送常规广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">replacePending</span> <span class="operator">=</span></span><br><span class="line">        (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">&quot;Enqueueing broadcast: &quot;</span> + intent.getAction()</span><br><span class="line">        + <span class="string">&quot; replacePending=&quot;</span> + replacePending);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">NR</span> <span class="operator">=</span> registeredReceivers != <span class="literal">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// If we are not serializing this broadcast, then send the</span></span><br><span class="line">    <span class="comment">// registered receivers separately so they don&#x27;t wait for the</span></span><br><span class="line">    <span class="comment">// components to be launched.</span></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                isProtectedBroadcast, registeredReceivers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">    <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">            resultCode, resultData, resultExtras, ordered, sticky, <span class="literal">false</span>, userId,</span><br><span class="line">            allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">&quot;Enqueueing parallel broadcast &quot;</span> + r);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">replaced</span> <span class="operator">=</span> replacePending</span><br><span class="line">            &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// Note: We assume resultTo is null for non-ordered broadcasts.</span></span><br><span class="line">    <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">        queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    registeredReceivers = <span class="literal">null</span>;</span><br><span class="line">    NR = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前广播为常规广播，上下文注册的接收器列表非空，进行以下操作：</p><ol><li>通过 <code>broadcastQueueForIntent</code> 方法，获取对应的广播队列。将广播封装到 BroadcastRecord 对象中。</li><li>如果广播（通过设置 <code>FLAG_RECEIVER_REPLACE_PENDING</code>） 要求顶替尚未发送的同类广播，就调用 <code>replaceParallelBroadcastLocked</code> 方法，尝试寻找广播队列中的同类广播并将其替换。否则，使用 <code>enqueueParallelBroadcastLocked</code> 将广播加入到广播队列，再使用 <code>scheduleBroadcastsLocked</code> 安排发送广播。</li><li>最后将上下文注册的接收器列表 <code>registeredReceivers</code> 设为 null，以避免下一步重复操作。</li></ol><h3 id="发送其余广播"><a class="markdownIt-Anchor" href="#发送其余广播"></a> 发送其余广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge into one list.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ir</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (receivers != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 不允许应用接收自身的 PACKAGE_ADDED 广播，以免其利用该广播自启动。</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">NT</span> <span class="operator">=</span> receivers != <span class="literal">null</span> ? receivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ResolveInfo</span> <span class="variable">curt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BroadcastFilter</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curt == <span class="literal">null</span>) &#123;</span><br><span class="line">            curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">            curr = registeredReceivers.get(ir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">            <span class="comment">// Insert this broadcast record into the final list.</span></span><br><span class="line">            receivers.add(it, curr);</span><br><span class="line">            ir++;</span><br><span class="line">            curr = <span class="literal">null</span>;</span><br><span class="line">            it++;</span><br><span class="line">            NT++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip to the next ResolveInfo in the final list.</span></span><br><span class="line">            it++;</span><br><span class="line">            curt = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ir &lt; NR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (receivers == <span class="literal">null</span>) &#123;</span><br><span class="line">        receivers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    receivers.add(registeredReceivers.get(ir));</span><br><span class="line">    ir++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面将动态接收器的常规广播记录加入广播队列，剩下待处理的还有静态接收器的常规广播，以及有序广播（动态和静态接收器的）。</p><p>如果广播类型为 <code>PACKAGE_ADDED</code> / <code>PACKAGE_RESTARTED</code> / <code>PACKAGE_DATA_CLEARED</code> / <code>EXTERNAL_APPLICATIONS_AVAILABLE</code>，则从接收器列表中移除广播中提到的应用，以免其利用该广播进行自启。</p><p>将动态接收器列表 <code>registeredReceivers</code> 按优先级顺序合并到静态接收器列表 <code>receivers</code> 中。现在这个列表中包含了来自动态接收器的 BroadcastFilter 对象，和来自静态接收器的 ResolveInfo 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((receivers != <span class="literal">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">        || resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">    <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, <span class="literal">false</span>, userId,</span><br><span class="line">            allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">&quot;Enqueueing ordered broadcast &quot;</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BroadcastRecord</span> <span class="variable">oldRecord</span> <span class="operator">=</span></span><br><span class="line">            replacePending ? queue.replaceOrderedBroadcastLocked(r) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Replaced, fire the result-to receiver.</span></span><br><span class="line">        <span class="keyword">if</span> (oldRecord.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">BroadcastQueue</span> <span class="variable">oldQueue</span> <span class="operator">=</span> broadcastQueueForIntent(oldRecord.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oldQueue.performReceiveLocked(oldRecord.callerApp, oldRecord.resultTo,</span><br><span class="line">                        oldRecord.intent,</span><br><span class="line">                        Activity.RESULT_CANCELED, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                        <span class="literal">false</span>, <span class="literal">false</span>, oldRecord.userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There was nobody interested in the broadcast, but we still want to record</span></span><br><span class="line">    <span class="comment">// that it happened.</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="literal">null</span> &amp;&amp; intent.getPackage() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This was an implicit broadcast... let&#x27;s record it for posterity.</span></span><br><span class="line">        addBroadcastStatLocked(intent.getAction(), callerPackage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br></pre></td></tr></table></figure><p>类似之前的操作，获取广播队列，封装广播对象，尝试替换未发送的重复广播，或者加入广播到队列并安排发送。替换广播后要调用 <code>performReceiveLocked</code> 方法。</p><p>如果隐式广播没有找到接收器，调用 <code>addBroadcastStatLocked</code> 记录这次广播。</p><p>最后，返回广播成功的标志。</p><h2 id="相关对象与方法"><a class="markdownIt-Anchor" href="#相关对象与方法"></a> 相关对象与方法</h2><h3 id="broadcastqueue"><a class="markdownIt-Anchor" href="#broadcastqueue"></a> BroadcastQueue</h3><h4 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h4><p>BroadcastQueue 对象分别存储了两种广播记录的队列，并支持对广播队列的增删改查操作。</p><p>动态注册的常规广播记录存储在 <code>ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts</code>  中。<code>enqueueParallelBroadcastLocked</code> 和  <code>replaceParallelBroadcastLocked</code> 方法实际上就是对该列表的操作。</p><p>其余广播存储在 <code>BroadcastDispatcher mDispatcher</code> 对象中，并由该对象负责管理。队列的实际存储位置是 <code>BroadcastDispatcher.mOrderedBroadcasts</code>，同样是 ArrayList&lt;BroadcastRecord&gt; 类型。<code>enqueueOrderedBroadcastLocked</code> 和 <code>replaceOrderedBroadcastLocked</code> 方法就是对该列表的操作。注意这里的变量和方法名令人困惑：这个广播队列不仅储存了有序广播，也储存了静态注册的常规广播。</p><h4 id="通过-handler-触发广播发送"><a class="markdownIt-Anchor" href="#通过-handler-触发广播发送"></a> 通过 Handler 触发广播发送</h4><p>BroadcastHandler 子类重载了 Handler 的 <code>HandleMessage</code> 方法，当接到 <code>BROADCAST_INTENT_MSG</code> 时执行 <code>processNextBroadcast</code> 方法，接到 <code>BROADCAST_TIMEOUT_MSG</code> 时执行 <code>broadcastTimeoutLocked</code> 方法。这个子类的实例作为成员变量 <code>mHandler</code> 出现，对应的 Looper 由 AMS 的 <code>mHandlerThread</code> 持有。</p><p><code>scheduleBroadcastsLocked</code> 方法安排广播发送，实际上就是向 <code>mHandler</code> 发送 <code>BROADCAST_INTENT_MSG</code>，并设置 <code>mBroadcastScheduled = true</code> 以避免重复发送该消息。</p><h4 id="处理广播队列"><a class="markdownIt-Anchor" href="#处理广播队列"></a> 处理广播队列</h4><p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendRegisteredBroadcast.svg" alt="发送常规广播时序图" /></p><p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendOrderedBroadcast.svg" alt="发送有序广播时序图" /></p><p><code>processNextBroadcast</code> 方法获取 AMS 的锁，再执行 <code>processNextBroadcastLocked</code> 方法。</p><p>这个方法是广播队列处理的核心，很长，分段来看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processNextBroadcastLocked</span><span class="params">(<span class="type">boolean</span> fromMsg, <span class="type">boolean</span> skipOomAdj)</span> &#123;</span><br><span class="line">    BroadcastRecord r;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">    mBroadcastsScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></span><br><span class="line">    <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> r.receivers.size();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> r.receivers.get(i);</span><br><span class="line">            ...</span><br><span class="line">            deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="literal">false</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        addBroadcastToHistoryLocked(r);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先发送动态接收器的常规广播记录。一个个取出 <code>mParallelBroadcasts</code> 存储的常规广播记录，遍历其接收器，调用 <code>deliverToRegisteredReceiverLocked</code> 方法向接收器发送广播。最后调用 <code>addBroadcastToHistoryLocked</code> 方法记录广播历史。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPendingBroadcast != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> isDead;</span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcast.curApp.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">            <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mService.mPidsSelfLocked.get(</span><br><span class="line">                    mPendingBroadcast.curApp.pid);</span><br><span class="line">            isDead = proc == <span class="literal">null</span> || proc.isCrashing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mService.mProcessList.mProcessNames.get(</span><br><span class="line">                mPendingBroadcast.curApp.processName, mPendingBroadcast.curApp.uid);</span><br><span class="line">        isDead = proc == <span class="literal">null</span> || !proc.pendingStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDead) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s still alive, so keep waiting</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">        mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">        mPendingBroadcast = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来处理其余广播。<code>mPendingBroadcast</code> 记录当前正在处理的广播。如果该广播不为空，判断正在处理该广播的进程是否已退出。如果没有退出，就直接返回，以继续等待该进程。如果已退出，表明该应用已完成处理这个广播，更改该广播的状态为空闲，更新其下个接收器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">looped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// while (r == null);</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    r = mDispatcher.getNextBroadcastLocked(now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        .....<span class="comment">// No more broadcasts are deliverable right now, so all done!</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">forceReceive</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that even if something goes awry with the timeout</span></span><br><span class="line">    <span class="comment">// detection, we catch &quot;hung&quot; broadcasts here, discard them,</span></span><br><span class="line">    <span class="comment">// and continue to make progress.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is only done if the system is ready so that early-stage receivers</span></span><br><span class="line">    <span class="comment">// don&#x27;t get executed with timeouts; and of course other timeout-</span></span><br><span class="line">    <span class="comment">// exempt broadcasts are ignored.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numReceivers</span> <span class="operator">=</span> (r.receivers != <span class="literal">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; !r.timeoutExempt &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                (now &gt; r.dispatchTime + (<span class="number">2</span> * mConstants.TIMEOUT * numReceivers))) &#123;</span><br><span class="line">            ...</span><br><span class="line">            broadcastTimeoutLocked(<span class="literal">false</span>); <span class="comment">// forcibly finish this broadcast</span></span><br><span class="line">            forceReceive = <span class="literal">true</span>;</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入循环，这个循环用来搜索下一个需要发送的广播并将其取到变量 <code>r</code>，只有当 <code>r != null</code> 时才会退出循环。</p><p>调用 <code>mDispatcher.getNextBroadcastLocked</code> 方法获取下一个要处理的广播。如果没有，就直接返回。</p><p>检查广播处理是否超时。AMS 转发广播时会将当前时间记录在 BroadcastRecord 中，如果这个广播任务不能在 <code>2 * mConstants.TIMEOUT * numReceivers</code> 时间内完成（默认 TIMEOUT 值为 10 秒），就调用 <code>broadcastTimeoutLocked</code> 方法强制完成广播，将其状态设为 <code>IDLE</code>。如果这个广播的状态不是 <code>IDLE</code>，在这里直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In do &#123;...&#125; while (r == null)</span></span><br><span class="line"><span class="comment">// Is the current broadcast is done for any reason?</span></span><br><span class="line"><span class="keyword">if</span> (r.receivers == <span class="literal">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">        || r.resultAbort || forceReceive) &#123;</span><br><span class="line">    <span class="comment">// Send the final result if requested</span></span><br><span class="line">    <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if this was part of a split/deferral complex, update the refcount and only</span></span><br><span class="line">        <span class="comment">// send the completion when we clear all of them</span></span><br><span class="line">        <span class="keyword">if</span> (r.splitToken != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newCount</span> <span class="operator">=</span> mSplitRefcounts.get(r.splitToken) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newCount == <span class="number">0</span>) &#123;</span><br><span class="line">                ...<span class="comment">// done!  clear out this record&#x27;s bookkeeping and deliver</span></span><br><span class="line">                mSplitRefcounts.delete(r.splitToken);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// still have some split broadcast records in flight; update refcount</span></span><br><span class="line">                <span class="comment">// and hold off on the callback</span></span><br><span class="line">                ...</span><br><span class="line">                sendResult = <span class="literal">false</span>;</span><br><span class="line">                mSplitRefcounts.put(r.splitToken, newCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendResult) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">                performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.resultCode,</span><br><span class="line">                        r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                <span class="comment">// Set this to null so that the reference</span></span><br><span class="line">                <span class="comment">// (local and remote) isn&#x27;t kept in the mBroadcastHistory.</span></span><br><span class="line">                r.resultTo = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// ... and on to the next...</span></span><br><span class="line">    addBroadcastToHistoryLocked(r);</span><br><span class="line">    <span class="keyword">if</span> (r.intent.getComponent() == <span class="literal">null</span> &amp;&amp; r.intent.getPackage() == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This was an implicit broadcast... let&#x27;s record it for posterity.</span></span><br><span class="line">        mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatcher.retireBroadcastLocked(r);</span><br><span class="line">    r = <span class="literal">null</span>;</span><br><span class="line">    looped = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前广播已经完成，进行如下处理：</p><ol><li>如果要求发送广播结果，执行 <code>performReceiveLocked</code> 方法</li><li>将当前广播加入历史记录</li><li>调用 AMS 的 <code>addBroadcastStatLocked</code> 方法记录当前广播</li><li>调用 <code>mDispatcher.retireBroadcastLocked</code> 方法</li><li>结束本轮循环，判断下一个广播是否需要发送</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do &#123; ...</span></span><br><span class="line">    <span class="keyword">if</span> (!r.deferred) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">receiverUid</span> <span class="operator">=</span> r.getReceiverUid(r.receivers.get(r.nextReceiver));</span><br><span class="line">        <span class="keyword">if</span> (mDispatcher.isDeferringLocked(receiverUid)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If this is the only (remaining) receiver in the broadcast, &quot;splitting&quot;</span></span><br><span class="line">            <span class="comment">// doesn&#x27;t make sense -- just defer it as-is and retire it as the</span></span><br><span class="line">            <span class="comment">// currently active outgoing broadcast.</span></span><br><span class="line">            BroadcastRecord defer;</span><br><span class="line">            <span class="keyword">if</span> (r.nextReceiver + <span class="number">1</span> == numReceivers) &#123;</span><br><span class="line">                ...</span><br><span class="line">                defer = r;</span><br><span class="line">                mDispatcher.retireBroadcastLocked(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Nontrivial case; split out &#x27;uid&#x27;s receivers to a new broadcast record</span></span><br><span class="line">                <span class="comment">// and defer that, then loop and pick up continuing delivery of the current</span></span><br><span class="line">                <span class="comment">// record (now absent those receivers).</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// The split operation is guaranteed to match at least at &#x27;nextReceiver&#x27;</span></span><br><span class="line">                defer = r.splitRecipientsLocked(receiverUid, r.nextReceiver);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// Track completion refcount as well if relevant</span></span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> r.splitToken;</span><br><span class="line">                    <span class="keyword">if</span> (token == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// first split of this record; refcount for &#x27;r&#x27; and &#x27;deferred&#x27;</span></span><br><span class="line">                        r.splitToken = defer.splitToken = nextSplitTokenLocked();</span><br><span class="line">                        mSplitRefcounts.put(r.splitToken, <span class="number">2</span>);</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// new split from an already-refcounted situation; increment count</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">curCount</span> <span class="operator">=</span> mSplitRefcounts.get(token);</span><br><span class="line">                        ...</span><br><span class="line">                        mSplitRefcounts.put(token, curCount + <span class="number">1</span>);</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mDispatcher.addDeferredBroadcast(receiverUid, defer);</span><br><span class="line">            r = <span class="literal">null</span>;</span><br><span class="line">            looped = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (r == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the next receiver...</span></span><br><span class="line"><span class="type">int</span> <span class="variable">recIdx</span> <span class="operator">=</span> r.nextReceiver++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep track of when this receiver started, and make sure there</span></span><br><span class="line"><span class="comment">// is a timeout message pending to kill it if need be.</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> <span class="type">BroadcastOptions</span> <span class="variable">brOptions</span> <span class="operator">=</span> r.options;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">nextReceiver</span> <span class="operator">=</span> r.receivers.get(recIdx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">    <span class="comment">// Simple case: this is a registered receiver who gets</span></span><br><span class="line">    <span class="comment">// a direct call.</span></span><br><span class="line">    <span class="type">BroadcastFilter</span> <span class="variable">filter</span> <span class="operator">=</span> (BroadcastFilter)nextReceiver;</span><br><span class="line">    ...</span><br><span class="line">    deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">    <span class="keyword">if</span> (r.receiver == <span class="literal">null</span> || !r.ordered) &#123;</span><br><span class="line">        <span class="comment">// The receiver has already finished, so schedule to</span></span><br><span class="line">        <span class="comment">// process the next one.</span></span><br><span class="line">        ...</span><br><span class="line">        r.state = BroadcastRecord.IDLE;</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束循环，表明已经取到需要发送的广播。取这个广播的下一个需要发送的接收器。</p><p>如果这个接收器是 BroadcastFilter 的实例，表明这个接收器是动态注册的：</p><ol><li><p>不需要启动相应的应用，直接使用 <code>deliverToRegisteredReceiverLocked</code> 方法发送广播到接收器。</p></li><li><p>如果广播接收器已完成处理（在上一步执行方法时使 <code>r.receiver = null</code>），或者不是有序广播，就安排处理下一个广播：将广播状态设为 <code>IDLE</code>，调用 <code>scheduleBroadcastsLocked</code> 发送处理广播队列的消息。</p></li><li><p>最后总是返回。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hard case: need to instantiate the receiver, possibly</span></span><br><span class="line"><span class="comment">// starting its application process to host it.</span></span><br><span class="line"><span class="type">ResolveInfo</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line">    (ResolveInfo)nextReceiver;</span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(</span><br><span class="line">        info.activityInfo.applicationInfo.packageName,</span><br><span class="line">        info.activityInfo.name);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">skip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">receiverUid</span> <span class="operator">=</span> info.activityInfo.applicationInfo.uid;</span><br><span class="line">...</span><br><span class="line"><span class="type">String</span> <span class="variable">targetProcess</span> <span class="operator">=</span> info.activityInfo.processName;</span><br><span class="line"><span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo.uid, <span class="literal">false</span>);</span><br><span class="line">...... <span class="comment">// 处理一些禁止后台启动的情况，将 skip 设为 true</span></span><br><span class="line"><span class="keyword">if</span> (skip) &#123;</span><br><span class="line">    ......</span><br><span class="line">    r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">    r.receiver = <span class="literal">null</span>;</span><br><span class="line">    r.curFilter = <span class="literal">null</span>;</span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    r.manifestSkipCount++;</span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">r.manifestCount++;</span><br><span class="line"></span><br><span class="line">r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">r.curComponent = component;</span><br><span class="line">r.curReceiver = info.activityInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broadcast is being executed, its package can&#x27;t be stopped.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">            r.curComponent.getPackageName(), <span class="literal">false</span>, r.userId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is this receiver&#x27;s application already running?</span></span><br><span class="line"><span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span> &amp;&amp; !app.killed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                info.activityInfo.applicationInfo.longVersionCode, mService.mProcessStats);</span><br><span class="line">        maybeAddAllowBackgroundActivityStartsToken(app, r);</span><br><span class="line">        processCurBroadcastLocked(r, app, skipOomAdj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123; ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If some unexpected exception happened, just skip</span></span><br><span class="line">        <span class="comment">// this broadcast. </span></span><br><span class="line">        ...... <span class="comment">// finishReceiverLocked; ScheduleBroadcastLocked; state = IDLE;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">    <span class="comment">// restart the application.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not running -- get it started, to be executed when the app comes up.</span></span><br><span class="line"><span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(...)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 应用启动失败，跳过广播</span></span><br><span class="line">    ...... <span class="comment">// finishReceiverLocked; ScheduleBroadcastLocked; state = IDLE;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到这里，表明这个接收器是静态声明的，需要判断是否需要启动接收器所在应用来处理广播。</p><p>判断一些不适合启动接收器应用的情形，跳过当前广播记录。如果判定需要跳过广播（<code>skip = true</code>），安排下个广播发送并返回。</p><p>接下来，调用 <code>PackageManagerService.setPackageStoppedState</code> 方法，设置 Stopped State 为 false。表明这个软件包不能被停止。</p><p>如果接收者进程已运行，则调用 <code>processCurBroadcastLocked</code> 方法直接发送广播给该进程，然后返回。如果该过程中抛出 RuntimeException 异常，则跳过当前广播记录并返回。</p><p>如果接收者进程尚未启动，则调用 AMS 的 <code>startProcessLocked</code> 方法拉起该进程。如果启动失败，则跳过当前广播记录并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    maybeAddAllowBackgroundActivityStartsToken(r.curApp, r);</span><br><span class="line">    mPendingBroadcast = r;</span><br><span class="line">    mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startProcessLocked</code> 方法是异步的，这里并不会等待进程启动完成后返回，再处理广播。因此设定 <code>mPendingBroadcast </code> 值为当前正在处理的广播记录，<code>mPendingBroadcastRecvIndex</code> 为当前处理的接收者。到这里整个方法就结束了，而这个待处理广播的发送也不在这个方法内完成，而是在进程启动完成时通过 AMS 调用相应方法处理的。前面判断 <code>mPendingBroadcast</code> 不为 <code>null</code> 时直接返回，进程完成后才继续处理，保证了有序广播总是在前一个接收器处理完之后才向下个接收器发送。</p><p>进程启动完成时，ActivityThread 会调用 AMS 的 attachApplication 方法，进一步调用 BroadcastQueue.sendPendingBroadcastsLocked 方法，最终将广播发送到启动的进程。</p><p><img src="/images/2020-02-10-Broadcast-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity.svg" alt="进程启动接收广播时序图" /></p><h4 id="发送广播到接收者"><a class="markdownIt-Anchor" href="#发送广播到接收者"></a> 发送广播到接收者</h4><h5 id="processcurbroadcastlocked"><a class="markdownIt-Anchor" href="#processcurbroadcastlocked"></a> <code>processCurBroadcastLocked</code></h5><p>调用 ActivityThread.ApplicationThread 的 <code>scheduleReceiver</code> 方法，向接收者进程发送广播 Intent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processCurBroadcastLocked</span><span class="params">(BroadcastRecord r,</span></span><br><span class="line"><span class="params">        ProcessRecord app, <span class="type">boolean</span> skipOomAdj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...... <span class="comment">// 一些异常判断</span></span><br><span class="line"></span><br><span class="line">    r.receiver = app.thread.asBinder();</span><br><span class="line">    r.curApp = app;</span><br><span class="line">    app.curReceivers.add(r);</span><br><span class="line">    ...... <span class="comment">// 通知 AMS 进程状态和优先级变更</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the application to launch this receiver.</span></span><br><span class="line">    r.intent.setComponent(r.curComponent);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.curReceiver,</span><br><span class="line">                mService.compatibilityInfoForPackage(r.curReceiver.applicationInfo),</span><br><span class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">                app.getReportedProcState());</span><br><span class="line">        ...</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!started) &#123;...&#125; <span class="comment">// 接收者进程启动失败，从 ProcessRecord 中移除广播记录。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="delivertoregisteredreceiverlocked"><a class="markdownIt-Anchor" href="#delivertoregisteredreceiverlocked"></a> <code>deliverToRegisteredReceiverLocked</code></h5><p>检查广播发送者是否有权限发送这个广播，广播接收器是否有权限接收这个广播。如果没有相应权限，则设置该广播结束。否则，将 BroadcastRecord 的成员变量传入 <code>performReceiveLocked</code> 发送该广播。</p><h5 id="performreceivelocked"><a class="markdownIt-Anchor" href="#performreceivelocked"></a> <code>performReceiveLocked</code></h5><p>使用单向 Binder 调用异步地向接收器发送广播 Intent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span><br><span class="line"><span class="params">        Intent intent, <span class="type">int</span> resultCode, String data, Bundle extras,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have an app thread, do the call through that so it is</span></span><br><span class="line">            <span class="comment">// correctly ordered with other one-way calls.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.getReportedProcState());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;...&#125; <span class="comment">//throw ex</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">//throw RemoteException</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于具有 ApplicationThread 的一般应用，通过 Binder 调用 scheduleRegisteredReceiver<code>方法，进一步调用</code>InnerReceiver.performReceive` 方法。</li><li>对于没有 ProcessRecord 的系统进程，直接调用 <code>InnerReceiver.performReceive</code> 方法。</li></ul><h5 id="loadedapkreceiverdispatcherinnerreceiverperformreceive"><a class="markdownIt-Anchor" href="#loadedapkreceiverdispatcherinnerreceiverperformreceive"></a> <code>LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive</code></h5><p>该方法是对其父类的 <code>performReceive</code> 方法的包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performReceive</span><span class="params">(Intent intent, <span class="type">int</span> resultCode, String data,</span></span><br><span class="line"><span class="params">        Bundle extras, <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Args</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Args</span>(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="literal">null</span> || !mActivityThread.post(args.getRunnable())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">            ...</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法初始化一个 LoadedApk.ReceiverDispatcher.Args 对象，这个类型是 BroadcastReceiver.PendingResult 的子类。通过 <code>getRunnable</code> 方法返回一个 Runnable，接下来在 if 语句中向 ActivityThread 的 Handler 发送该 Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Runnable <span class="title function_">getRunnable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> mReceiver;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ordered</span> <span class="operator">=</span> mOrdered;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> mCurIntent;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="literal">null</span> || intent == <span class="literal">null</span> || mForgotten) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sendFinished(mgr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            receiver.setPendingResult(<span class="built_in">this</span>);</span><br><span class="line">            receiver.onReceive(mContext, intent);;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sendFinished(mgr);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先调用 <code>setPendingResult</code> 设置接收器收到的返回结果，接着执行接收器的 <code>onReceive</code> 方法。如果执行 <code>onReceive</code> 或者发送 Runnable 过程出现异常，就会调用 <code>sendFinished</code> 方法。这个方法传入广播的返回结果到 AMS 的 <code>finishReceiver</code> 方法，以通知 AMS 该有序广播处理完毕，继续处理下一个目标。</p><h5 id="finishreceiverlocked"><a class="markdownIt-Anchor" href="#finishreceiverlocked"></a> <code>finishReceiverLocked</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">finishReceiverLocked</span><span class="params">(BroadcastRecord r, <span class="type">int</span> resultCode,</span></span><br><span class="line"><span class="params">        String resultData, Bundle resultExtras, <span class="type">boolean</span> resultAbort, <span class="type">boolean</span> waitForServices)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> r.state;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityInfo</span> <span class="variable">receiver</span> <span class="operator">=</span> r.curReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">finishTime</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">elapsed</span> <span class="operator">=</span> finishTime - r.receiverTime;</span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    ...... <span class="comment">// 调整活动优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re abandoning this broadcast before any receivers were actually spun up,</span></span><br><span class="line">    <span class="comment">// nextReceiver is zero; in which case time-to-process bookkeeping doesn&#x27;t apply.</span></span><br><span class="line">    <span class="keyword">if</span> (r.nextReceiver &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.duration[r.nextReceiver - <span class="number">1</span>] = elapsed;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 记录处理广播耗时过长的应用</span></span><br><span class="line">    r.receiver = <span class="literal">null</span>;</span><br><span class="line">    r.intent.setComponent(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.curApp != <span class="literal">null</span> &amp;&amp; r.curApp.curReceivers.contains(r)) &#123;</span><br><span class="line">        r.curApp.curReceivers.remove(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.curFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = <span class="literal">null</span>;</span><br><span class="line">    r.curReceiver = <span class="literal">null</span>;</span><br><span class="line">    r.curApp = <span class="literal">null</span>;</span><br><span class="line">    mPendingBroadcast = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    r.resultCode = resultCode;</span><br><span class="line">    r.resultData = resultData;</span><br><span class="line">    r.resultExtras = resultExtras;</span><br><span class="line">    <span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">        r.resultAbort = resultAbort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.resultAbort = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 处理 waitForServices</span></span><br><span class="line">    r.curComponent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We will process the next receiver right now if this is finishing</span></span><br><span class="line">    <span class="comment">// an app receiver (which is always asynchronous) or after we have</span></span><br><span class="line">    <span class="comment">// come back from calling a receiver.</span></span><br><span class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法将 <code>AMS.finishReceiver</code> 方法传入的广播结果记录到对应的 BroadcastRecord 中，这样下个广播接收者就能收到更新的结果。</p><h5 id="broadcasttimeoutlocked"><a class="markdownIt-Anchor" href="#broadcasttimeoutlocked"></a> <code>broadcastTimeoutLocked</code></h5><p>这个方法排除一些特定场景的例外后，强制完成广播，触发 ANR。</p><p>排除的场景包括：</p><ol><li>系统尚未启动完成；</li><li>这个广播豁免了超时；</li><li>广播启动了服务，而服务被延迟启动；</li><li>应用处于调试状态。</li></ol><p>不同的广播队列超时时间不同，详见 <a href="#broadcastqueueforintent">broadcastQueueForIntent</a>。</p><h3 id="activitythread"><a class="markdownIt-Anchor" href="#activitythread"></a> ActivityThread</h3><h5 id="applicationthreadschedulereceiver"><a class="markdownIt-Anchor" href="#applicationthreadschedulereceiver"></a> <code>ApplicationThread.scheduleReceiver</code></h5><p>将收到的广播结果封装到 ActivityThread.ReceiverData 对象中，该类型是 BroadcastReceiver.PendingResult 的子类。向 ActivityThread 的 Handler 发送 <code>RECEIVER</code> 消息和 ReceiverData 对象，Handler 收到消息后调用 <code>handleReceiver</code> 方法；</p><h4 id="applicationthreadscheduleregisteredreceiver"><a class="markdownIt-Anchor" href="#applicationthreadscheduleregisteredreceiver"></a> <code>ApplicationThread.scheduleRegisteredReceiver</code></h4><p>通过 <code>updateProcessState</code> 更新进程状态，再调用 <code>InnerReceiver.performReceive</code> 方法。</p><h4 id="handlereceiver"><a class="markdownIt-Anchor" href="#handlereceiver"></a> <code>handleReceiver</code></h4><p>这个方法在 <code>ActivityThread</code> 中定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleReceiver</span><span class="params">(ReceiverData data)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line"></span><br><span class="line">    Application app;</span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    ContextImpl context;</span><br><span class="line">    ...... <span class="comment">// 获取 app, receiver, context</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sCurrentBroadcastIntent.set(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="literal">null</span>) &#123;</span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能和代码都类似于 <code>Args.getRunnable</code> 返回的 Runnable 方法，设置 PendingResult，调用 <code>onReceive</code> 方法，并在方法完成后通知 AMS 完成广播。</p><h3 id="broadcastreceiver"><a class="markdownIt-Anchor" href="#broadcastreceiver"></a> BroadcastReceiver</h3><p>BroadcastReceiver 接收到广播后，可以使用 <code>getResult</code> 获取上个接收器返回的结果，使用 <code>setResult</code> 系列方法来设置结果传给下个广播接收器，或者使用 <code>abortBroadcast</code> 方法中止广播向下一个接收器传递。这一系列方法操作的是 BroadcastReceiver.PendingResult 对象。</p><h4 id="setpendingresult"><a class="markdownIt-Anchor" href="#setpendingresult"></a> <code>setPendingResult</code></h4><p>设置 mPendingResult 变量的值。<code>ActivityThead.handleReceiver</code> 和 <code>Args.getRunnable</code> 方法发送广播时，调用该方法设置接收器结果。</p><h4 id="完成广播"><a class="markdownIt-Anchor" href="#完成广播"></a> 完成广播</h4><p><code>Args.getRunnable</code> 和 <code>handleReceiver</code> 在广播处理完返回时，都会调用 <code>PendingResult.finish</code> 方法，该方法会调用 <code>PendingResult.sendFinished</code> 方法。如果处理广播中出现异常，则会直接调用 <code>sendFinished</code> 方法。</p><p><code>sendFinished</code> 方法禁止广播结果传递文件描述符，接着传入广播结果（可能被接收器更改）到 AMS 的 <code>finishReceiver</code> 方法。</p><p><code>AMS.finishReceiver</code> 方法找到广播所在广播队列及对应的广播记录，传入广播结果到 <code>BroadcastQueue.finishReceiverLocked</code> 方法。接着，根据其返回值判定是否调用 <code>BroadcastQueue.processNextBroadcastLocked</code> 方法推动下次广播发送。</p><h3 id="broadcastqueueforintent"><a class="markdownIt-Anchor" href="#broadcastqueueforintent"></a> <code>broadcastQueueForIntent</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue <span class="title function_">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOnOffloadQueue(intent.getFlags())) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> mOffloadBroadcastQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isFg</span> <span class="operator">=</span> (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOnOffloadQueue</span><span class="params">(<span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mEnableOffloadQueue &amp;&amp; ((flags &amp; Intent.FLAG_RECEIVER_OFFLOAD) != <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法返回 Intent 对应的广播队列。AMS 中定义了三个广播队列：<code>mFgBroadcastQueue, mBgBroadcastQueue, mOffloadBroadcastQueue</code>，分别用于前台的接收器、后台的接收器，和“长”广播（例如 <code>BOOT_COMPLETED</code>，通过 <code>FLAG_RECEIVER_OFFLOAD</code> 标志来判定）。</p><p>这三个队列有不同的广播超时时间：前台广播是 10 秒，后台广播和长广播是 60 秒。</p><h3 id="collectreceivercomponents"><a class="markdownIt-Anchor" href="#collectreceivercomponents"></a> <code>collectReceiverComponents</code></h3><p>这个方法调用 <code>PackageManagerService.queryIntentReceivers</code> 方法，</p><h3 id="mreceiverresolverqueryintent"><a class="markdownIt-Anchor" href="#mreceiverresolverqueryintent"></a> <code>mReceiverResolver.queryIntent</code></h3><p>查询指定用户的接收器使用的是 <code>mReceiverResolver.queryIntent</code> 方法，TODO</p><h1 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h1><p>Q: <strong>从未打开过的 APP(包括系统 APP)可以接收 <code>ACTION_BOOT_COMPLETED</code> 广播么？</strong></p><p>A: Android 8.0 开始对后台执行进行限制，应用无法在清单注册一些隐式广播的接收器。但是，<code>ACTION_BOOT_COMPLETED</code> 广播被豁免这一限制。</p><p>从未打开的非系统应用在软件包管理器(PackageManager)中处于停止状态(stopped state)。只有具有 <code>FLAG_INCLUDE_STOPPED_PACKAGES</code> 广播才可以被停止状态的应用接收。</p><p>而系统广播 <code>ACTION_BOOT_COMPLETE</code> 不具有该标志，而是有 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> 标志，这意味着该广播不能被从未打开过的应用接收，但是系统应用不受该限制，因此该广播可以被从未打开过的系统应用接收。</p><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1><ol><li>广播概览, <a href="https://developer.android.com/guide/components/broadcasts?hl=zh_cn">https://developer.android.com/guide/components/broadcasts?hl=zh_cn</a></li><li>Android系统源码分析-Broadcast注册和注销, <a href="https://www.jianshu.com/p/882cf3911772">https://www.jianshu.com/p/882cf3911772</a></li><li>Android系统源码分析-Broadcast发送, <a href="https://www.jianshu.com/p/c5323a22f3f3">https://www.jianshu.com/p/c5323a22f3f3</a></li><li>安装APP后不启动，实现开机启动APP的Activity或者Service, <a href="https://segmentfault.com/a/1190000015851405">https://segmentfault.com/a/1190000015851405</a></li></ol><h1 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/content/Context.java</span><br><span class="line">frameworks/base/core/java/android/content/BroadcastReceiver.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/IntentResolver.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</span><br><span class="line">frameworks/base/services/core/java/com/android/server/am/ReceiverList.java</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler 源码分析</title>
      <link href="/posts/249898534/"/>
      <url>/posts/249898534/</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a class="markdownIt-Anchor" href="#背景知识"></a> 背景知识</h1><h2 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h2><p>类似其他操作系统的相应概念，Android 的进程拥有独立的虚拟内存空间，而线程与同一进程内的其他线程共享内存，只拥有各自的栈空间、程序计数器和寄存器等少量独占资源。<br />当 Android 启动一个之前未运行的应用的组件时，会为其启动一个包含单个主线程&quot;main&quot;的新的 Linux 进程。默认情况下，同一应用的所有组件会在此进程内启动，并且使用同一执行线程。<br />开发者可以人为安排组件在单独的进程中运行，并且为进程创建额外的线程。</p><h2 id="android-线程"><a class="markdownIt-Anchor" href="#android-线程"></a> Android 线程</h2><p>每个 Android 应用都有一个主线程，也称界面线程，负责绘制 UI，处理用户交互以及接收生命周期事件。Android UI 操作不是线程安全的，这些操作必须在主线程执行。<br />为了不拖慢主线程，任何长时间运行的计算和操作都应在后台线程完成，避免 ANR。使用多线程还可以充分利用多核处理器的优势，通过并行提高运行速度。</p><span id="more"></span><ol><li>创建线程的方法<ol><li>Java 的线程方法<ol><li>重载 Thread.run() 方法</li><li>实现 Runnable 类</li></ol></li><li>Android 的线程方法<ol><li>AsyncTask</li><li>IntentService</li><li>HandlerThread</li><li>Executors 中创建线程池 (<code>newFixedThreadPool</code>, <code>newScheduledThreadPool</code>, <code>newWorkStealingPool</code>)</li></ol></li></ol></li></ol><p>从其他线程访问主线程的方法</p><ol><li><code>Activity.runOnUiThread(Runnable)</code></li><li><code>View.post(Runnable)</code></li><li><code>View.postDelayed(Runnable, long)</code></li><li>使用 Handler</li></ol><h2 id="handler-介绍"><a class="markdownIt-Anchor" href="#handler-介绍"></a> Handler 介绍</h2><p><code>Handler</code> 是 Android 系统线程管理框架的一部分，使用消息队列实现线程之间的通信。<br /><code>Handler</code> 允许你发送和处理关联到线程的 <code>MessageQueue</code> 的 <code>Message</code> 和 <code>Runnable</code> 对象。新的 <code>Handler</code> 会绑定到创建者线程的消息队列上。</p><p>消息驱动机制的四要素：</p><ol><li>接收消息的“消息队列”：<code>MessageQueue</code></li><li>阻塞式地从消息队列中接收消息并进行处理的“线程”:<code>Thread</code> &amp; <code>Looper</code></li><li>可发送的“消息的格式”: <code>Message</code></li><li>“消息发送函数”: <code>Handler.post(Runnable)</code> &amp; <code>Handler.sendMessage(Message)</code></li></ol><p>Handler 的两大主要作用：</p><ol><li>安排 <code>Message</code> 和 <code>Runnable</code> 在未来某个时刻运行。</li><li>安排在其他线程中执行的动作。</li></ol><p>使用 Handler：</p><ul><li><p>接收者线程：</p><ol><li>如果是子线程，判断其是否已有 <code>Looper</code>，如果没有，运行 <code>Looper.prepare()</code></li><li>实例化 Handler 对象 <code>mHandler</code>，实现 <code>handleMessage</code> 方法（重载方法或实现 <code>Callback</code> 接口）。</li><li>如果接收者是子线程，调用 <code>Looper.loop()</code> 方法，使得 Looper 调用 <code>handleMessage</code> 方法对消息进行处理；如果是主线程，启动时已经调用了 <code>Looper.prepare()</code> <code>Looper.loop()</code> 方法。</li><li>如果子线程不需要再处理消息，调用 <code>Looper.myLooper().quit()</code> 退出消息轮询</li></ol></li><li><p>发送者线程：</p><ol><li>创建 Message 对象，设置 Message 的参数</li><li>使用 <code>mHandler.sendMessage(Message)</code> 方法将 Message 传入 Handler 的消息队列</li></ol></li></ul><p>Handler 常用方法：<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, <code>sendMessageDelayed(Message, long)</code></p><h2 id="looper-介绍"><a class="markdownIt-Anchor" href="#looper-介绍"></a> Looper 介绍</h2><p>Looper 负责处理 MessageQueue 中的 Message。</p><p>一个线程内最多只有一个 Looper 对象，否则会抛出异常。</p><p>使用 Looper：<br />1. 判定是否已有 <code>Looper</code> 并 <code>Looper.prepare()</code><br />2. 做一些准备工作<br />3. 调用<code>Looper.loop()</code>，线程进入阻塞态</p><h1 id="handler-源码分析"><a class="markdownIt-Anchor" href="#handler-源码分析"></a> Handler 源码分析</h1><p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/classes.svg" alt="Handler 相关类型" /></p><h2 id="handler"><a class="markdownIt-Anchor" href="#handler"></a> Handler</h2><p><code>frameworks/base/core/java/android/os/Handler.java</code></p><p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MessageLoop.png" alt="Handler 工作原理" /></p><p>重要成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> mAsynchronous;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">IMessenger mMessenger;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  mLooper = Looper.myLooper();</span><br><span class="line">  <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">  mQueue = mLooper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">  mLooper = looper;</span><br><span class="line">  mQueue = looper.mQueue;</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种构造方法首先获取当前线程的 Looper。如果当前线程没有初始化 Looper，则会抛出异常。第二种构造方法直接传入要使用的 Looper 作为参数。之后初始化 <code>mCallback</code> 和 <code>mAsynchronous</code> 成员。</p><h3 id="其他方法"><a class="markdownIt-Anchor" href="#其他方法"></a> 其他方法</h3><p><code>post</code> 系列方法会调用 <code>getPostMessage</code> 方法将 Runnable 包装为 Message，然后使用 <code>sendMessage</code> 系列方法发送。</p><p><code>sendMessage</code> 系列方法最终会调用 <code>enqueueMessage</code> 私有方法，最后调用 <code>MessageQueue.enqueueMessage</code> 方法加入消息队列。</p><p><code>removeMessages</code> 和 <code>removeCallbacks</code> 系列方法会调用 <code>MessageQueue.removeMessages</code> 方法从消息队列中移除指定消息。</p><p><code>obtainMessage</code> 系列方法会调用 <code>Message.obtian</code> 系列方法，从消息池中获取一个 <code>Message</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">  <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">  m.callback = r;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getPostMessage</code> 方法将 Runnable 对象赋值给 Message 对象的 <code>callback</code> 成员变量，从而将其包装为 Message。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatchMessage</code> 方法处理消息的方式有三种：</p><ol><li>先检查 Message 对象的 <code>callback</code> 是否非空，若是，表明这个 Message 是使用 <code>post</code> 方法发送的，运行该 Runnable。</li><li>否则，检查是否初始化了 <code>mCallback</code> 成员变量，若是，运行其中的 <code>handleMessage</code> 方法。mCallback 成员变量可以在调用 Handler 构造方法时传入 Callback 接口的实现来初始化。</li><li>如果没有实现 Callback 接口，或上一步方法返回值为 <code>true</code>，则运行 Handler 本身的 <code>handleMessage</code> 方法。</li></ol><p><code>getMain</code> 方法会返回静态成员变量 <code>MAIN_THREAD_HANDLER</code> 的值。如果该变量没有初始化，就创建一个使用主线程 Looper 对象初始化的 Handler 对象，对该变量赋值并返回。</p><p><code>createAsync</code> 系列方法调用 Handler 对应构造方法，其中<code>async=true</code></p><p><code>runWithScissors</code> TODO</p><p><code>getIMessenger</code> TODO</p><h2 id="looper"><a class="markdownIt-Anchor" href="#looper"></a> Looper</h2><p><code>frameworks/base/core/java/android/os/Looper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Looper</span> &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Observer sObserver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-2"><a class="markdownIt-Anchor" href="#构造方法-2"></a> 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法是私有方法，只能通过 <code>Looper.prepare()</code> 来初始化 <code>Looper</code>。</p><p>接下来就看看<code>Looper.prepare()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">       prepare(<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先尝试获取静态线程局部变量 <code>sThreadLocal</code>，如果不为空，就说明已经创建过 <code>Looper</code> 对象，抛出<code>RuntimeException</code>；否则，就将 <code>sThreadLocal</code> 的值设置为新创建的 <code>Looper</code> 对象。</p><p>同一线程内的所有对象共享同一个静态变量 <code>sThreadLocal</code>，因此能保证一个线程至多只有一个 <code>Looper</code> 对象。</p><p>启动主线程相关代码：</p><p><code>frameworks/base/core/java/android/app/ActiviytThead.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  Looper.prepareMainLooper();</span><br><span class="line">  ......</span><br><span class="line"><span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line">......</span><br><span class="line">  Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程启动时调用 <code>PrepareMainLooper()</code> 方法。这个方法会调用 <code>prepare(quitAllowed)</code> 方法，其中 <code>quitAllow=False</code>，之后将 <code>sMainLooper</code> 赋值为自身的 Looper。其他线程可以使用 <code>Looper.getMainLooper()</code> 方法来访问主线程的 Looper。<br />实例化 Looper 之后，创建 ActivityThread 实例，将线程注册到系统服务，最后调用 <code>Looper.loop()</code> 进入消息处理循环。</p><p>至此，应用程序的启动过程就完成了。正常情况下主线程会一直处于消息循环中，这样应用程序组件就可以利用消息处理机制来实现业务逻辑。</p><h3 id="消息循环"><a class="markdownIt-Anchor" href="#消息循环"></a> 消息循环</h3><p>看看<code>Looper.loop()</code>怎样进行消息处理循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;...&#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loop()</code> 方法会进入一个死循环，不断从 MessageQueue 取出消息，交给 Handler 处理。</p><p>如果消息队列为空，<code>queue.next()</code> 方法会阻塞，直到有消息进来，再取出消息返回。除非调用<code>quit()</code> 或 <code>quitSafely()</code> 方法结束轮询，<code>queue.next()</code> 才会返回<code>null</code>，结束循环。</p><h2 id="messagequeue"><a class="markdownIt-Anchor" href="#messagequeue"></a> MessageQueue</h2><p><code>frameworks/base/core/java/android/os/MessageQueue.java</code></p><p><code>frameworks/base/core/jni/android_os_MessageQueue.cpp</code></p><h3 id="构造方法-3"><a class="markdownIt-Anchor" href="#构造方法-3"></a> 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">  mQuitAllowed = quitAllowed;</span><br><span class="line">  mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出主要工作在 <code>nativeInit()</code>函数进行，这是一个 JNI 方法，在讨论线程阻塞与唤醒时再回到这里。</p><h3 id="插入与移除消息"><a class="markdownIt-Anchor" href="#插入与移除消息"></a> 插入与移除消息</h3><p>消息队列以链表的方式储存，MessageQueue 的 <code>mMessages</code> 成员变量保存链表的第一个消息。</p><p><code>enqueueMessage</code> 方法插入消息到队列，<code>removeMessages</code> 方法移除消息。插入和移除消息时会保证消息队列总是按 <code>when</code> 属性递增的顺序排列，也就是链表的头总是最紧急要处理的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mBlocked = true</code> 时，以下几种情况下，插入消息会设置 <code>needWake = true</code>，唤醒接收者线程：</p><ol><li>消息队列为空(<code>p == null</code>)</li><li>消息设置为立即处理(<code>when == 0</code>)</li><li>消息预定的时刻早于队列头部的消息(<code>when &lt; p.when</code>)</li><li>消息队列被同步屏障暂停，而插入的消息是最早一条要处理的异步消息</li></ol><p>如果需要唤醒，会调用 <code>nativeWake(mPtr)</code> 方法唤醒线程。我们待会讨论这个方法。</p><h3 id="插入与移除同步屏障"><a class="markdownIt-Anchor" href="#插入与移除同步屏障"></a> 插入与移除同步屏障</h3><p><code>postSyncBarrier</code> 方法会插入一条同步屏障(Sync Barrier)消息到消息队列。<code>next</code> 方法读取到同步屏障消息后，会停止处理同步消息，只处理异步消息。如果不设置生效时间或设置为 0，屏障将立即生效。该方法返回一个 token，用于调用 <code>removeSyncBarrier</code> 方法移除该同步屏障。</p><p><code>removeSyncBarrier</code> 方法会移除插入的同步屏障消息，使消息队列继续处理同步消息。</p><h3 id="取下一条消息"><a class="markdownIt-Anchor" href="#取下一条消息"></a> 取下一条消息</h3><p><code>MessageQueue.next()</code> 方法将下一条待处理的消息返回给 Looper。其内部实现了阻塞线程、同步屏障、定时处理消息、处理空闲情况等机制。没有消息时，该方法会阻塞线程，直到新的消息到达，或者定时器到期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>首先获取 NativeMessageQueue 对象的指针。如果该指针为空，说明 Native 对象没有正确初始化，返回 null 结束消息循环。</p><p>接下来进入取待处理消息的循环。</p><p>若下次查询的超时时间不为0，Binder.flushPendingCommands()；（？）</p><p>调用 JNI 方法 <code>nativePollOnce</code>，这个方法就是没有消息时阻塞的源头，先放在一边。</p><p>接着看下面的过程，仍在 for 循环内：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prevMsg = msg;</span><br><span class="line">            msg = msg.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">            <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">            nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Got a message.</span></span><br><span class="line">            mBlocked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                prevMsg.next = msg.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = msg.next;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No more messages.</span></span><br><span class="line">        nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">    <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">    <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">        pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">        mBlocked = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">        mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mMessages</code> 成员变量作为链表头，是这一轮循环搜索消息的起始点，临时变量<code>msg</code> 保存要取出的消息。</p><ol><li><p>第 6 到 12 行，如果 <code>msg.target</code> 为空，说明这是一个由 <code>postSyncBarrier</code> 方法设置的同步屏障(Sync Barrier)消息，那么快进 <code>msg</code> 到下一个异步消息。</p></li><li><p>接下来，如果<code>msg</code>不为空，首先判断消息的唤醒时间是否已到，没有到就设置下次唤醒时间为该唤醒时间。否则，从消息队列链表中取出<code>msg</code>：</p></li></ol><ul><li>如果之前有快进过(<code>prevMsg != null</code>)，<code>prevMsg</code> 指向下一个消息。</li><li>否则，<code>mMessages</code> 向前移动。</li></ul><p>最后返回当前消息 <code>msg</code>。<br />如果上一步判断当前消息为空，设置 <code>nextPollTimeoutMillis = -1</code>, 执行<code>nativePollOnce</code> 方法时将一直阻塞，直到有新的消息到达。</p><ol start="3"><li><p>36 到 39 行，如果 <code>mQuitting</code> 变量设置为 <code>true</code>， 现在就是处理退出请求的时候：扔掉剩余请求，并返回 null。</p></li><li><p>44 行开始，就是处理 IdleHandler 的代码。如果第一次遇到空闲（没有消息要处理）的情况，初始化 <code>pendingIdleHandlerCount</code> 计数。</p></li><li><p>接下来，如果没有 IdleHandler 需要运行，设置<code>mBlocked = true</code>，这会通知 <code>enqueueMessage</code> 方法在加入消息时唤醒当前线程。<br />这一节的最后，如果之前没有初始化 <code>mPendingIdleHandlers</code>，执行初始化。<br />离开临界区，继续处理 IdleHandlerr：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">    mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line"><span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">nextPollTimeoutMillis = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>遍历要处理的 IdleHandler，执行其 <code>queueIdle()</code> 方法。如果该方法返回 <code>false</code>，表明整个消息循环中该方法只需执行一次，就从 <code>mIdleHandlers</code> 中移除对应的 IdleHandler。</p><p>最后重设 <code>pendingIdleHandlerCount</code> 计数为 0，这样下个循环就不会再次处理 IdleHandler 相关逻辑。</p><p>总结一下整个方法的行为：</p><p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/next_activity.svg" alt="MessageQueue.next" /></p><h2 id="线程阻塞与唤醒"><a class="markdownIt-Anchor" href="#线程阻塞与唤醒"></a> 线程阻塞与唤醒</h2><h3 id="初始化-nativemessagequeue"><a class="markdownIt-Anchor" href="#初始化-nativemessagequeue"></a> 初始化 NativeMessageQueue</h3><p>前面 MessageQueue 初始化时，调用 <code>nativeInit()</code> 初始化其 C++ 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> <span class="built_in">NativeMessageQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">incStrong</span>(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建了 NativeMessageQueue 对象并增加其强引用计数，返回对象指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::<span class="built_in">NativeMessageQueue</span>() :</span><br><span class="line">        <span class="built_in">mPollEnv</span>(<span class="literal">NULL</span>), <span class="built_in">mPollObj</span>(<span class="literal">NULL</span>), <span class="built_in">mExceptionObj</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::<span class="built_in">getForThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">false</span>);</span><br><span class="line">        Looper::<span class="built_in">setForThread</span>(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法尝试获取当前线程的 C++ 层 Looper 对象，如果没有获取到，则新建一个并绑定到当前线程。</p><p>来看看这个 C++ 层的 Looper：<br /><code>system/core/libutils/include/utils/Looper.h</code>、<br /><code>system/core/libutils/Looper.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks)</span><br><span class="line">    : <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks),</span><br><span class="line">      <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mPolling</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mResponseIndex</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd.<span class="built_in">reset</span>(<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd.<span class="built_in">get</span>() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法使用 <code>eventFd</code> 系统调用获取了 <code>mWakeEventFd</code>，作为后续 <code>epoll</code> 用于唤醒的文件描述符。</p><p>有了 Fd，再进入 <code>rebuildEpollLocked()</code> 调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Close old epoll instance if we have one.</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the new epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd.<span class="built_in">reset</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="built_in">get</span>(), &amp;eventItem);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 6 行，通过系统调用 <code>epoll_create1</code> 初始化一个 epoll 实例，之后创建 epoll_event 结构 <code>eventItem</code> 并设置 <code>events</code> 属性，将 <code>fd</code> 设置为之前创建的 <code>mWakeEventFd</code>。</p><p>在第 13 行，通过系统调用 <code>epoll_ctl</code> 将 <code>eventItem</code> 注册到 epoll。</p><p>epoll  允许我们对多个文件描述符进行监听。注册监听的 <code>fd</code> 之后，调用 <code>epoll_wait</code> 函数，当 <code>fd</code> 指向的对象数据可用时，<code>epoll_wait</code> 函数就会返回，同时从传入的<code>events</code>指针返回发生改变的 <code>fd</code> 对应的 <code>eventItem</code>。</p><h3 id="阻塞"><a class="markdownIt-Anchor" href="#阻塞"></a> 阻塞</h3><p>前面说过如果消息队列没有消息，线程就会被阻塞。阻塞的调用路径是 <code>Looper.loop() -&gt; MessageQueue.next() -&gt; MessageQueue.nativePollOnce(long , int)</code>。我们从 <code>nativePollOnce</code> 开始继续追踪。</p><p>JNI 方法 <code>nativePollOnce</code> 调用 <code>NativeMessageQueue::pollOnce</code> 方法，进一步调用 <code>Looper::pollOnce</code> 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      ......</span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来到 <code>pollInner</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4行就是关键所在。通过执行系统调用 <code>epoll_wait</code> ，线程将会阻塞，直到注册的 fd 有新数据或者到达超时时间才会返回。前面 MessageQueue 初始化时注册了 <code>mWakeEventFd</code> ，当它有新数据时 <code>epoll_wait</code> 就会返回，解除阻塞。由此推测，唤醒线程的方法 <code>nativeWake</code> 正是通过向 <code>mWakeEventFd</code> 写数据的操作，来解除阻塞，实现其功能的。这里写入的数据并不重要，只是利用 <code>epoll</code> 机制提供的阻塞和唤醒功能。</p><p>解除阻塞后，接下来进入事件处理的过程。遍历返回的 <code>eventItems</code>，检查是否有 fd 与 <code>mWakeEventFd</code> 相同。如果有，执行 <code>awoken</code> 方法。该方法不断读取 <code>mWakeEventFd</code> 以清空其内容，便于下次使用。</p><p>这里省略了大量与处理 Native 层消息相关的代码，因为这与本次主题无关。</p><h3 id="唤醒"><a class="markdownIt-Anchor" href="#唤醒"></a> 唤醒</h3><p><code>nativeWake</code> 用于唤醒功能，调用 <code>NativeMessageQueue::wake()</code>，进一步调用 <code>Looper::wake()</code>。正如之前预测的，该方法向 <code>mWakeEventFd</code> 写入数据，实现其唤醒的功能。</p><h2 id="调用链"><a class="markdownIt-Anchor" href="#调用链"></a> 调用链</h2><p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MessageQueue.svg" alt="MessageQueue" /></p><p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/loop.svg" alt="loop" /></p><p><img src="/images/2020-01-19-Handler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/sendMessage.svg" alt="sendMessage" /></p><h1 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h1><p><strong>Q: Looper 如何保证线程唯一的？</strong></p><p>A: Looper 的构造方法是私有的，只能通过 <code>Looper.prepare()</code> 创建，通过 <code>Looper.myLooper()</code> 获取。</p><p><code>Looper.prepare()</code> 会检查静态线程局部变量 <code>sThreadLocal</code> 的值是否已设定，只有未设定时才会将其设为新建的Looper 对象，否则抛出异常。同一线程内的所有对象共享同一个静态变量<code>sThreadLocal</code> ，因此能保证一个线程至多只有一个 Looper 对象。</p><p><strong>Q: ThreadLocal如何实现数据隔离的？与加锁实现的区别是什么？</strong></p><p>A: 每个 Thread 对象中保存一个 ThreadLocalMap 对象，由 ThreadLocal 中的方法操纵。这个 Map 的 key 是 ThreadLocal 的弱引用，value 就是储存的对象。</p><p>当调用 <code>ThreadLocal.get()</code> 方法时，先判断该 ThreadLocalMap 是否非空，再使用 ThreadLocal 对象作为 key 查询并返回储存的对象。查询用的 hash code 是在ThreadLocal 对象初始化时调用  <code>threadLocalHashCode</code>  生成的。若 ThreadLocalMap 为null，或没有与 key 对应的对象，则调用 <code>setInitialValue()</code> 设初值并返回该值。</p><p>ThreadLocal 和 synchonized 都用于解决多线程并发访问，但是 ThreadLocal 与 synchronized 有本质的区别。</p><ol><li>机制不同<ul><li>synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。</li><li>ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象。</li></ul></li><li>数据共享状态不同<ul><li>synchronized 仅提供一份数据，使得多个线程间通信时能够获得数据共享。</li><li>ThreadLocal 为每个线程提供一份数据，隔离了多个线程对数据的数据共享。</li></ul></li></ol><p><strong>Q: 想在消息队列阻塞前处理一个事件应该如何实现？</strong></p><p>A: 调用 <code>next</code> 方法取下一条消息时，消息队列会在当前消息为空时阻塞，以等待新的消息。通过 <code>addIdleHandler</code> 方法，添加处理空闲状态的代码，可以在下次循环到 <code>nativePollOnce</code> 阻塞之前执行期望的操作。</p><p><strong>Q: 主线程与其他线程的不同之处有哪些？</strong></p><p>A:  主线程在应用启动时由 Android 系统启动，子线程由应用开发者主动开启。主线程会在启动时调用 <code>Looper.prepareMainLooper()</code> 和 <code>Looper.loop()</code> 方法，进入消息循环。主线程进入 <code>Looper.loop()</code> 方法后不会退出消息循环，子线程可以通过 <code>Looper.quit()</code> 退出消息循环。主线程负责处理 UI 事件和 Broadcast 消息，若超时未响应会触发 ANR。</p><p><strong>Q: <code>Message</code> 和 <code>Runnable</code> 在 Handler 中什么区别？</strong></p><p>A:  逻辑是一样的，<code>post</code> 方法中的<code> Runnable</code> 会被封装成 <code>Message</code>，再用 <code>SendMessage</code> 方法发送。</p><p><strong>Q: Handler 如何实现消息定时处理？</strong></p><p>A: 这一功能是在 <code>MessageQueue.next()</code> 方法实现的。MessageQueue 取出消息返回前，会对比该消息的 <code>when</code> 属性与当前时间。如果还没有到设定的时刻，就会设置<code>nextPollTimeoutMillis</code>变量，使得线程在给定的时刻唤醒。否则，就会返回该消息到 Looper，Looper 再调用 <code>dispatchMessage</code> 交给 Handler 处理。</p><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1><ol><li>Android SDK, android.os.Handler</li><li>Android Developers Documentation, <a href="https://developer.android.com/reference/android/os/Handler">https://developer.android.com/reference/android/os/Handler</a></li><li>Android 源码分析 --Handler 机制的实现与工作原理,<a href="https://juejin.im/post/5910522f1b69e6006858b830">https://juejin.im/post/5910522f1b69e6006858b830</a></li><li>Android 消息机制（一）消息队列的创建与循环的开始 Looper与MessageQueue, <a href="https://www.viseator.com/2017/10/22/android_event_1/">https://www.viseator.com/2017/10/22/android_event_1/</a></li><li>Android Handler的使用方式和注意事项, <a href="https://juejin.im/post/5910533dac502e006cfe01cd">https://juejin.im/post/5910533dac502e006cfe01cd</a></li><li>理解 Java 中的 ThreadLocal, <a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
